{"BuggyCode": "int hashTableSize()\n    {\n        return table.size();\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.caffinitas.ohc.tables.OffHeapMap.hashTableSize` reads without synchronization from `this.org.caffinitas.ohc.tables.OffHeapMap.table`. Potentially races with write in method `OffHeapMap.release()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, AtomicLong freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        int bl = builder.getBucketLength();\n        if (bl <= 0)\n            bl = 8;\n        int buckets = (int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE);\n        entriesPerBucket = (int) Util.roundUpToPowerOf2(bl, MAX_TABLE_SIZE);\n        table = Table.create(buckets, entriesPerBucket);\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        if (lf >= 1d)\n            throw new IllegalArgumentException(\"load factor must not be greater that 1\");\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "int hashTableSize()\n{\nreturn table.size();", "LocalizedPatchLength": 42, "CodeLength": 60}
{"BuggyCode": "public boolean initForceBatchStatementsOrdering(TypedMap configMap) {\n        return configMap.getTypedOr(FORCE_BATCH_STATEMENTS_ORDERING, true);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `configMap.getTypedOr(\"achilles.batch.force.statements.ordering\",valueOf(1))` could be null and is dereferenced at line 379."}, "FixedCode": "public boolean initForceBatchStatementsOrdering(TypedMap configMap) {\n        return configMap.getTypedOr(FORCE_BATCH_STATEMENTS_ORDERING, DEFAULT_FORCE_BATCH_STATEMENTS_ORDERING);\n    }", "LocalizedBug": "return configMap.getTypedOr(FORCE_BATCH_STATEMENTS_ORDERING, true);", "LocalizedPatchLength": 67, "CodeLength": 151}
{"BuggyCode": "@Test\n\tpublic void TestEscAposLast() throws IOException {\n\t\t//int [] recordBreaks = new int[] { 0, 75, 146, 218, 290, 362, , ,  };\n\t\tAssert.assertArrayEquals(new int[] { 0 }, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 0, 44)));\n\t\tAssert.assertArrayEquals(new int[] {0, 1}, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 0, 45)));\n\t\tAssert.assertArrayEquals(new int[] {0, 1}, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 0, 46)));\n\t\tAssert.assertArrayEquals(new int[] {1,2,3}, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 19, 140)));\n\t\tAssert.assertArrayEquals(new int[] {1,2,3}, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 26, 140)));\n\t\tAssert.assertArrayEquals(new int[] {1,2,3}, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 43, 140)));\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.InputStreamReader` acquired by call to `getReaderFor(...)` at line 160 is not released after line 160."}, "FixedCode": "@Test\n\tpublic void TestEscAposLast() throws Exception {\n\t\t//int [] recordBreaks = new int[] { 0, 75, 146, 218, 290, 362, , ,  };\n\t\tAssert.assertArrayEquals(new int[] { 0 }, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 0, 44)));\n\t\tAssert.assertArrayEquals(new int[] {0, 1}, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 0, 45)));\n\t\tAssert.assertArrayEquals(new int[] {0, 1}, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 0, 46)));\n\t\tAssert.assertArrayEquals(new int[] {1,2,3}, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 19, 140)));\n\t\tAssert.assertArrayEquals(new int[] {1,2,3}, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 26, 140)));\n\t\tAssert.assertArrayEquals(new int[] {1,2,3}, getRecordIndexesInReader(getReaderFor(\"unenclosed-json-esc2.json\", 43, 140)));\n\t}", "LocalizedBug": "public void TestEscAposLast() throws IOException {", "LocalizedPatchLength": 50, "CodeLength": 873}
{"BuggyCode": "@Test\n    public void shouldReturnTheResourceForAClass() throws IOException {\n        PropertiesManagerForTest manager = new PropertiesManagerForTest(SampleConfig.class, new Properties(),\n                scheduler, expander);\n\n        assertEquals(1, manager.getUrls().size());\n        for(URL url : manager.getUrls()) \n            assertTrue(url.getPath().contains(\"org/aeonbits/owner/loadstrategies/DefaultLoadStrategyTest$SampleConfig\"));\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `manager.getUrls()` could be null and is dereferenced at line 48."}, "FixedCode": "@Test\n    public void shouldReturnTheResourceForAClass() throws IOException {\n        PropertiesManagerForTest manager = \n                new PropertiesManagerForTest(SampleConfig.class, new Properties(), scheduler, expander, loaders);\n\n        manager.load();\n        \n        verify(loaders, times(1)).findLoader(any(URL.class));\n        verify(loaders, times(1)).findLoader(argThat(urlMatches(\n                \"org/aeonbits/owner/loadstrategies/DefaultLoadStrategyTest$SampleConfig.properties\")));\n    }", "LocalizedBug": "assertEquals(1, manager.getUrls().size());\nfor(URL url : manager.getUrls())\nassertTrue(url.getPath().contains(\"org/aeonbits/owner/loadstrategies/DefaultLoadStrategyTest$SampleConfig\"));", "LocalizedPatchLength": 185, "CodeLength": 447}
{"BuggyCode": "static GHDiscussion read(GHTeam team, long discussionNumber) throws IOException {\n        return team.root.createRequest()\n                .setRawUrlPath(team.getUrl().toString() + \"/discussions/\" + discussionNumber)\n                .fetch(GHDiscussion.class)\n                .wrapUp(team);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `team.getUrl()` could be null and is dereferenced at line 114."}, "FixedCode": "static GHDiscussion read(GHTeam team, long discussionNumber) throws IOException {\n        return team.root.createRequest()\n                .setRawUrlPath(getRawUrlPath(team, discussionNumber))\n                .fetch(GHDiscussion.class)\n                .wrapUp(team);\n    }", "LocalizedBug": ".setRawUrlPath(team.getUrl().toString() + \"/discussions/\" + discussionNumber)", "LocalizedPatchLength": 77, "CodeLength": 296}
{"BuggyCode": "private int getCommentsAmount(File file) throws IOException {\n\n\t\tif (!file.exists())\n\t\t\treturn 0;\n\t\tint comments = 0;\n\t\tString currentLine;\n\n\t\tBufferedReader reader = new BufferedReader(new FileReader(file));\n\n\t\twhile ((currentLine = reader.readLine()) != null)\n\t\t\tif (currentLine.startsWith(\"#\"))\n\t\t\t\tcomments++;\n\n\t\treader.close();\n\t\treturn comments;\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileReader` acquired by call to `new()` at line 155 is not released after line 162.\n**Note**: potential exception at line 157"}, "FixedCode": "private int getCommentsAmount(File file) throws IOException {\n\n\t\tif (!file.exists())\n\t\t\treturn 0;\n\t\tint comments = 0;\n\t\tString currentLine;\n\n\t\tBufferedReader reader = null;\n\t\ttry {\n\t\t\treader = new BufferedReader(new FileReader(file));\n\t\t\twhile ((currentLine = reader.readLine()) != null)\n\t\t\t\tif (currentLine.startsWith(\"#\"))\n\t\t\t\t\tcomments++;\n\n\t\t\treturn comments;\n\t\t} catch (IOException e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();\n\t\t}\n\t}", "LocalizedBug": "return comments;", "LocalizedPatchLength": 16, "CodeLength": 354}
{"BuggyCode": "@Override\n    protected void processEvents(int readyCount) throws IOReactorException {\n        processSessionRequests();\n        \n        if (readyCount > 0) {\n            Set<SelectionKey> selectedKeys = this.selector.selectedKeys();\n            for (Iterator<SelectionKey> it = selectedKeys.iterator(); it.hasNext(); ) {\n                \n                SelectionKey key = it.next();\n                processEvent(key);\n                \n            }\n            selectedKeys.clear();\n        }\n        \n        long currentTime = System.currentTimeMillis();\n        if ((currentTime - this.lastTimeoutCheck) >= this.selectTimeout) {\n            this.lastTimeoutCheck = currentTime;\n            Set<SelectionKey> keys = this.selector.keys();\n            synchronized (keys) {\n                processTimeouts(keys);\n            }\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor.processEvents` reads without synchronization from `this.org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor.lastTimeoutCheck`. Potentially races with write in method `DefaultConnectingIOReactor.processEvents(...)`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "@Override\n    protected void processEvents(int readyCount) throws IOReactorException {\n        processSessionRequests();\n        \n        if (readyCount > 0) {\n            Set<SelectionKey> selectedKeys = this.selector.selectedKeys();\n            for (Iterator<SelectionKey> it = selectedKeys.iterator(); it.hasNext(); ) {\n                \n                SelectionKey key = it.next();\n                processEvent(key);\n                \n            }\n            selectedKeys.clear();\n        }\n        \n        long currentTime = System.currentTimeMillis();\n        if ((currentTime - this.lastTimeoutCheck) >= this.selectTimeout) {\n            this.lastTimeoutCheck = currentTime;\n            Set<SelectionKey> keys = this.selector.keys();\n            processTimeouts(keys);\n        }\n    }", "LocalizedBug": "synchronized (keys) {\n}", "LocalizedPatchLength": 23, "CodeLength": 845}
{"BuggyCode": "@Test\n  public void testShortArray_AsIntegers() throws Exception {\n    assertArrayEquals(new byte []{1,2,3,4}, binStart().Short(0x0102,0x0304).end().toByteArray());\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.igormaznitsa.jbbp.io.JBBPBitOutputStream` acquired by call to `binStart()` at line 145 is not released after line 145."}, "FixedCode": "@Test\n  public void testShortArray_AsIntegers() throws Exception {\n    assertArrayEquals(new byte []{1,2,3,4}, BeginBin().Short(0x0102,0x0304).End().toByteArray());\n  }", "LocalizedBug": "assertArrayEquals(new byte []{1,2,3,4}, binStart().Short(0x0102,0x0304).end().toByteArray());", "LocalizedPatchLength": 93, "CodeLength": 168}
{"BuggyCode": "@Override\n\tpublic int getNumberOfFeatures(){\n\t\treturn (Integer)get(\"n_features\");\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `get(\"n_features\")` could be null and is dereferenced at line 38."}, "FixedCode": "@Override\n\tpublic int getNumberOfFeatures(){\n\t\treturn ValueUtil.asInteger((Number)get(\"n_features\"));\n\t}", "LocalizedBug": "return (Integer)get(\"n_features\");", "LocalizedPatchLength": 34, "CodeLength": 84}
{"BuggyCode": "@Test\n    public void connectThrowsForUnknownAuthToken()\n    {\n        ConnectionSettings settings = new ConnectionSettings( mock( AuthToken.class ) );\n        TestSocketConnector connector = new TestSocketConnector( settings, insecure(), loggingMock() );\n\n        try\n        {\n            connector.connect( LOCAL_DEFAULT );\n            fail( \"Exception expected\" );\n        }\n        catch ( Exception e )\n        {\n            assertThat( e, instanceOf( ClientException.class ) );\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.neo4j.driver.internal.net.ConcurrencyGuardingConnection` acquired by call to `connect(...)` at line 84 is not released after line 84."}, "FixedCode": "@Test\n    public void connectThrowsForUnknownAuthToken()\n    {\n        ConnectionSettings settings = new ConnectionSettings( mock( AuthToken.class ) );\n        RecordingSocketConnector connector = new RecordingSocketConnector( settings );\n\n        try\n        {\n            connector.connect( LOCAL_DEFAULT );\n            fail( \"Exception expected\" );\n        }\n        catch ( Exception e )\n        {\n            assertThat( e, instanceOf( ClientException.class ) );\n        }\n    }", "LocalizedBug": "TestSocketConnector connector = new TestSocketConnector( settings, insecure(), loggingMock() );", "LocalizedPatchLength": 95, "CodeLength": 500}
{"BuggyCode": "@SuppressWarnings( \"ConstantConditions\" )\n    @Test\n    public void shouldHandleNullAuthToken() throws Throwable\n    {\n        // Given\n        AuthToken token = null;\n        Driver driver = GraphDatabase.driver( neo4j.address(), token);\n        Session session = driver.session();\n\n        // When\n        session.close();\n\n        // Then\n        assertFalse( session.isOpen() );\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.neo4j.driver.internal.pool.InternalConnectionPool` acquired by call to `driver(...)` at line 72 is not released after line 73."}, "FixedCode": "@SuppressWarnings( \"ConstantConditions\" )\n    @Test\n    public void shouldHandleNullAuthToken() throws Throwable\n    {\n        // Given\n        AuthToken token = null;\n        try ( Driver driver = GraphDatabase.driver( neo4j.address(), token ) )\n        {\n            Session session = driver.session();\n\n            // When\n            session.close();\n\n            // Then\n            assertFalse( session.isOpen() );\n        }\n    }", "LocalizedBug": "Driver driver = GraphDatabase.driver( neo4j.address(), token);", "LocalizedPatchLength": 62, "CodeLength": 388}
{"BuggyCode": "@Test\n    public void rendersProfilePageWithRateInFirefox() throws Exception {\n        final Farm farm = new PropsFarm(new FkFarm());\n        final double rate = 99.99;\n        final People people = new People(farm).bootstrap();\n        people.rate(\n            \"yegor256\", new Cash.S(String.format(\"USD %f\", rate))\n        );\n        MatcherAssert.assertThat(\n            new View(farm, \"/u/yegor256\").html(),\n            Matchers.containsString(\n                String.format(\n                    \"rate</a> is <span style=\\\"color:darkgreen\\\">$%.2f</span>\",\n                    rate\n                )\n            )\n        );\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.farm.props.PropsFarm` acquired by call to `PropsFarm(...)` at line 83 is not released after line 90."}, "FixedCode": "@Test\n    public void rendersProfilePageWithRateInFirefox() throws Exception {\n        final Farm farm = FkFarm.props();\n        final double rate = 99.99;\n        final People people = new People(farm).bootstrap();\n        people.rate(\n            \"yegor256\", new Cash.S(String.format(\"USD %f\", rate))\n        );\n        MatcherAssert.assertThat(\n            new View(farm, \"/u/yegor256\").html(),\n            Matchers.containsString(\n                String.format(\n                    \"rate</a> is <span style=\\\"color:darkgreen\\\">$%.2f</span>\",\n                    rate\n                )\n            )\n        );\n    }", "LocalizedBug": "final Farm farm = new PropsFarm(new FkFarm());", "LocalizedPatchLength": 46, "CodeLength": 632}
{"BuggyCode": "@Override\n    public void onEvent(TransactionEvent event, String fromId) {\n        Transaction tx = event.getEventBody();\n        if (null == tx) {\n            return;\n        }\n        ValidateResult result = tx.verify();\n        if (result.isFailed()) {\n            if (result.getLevel() == SeverityLevelEnum.NORMAL_FOUL) {\n                networkService.removeNode(fromId);\n            } else if (result.getLevel() == SeverityLevelEnum.FLAGRANT_FOUL) {\n                networkService.removeNode(fromId);\n            }\n        }\n        cacheManager.putTx(tx);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `result` last assigned on line 61 could be null and is dereferenced at line 62."}, "FixedCode": "@Override\n    public void onEvent(TransactionEvent event, String fromId) {\n        Transaction tx = event.getEventBody();\n        if (null == tx) {\n            return;\n        }\n        ValidateResult result = tx.verify();\n        if (result.isFailed()) {\n            if (result.getLevel() == SeverityLevelEnum.NORMAL_FOUL) {\n                networkService.blackNode(fromId,NodePo.YELLOW);\n            } else if (result.getLevel() == SeverityLevelEnum.FLAGRANT_FOUL) {\n                networkService.blackNode(fromId, NodePo.BLACK);\n            }\n        }\n        cacheManager.putTx(tx);\n    }", "LocalizedBug": "networkService.removeNode(fromId);\nnetworkService.removeNode(fromId);", "LocalizedPatchLength": 69, "CodeLength": 568}
{"BuggyCode": "protected AlgorithmExecutor buildExecutor(String algorithmName) throws FileNotFoundException, UnsupportedEncodingException {\n\t\tFunctionalDependencyResultReceiver fdResultReceiver = \n\t\t\t\tnew FunctionalDependencyPrinter(getResultFileName(algorithmName), getResultDirectoryName());\n\t\tInclusionDependencyResultReceiver indResultReceiver = \n\t\t\t\tnew InclusionDependencyPrinter(getResultFileName(algorithmName), getResultDirectoryName());\n\t\tUniqueColumnCombinationResultReceiver uccResultReceiver = \n\t\t\t\tnew UniqueColumnCombinationPrinter(getResultFileName(algorithmName), getResultDirectoryName());\n\t\tFileGenerator fileGenerator = new TempFileGenerator();\n\t\t\n\t\treturn new AlgorithmExecutor(fdResultReceiver, indResultReceiver, uccResultReceiver, fileGenerator);\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `de.uni_potsdam.hpi.metanome.result_receiver.InclusionDependencyPrinter` acquired by call to `InclusionDependencyPrinter(...)` at line 59 is not released after line 64.\n**Note**: potential exception at line 61"}, "FixedCode": "protected AlgorithmExecutor buildExecutor(String algorithmName) throws FileNotFoundException, UnsupportedEncodingException {\n\t\tLinkedList<ResultPrinter> resultPrinters = new LinkedList<ResultPrinter>();\n\t\t\n\t\tFunctionalDependencyPrinter fdResultReceiver = \n\t\t\t\tnew FunctionalDependencyPrinter(getResultFileName(algorithmName), getResultDirectoryName());\n\t\tresultPrinters.add(fdResultReceiver);\n\t\t\n\t\tInclusionDependencyPrinter indResultReceiver = \n\t\t\t\tnew InclusionDependencyPrinter(getResultFileName(algorithmName), getResultDirectoryName());\n\t\tresultPrinters.add(indResultReceiver);\n\t\t\n\t\tUniqueColumnCombinationPrinter uccResultReceiver = \n\t\t\t\tnew UniqueColumnCombinationPrinter(getResultFileName(algorithmName), getResultDirectoryName());\n\t\tresultPrinters.add(uccResultReceiver);\n\t\t\n\t\tFileGenerator fileGenerator = new TempFileGenerator();\n\t\t\n\t\tAlgorithmExecutor executor = new AlgorithmExecutor(fdResultReceiver, indResultReceiver, uccResultReceiver, fileGenerator);\n\t\tcurrentResultPrinters.put(algorithmName, resultPrinters);\n\t\treturn executor;\n\t}", "LocalizedBug": "FunctionalDependencyResultReceiver fdResultReceiver =\nInclusionDependencyResultReceiver indResultReceiver =\nUniqueColumnCombinationResultReceiver uccResultReceiver =\nreturn new AlgorithmExecutor(fdResultReceiver, indResultReceiver, uccResultReceiver, fileGenerator);", "LocalizedPatchLength": 266, "CodeLength": 758}
{"BuggyCode": "public Order orderQuery(IdQuery idQuery) throws WeixinException {\n\t\tMap<String, String> map = baseMap(idQuery);\n\t\tString sign = PayUtil.paysignMd5(map, weixinAccount.getPaySignKey());\n\t\tmap.put(\"sign\", sign);\n\t\tString param = XmlStream.map2xml(map);\n\t\tString orderquery_uri = getRequestUri(\"orderquery_v3_uri\");\n\t\tWeixinResponse response = weixinClient.post(orderquery_uri, param);\n\t\treturn ListsuffixResultDeserializer.deserialize(response.getAsString(),\n\t\t\t\tOrder.class, \"couponList\");\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `response.getAsString()` could be null and is dereferenced by call to `deserialize(...)` at line 83."}, "FixedCode": "public Order orderQuery(IdQuery idQuery) throws WeixinException {\n\t\tMap<String, String> map = baseMap(idQuery);\n\t\tString sign = PayUtil.paysignMd5(map, weixinAccount.getPaySignKey());\n\t\tmap.put(\"sign\", sign);\n\t\tString param = XmlStream.map2xml(map);\n\t\tString orderquery_uri = getRequestUri(\"orderquery_v3_uri\");\n\t\tWeixinResponse response = weixinClient.post(orderquery_uri, param);\n\t\treturn ListsuffixResultDeserializer.deserialize(response.getAsString(),\n\t\t\t\tOrder.class);\n\t}", "LocalizedBug": "Order.class, \"couponList\");", "LocalizedPatchLength": 27, "CodeLength": 490}
{"BuggyCode": "@Override\n  public void onPageLoad() {\n    System.err.println(\"new page loaded\");\n    pageLoaded = true;\n    reset();\n    try {\n      Thread.sleep(5000);\n      System.out.println(\n          \"on page load:\" + session.getWebInspector().getProtocol().sendCommand(DOM.getDocument())\n              .optJSONObject(\"root\").optString(\"documentURL\"));\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.uiautomation.ios.server.DOMContext.onPageLoad` indirectly reads without synchronization from `mobileSafari.DebugProtocol.org.uiautomation.ios.mobileSafari.DebugProtocol.socket`. Potentially races with write in method `DOMContext.domHasChanged(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n  public void onPageLoad() {\n    pageLoaded = true;\n    reset();\n  }", "LocalizedBug": "System.err.println(\"new page loaded\");\ntry {\nThread.sleep(5000);\nSystem.out.println(\n\"on page load:\" + session.getWebInspector().getProtocol().sendCommand(DOM.getDocument())\n.optJSONObject(\"root\").optString(\"documentURL\"));\n} catch (Exception e) {\ne.printStackTrace();\n}\n}", "LocalizedPatchLength": 272, "CodeLength": 407}
{"BuggyCode": "@Test\n    public void testCountAllWithPredicate()\n    {\n        List<Tuple> expected = computeExpected(\"SELECT COUNT(*) FROM orders WHERE orderstatus = 'F'\", FIXED_INT_64);\n\n        TupleStream orderStatus = createBlockStream(ordersData, Column.ORDER_ORDERSTATUS, VARIABLE_BINARY);\n\n        ApplyPredicateOperator filtered = new ApplyPredicateOperator(orderStatus, new Predicate<Cursor>()\n        {\n            @Override\n            public boolean apply(Cursor input)\n            {\n                return input.getSlice(0).equals(Slices.copiedBuffer(\"F\", Charsets.UTF_8));\n            }\n        });\n\n        AggregationOperator aggregation = new AggregationOperator(filtered, CountAggregation.PROVIDER);\n\n        assertEqualsIgnoreOrder(tuples(aggregation), expected);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.facebook.presto.TestQueries$3` acquired by call to `createBlockStream(...)` at line 163 is not released after line 176."}, "FixedCode": "@Test\n    public void testCountAllWithPredicate()\n    {\n        List<Tuple> expected = computeExpected(\"SELECT COUNT(*) FROM orders WHERE orderstatus = 'F'\", FIXED_INT_64);\n\n        TupleStream orderStatus = createTupleStream(ordersData, Column.ORDER_ORDERSTATUS, VARIABLE_BINARY);\n\n        ApplyPredicateOperator filtered = new ApplyPredicateOperator(orderStatus, new Predicate<Cursor>()\n        {\n            @Override\n            public boolean apply(Cursor input)\n            {\n                return input.getSlice(0).equals(Slices.copiedBuffer(\"F\", Charsets.UTF_8));\n            }\n        });\n\n        AggregationOperator aggregation = new AggregationOperator(filtered, CountAggregation.PROVIDER);\n\n        assertEqualsIgnoreOrder(tuples(aggregation), expected);\n    }", "LocalizedBug": "TupleStream orderStatus = createBlockStream(ordersData, Column.ORDER_ORDERSTATUS, VARIABLE_BINARY);", "LocalizedPatchLength": 99, "CodeLength": 774}
{"BuggyCode": "@Override\n    public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbolAsValue(name, typeSolver);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getContext(AbstractJavaParserContext.wrappedNode.getParentNode())` could be null and is dereferenced at line 84."}, "FixedCode": "@Override\n    public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n        return getParent().solveSymbolAsValue(name, typeSolver);\n    }", "LocalizedBug": "return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbolAsValue(name, typeSolver);", "LocalizedPatchLength": 102, "CodeLength": 210}
{"BuggyCode": "@Test\n    public void testSystemGc() throws Exception {\n        TestLogHandler handler = new TestLogHandler();\n        handler.setLevel(Level.WARNING);\n        IMP_LOGGER.addHandler(handler);\n        DATA_READER_FACTORY_LOGGER.addHandler(handler);\n\n        InputStream in = UnittestHelper.getResourceAsStream(UnittestHelper.FOLDER_IBM, \"SampleIBMJ9_R28_global.txt\");\n        DataReader reader = new DataReaderIBM_J9_R28(in);\n        GCModel model = reader.read();\n\n        assertThat(\"model size\", model.size(), is(1));\n\n        GCEvent event = (GCEvent) model.get(0);\n        assertThat(\"pause\", event.getPause(), closeTo(0.097756, 0.0000001));\n\n        assertThat(\"number of errors\", handler.getCount(), is(0));\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.LineNumberReader` acquired by call to `DataReaderIBM_J9_R28(...)` at line 67 is not released after line 68."}, "FixedCode": "@Test\n    public void testSystemGc() throws Exception {\n        TestLogHandler handler = new TestLogHandler();\n        handler.setLevel(Level.WARNING);\n        GCResource gcResource = new GCResource(\"SampleIBMJ9_R28_global.txt\");\n        gcResource.getLogger().addHandler(handler);\n\n        DataReader reader = getDataReader(gcResource);\n        GCModel model = reader.read();\n\n        assertThat(\"model size\", model.size(), is(1));\n\n        GCEvent event = (GCEvent) model.get(0);\n        assertThat(\"pause\", event.getPause(), closeTo(0.097756, 0.0000001));\n\n        assertThat(\"number of errors\", handler.getCount(), is(0));\n    }", "LocalizedBug": "IMP_LOGGER.addHandler(handler);\nDATA_READER_FACTORY_LOGGER.addHandler(handler);\nInputStream in = UnittestHelper.getResourceAsStream(UnittestHelper.FOLDER_IBM, \"SampleIBMJ9_R28_global.txt\");\nDataReader reader = new DataReaderIBM_J9_R28(in);", "LocalizedPatchLength": 239, "CodeLength": 719}
{"BuggyCode": "@Test\n    public void testReadWrite() {\n        DirectStore ds = new DirectStore(null, 1024);\n        DirectBytes db = ds.createSlice();\n        RawCopier<A> aRawCopier = RawCopier.copies(A.class);\n        A a = new A();\n        a.i = 111;\n        a.j = -222;\n        a.k = 333;\n        a.s = \"Hello\";\n        aRawCopier.toBytes(a, db);\n        assertEquals(12, db.position());\n\n        assertEquals(111, db.readInt(0));\n        assertEquals(-222, db.readInt(4));\n        assertEquals(333, db.readInt(8));\n\n        A a2 = new A();\n        a2.i = 1;\n        a2.j = 2;\n        a2.k = 3;\n//        printInts(a2, 28);\n        db.position(0);\n        aRawCopier.fromBytes(db, a2);\n//        printInts(a2, 28);\n        assertEquals(111, a2.i);\n        assertEquals(-222, a2.j);\n        assertEquals(333, a2.k);\n        assertEquals(null, a2.s);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `net.openhft.lang.io.DirectBytes` acquired to `db` by call to `createSlice()` at line 56 is not released after line 76."}, "FixedCode": "@Test\n    public void testReadWrite() {\n        DirectStore ds = new DirectStore(null, 1024);\n        DirectBytes db = ds.bytes();\n        RawCopier<A> aRawCopier = RawCopier.copies(A.class);\n        A a = new A();\n        a.i = 111;\n        a.j = -222;\n        a.k = 333;\n        a.s = \"Hello\";\n        aRawCopier.toBytes(a, db);\n        assertEquals(12, db.position());\n\n        assertEquals(111, db.readInt(0));\n        assertEquals(-222, db.readInt(4));\n        assertEquals(333, db.readInt(8));\n\n        A a2 = new A();\n        a2.i = 1;\n        a2.j = 2;\n        a2.k = 3;\n//        printInts(a2, 28);\n        db.position(0);\n        aRawCopier.fromBytes(db, a2);\n//        printInts(a2, 28);\n        assertEquals(111, a2.i);\n        assertEquals(-222, a2.j);\n        assertEquals(333, a2.k);\n        assertEquals(null, a2.s);\n    }", "LocalizedBug": "DirectBytes db = ds.createSlice();", "LocalizedPatchLength": 34, "CodeLength": 844}
{"BuggyCode": "public Collection<StoredObject> list(String prefix, String marker, int pageSize) {\n        ListInstructions listInstructions = new ListInstructions()\n                .setPrefix(prefix)\n                .setMarker(marker)\n                .setLimit(pageSize);\n        return new ListObjectsCommand(getAccount(), getClient(), getAccess(), this, listInstructions).call();\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.javaswift.joss.command.impl.container.ListObjectsCommand` acquired by call to `ListObjectsCommand(...)` at line 33 is not released after line 33."}, "FixedCode": "public Collection<StoredObject> list(String prefix, String marker, int pageSize) {\n        ListInstructions listInstructions = new ListInstructions()\n                .setPrefix(prefix)\n                .setMarker(marker)\n                .setLimit(pageSize);\n        return commandFactory.createListObjectsCommand(getAccount(), getClient(), getAccess(), this, listInstructions).call();\n    }", "LocalizedBug": "return new ListObjectsCommand(getAccount(), getClient(), getAccess(), this, listInstructions).call();", "LocalizedPatchLength": 101, "CodeLength": 372}
{"BuggyCode": "@Test\n\tpublic void objectRetrievedSuccessfullyFromEagerReferencedObjectOffHeapPool() {\n\t\tEagerReferencedObjectOffHeapPool<SampleOffHeapClass> objectPool = \n\t\t\t\toffHeapService.createOffHeapPool(\n\t\t\t\t\t\tnew ObjectOffHeapPoolCreateParameterBuilder<SampleOffHeapClass>().\n\t\t\t\t\t\t\t\ttype(SampleOffHeapClass.class).\n\t\t\t\t\t\t\t\tobjectCount(ELEMENT_COUNT).\n\t\t\t\t\t\t\t\treferenceType(ObjectPoolReferenceType.EAGER_REFERENCED).\n\t\t\t\t\t\t\tbuild());\n   \n    \tfor (int i = 0; i < ELEMENT_COUNT; i++) {\n    \t\tSampleOffHeapClass obj = objectPool.get();\n    \t\tAssert.assertEquals(0, obj.getOrder());\n    \t\tobj.setOrder(i);\n    \t\tAssert.assertEquals(i, obj.getOrder());\n    \t}\n    \t\n    \tobjectPool.reset();\n    \t\n    \tfor (int i = 0; i < ELEMENT_COUNT; i++) {\n    \t\tSampleOffHeapClass obj = objectPool.getAt(i);\n    \t\tAssert.assertEquals(0, obj.getOrder());\n    \t\tobj.setOrder(i);\n    \t\tAssert.assertEquals(i, obj.getOrder());\n    \t}\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `obj` last assigned on line 64 could be null and is dereferenced at line 65."}, "FixedCode": "@Test\n\tpublic void objectRetrievedSuccessfullyFromEagerReferencedObjectOffHeapPool() {\n\t\tEagerReferencedObjectOffHeapPool<SampleOffHeapClass> objectPool = \n\t\t\t\toffHeapService.createOffHeapPool(\n\t\t\t\t\t\tnew ObjectOffHeapPoolCreateParameterBuilder<SampleOffHeapClass>().\n\t\t\t\t\t\t\t\ttype(SampleOffHeapClass.class).\n\t\t\t\t\t\t\t\tobjectCount(ELEMENT_COUNT).\n\t\t\t\t\t\t\t\treferenceType(ObjectPoolReferenceType.EAGER_REFERENCED).\n\t\t\t\t\t\t\tbuild());\n   \n    \tfor (int i = 0; true; i++) {\n    \t\tSampleOffHeapClass obj = objectPool.get();\n    \t\tif (obj == null) {\n    \t\t\tbreak;\n    \t\t}\n    \t\tAssert.assertEquals(0, obj.getOrder());\n    \t\tobj.setOrder(i);\n    \t\tAssert.assertEquals(i, obj.getOrder());\n    \t}\n    \t\n    \tobjectPool.reset();\n    \t\n    \tfor (int i = 0; i < ELEMENT_COUNT; i++) {\n    \t\tSampleOffHeapClass obj = objectPool.getAt(i);\n    \t\tAssert.assertEquals(0, obj.getOrder());\n    \t\tobj.setOrder(i);\n    \t\tAssert.assertEquals(i, obj.getOrder());\n    \t}\n\t}", "LocalizedBug": "for (int i = 0; i < ELEMENT_COUNT; i++) {", "LocalizedPatchLength": 41, "CodeLength": 907}
{"BuggyCode": "void resetStatistics()\n    {\n        rehashes = 0L;\n        evictedEntries = 0L;\n        hitCount = 0L;\n        missCount = 0L;\n        putAddCount = 0L;\n        putReplaceCount = 0L;\n        removeCount = 0L;\n        lruCompactions = 0L;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.caffinitas.ohc.tables.OffHeapMap.resetStatistics` writes to field `this.org.caffinitas.ohc.tables.OffHeapMap.putReplaceCount` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, AtomicLong freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        int bl = builder.getBucketLength();\n        if (bl <= 0)\n            bl = 8;\n        int buckets = (int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE);\n        entriesPerBucket = (int) Util.roundUpToPowerOf2(bl, MAX_TABLE_SIZE);\n        table = Table.create(buckets, entriesPerBucket);\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        if (lf >= 1d)\n            throw new IllegalArgumentException(\"load factor must not be greater that 1\");\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "void resetStatistics()\n{\nrehashes = 0L;\nevictedEntries = 0L;\nhitCount = 0L;\nmissCount = 0L;\nputAddCount = 0L;\nputReplaceCount = 0L;\nremoveCount = 0L;\nlruCompactions = 0L;", "LocalizedPatchLength": 170, "CodeLength": 244}
{"BuggyCode": "@Test\n    public void testLineFeedEndings() throws IOException {\n        final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n        final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n        final List<CSVRecord> records = parser.getRecords();\n        assertEquals(4, records.size());\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.commons.csv.ExtendedBufferedReader` acquired by call to `parseString(...)` at line 419 is not released after line 420."}, "FixedCode": "@Test\n    public void testLineFeedEndings() throws IOException {\n        final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n        final List<CSVRecord> records = parser.getRecords();\n        assertEquals(4, records.size());\n    }", "LocalizedBug": "final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);", "LocalizedPatchLength": 72, "CodeLength": 315}
{"BuggyCode": "public boolean isIterableMapping() {\n        return getSingleSourceType().isIterableType() && resultType.isIterableType();\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getSingleSourceType()` could be null and is dereferenced at line 177."}, "FixedCode": "public boolean isIterableMapping() {\n        return getSingleSourceParameter().getType().isIterableType() && getResultType().isIterableType();\n    }", "LocalizedBug": "return getSingleSourceType().isIterableType() && resultType.isIterableType();", "LocalizedPatchLength": 77, "CodeLength": 128}
{"BuggyCode": "long evictedEntries()\n    {\n        return evictedEntries;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.caffinitas.ohc.linked.OffHeapMap.evictedEntries` reads without synchronization from `this.org.caffinitas.ohc.linked.OffHeapMap.evictedEntries`. Potentially races with write in method `OffHeapMap.replaceEntry(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, long freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        this.throwOOME = builder.isThrowOOME();\n\n        this.lock = builder.isUnlocked() ? null : new ReentrantLock();\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        table = Table.create((int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE), throwOOME);\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "long evictedEntries()\n{\nreturn evictedEntries;", "LocalizedPatchLength": 46, "CodeLength": 64}
{"BuggyCode": "public Number getWeight(int index){\n\t\tCSRMatrix idfDiag = (CSRMatrix)get(\"_idf_diag\");\n\n\t\tList<?> data = idfDiag.getData();\n\n\t\treturn (Number)data.get(index);\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `idfDiag` last assigned on line 33 could be null and is dereferenced at line 35."}, "FixedCode": "public Number getWeight(int index){\n\t\tCSRMatrix idfDiag = get(\"_idf_diag\", CSRMatrix.class);\n\n\t\tList<?> data = idfDiag.getData();\n\n\t\treturn (Number)data.get(index);\n\t}", "LocalizedBug": "CSRMatrix idfDiag = (CSRMatrix)get(\"_idf_diag\");", "LocalizedPatchLength": 48, "CodeLength": 161}
{"BuggyCode": "public void setupSensibleDefaultPty() {\n        try {\n            String os = System.getProperty(\"os.name\").toLowerCase();\n            if (os.indexOf(\"windows\") < 0) {\n                ptyModes = SttySupport.getUnixPtyModes();\n                ptyColumns = SttySupport.getTerminalWidth();\n                ptyLines = SttySupport.getTerminalHeight();\n            } else {\n                ptyType = \"windows\";\n            }\n        } catch (Throwable t) {\n            // Ignore exceptions\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getProperty(\"os.name\")` could be null and is dereferenced at line 66."}, "FixedCode": "public void setupSensibleDefaultPty() {\n        try {\n            if (OsUtils.isUNIX()) {\n                ptyModes = SttySupport.getUnixPtyModes();\n                ptyColumns = SttySupport.getTerminalWidth();\n                ptyLines = SttySupport.getTerminalHeight();\n            } else {\n                ptyType = \"windows\";\n            }\n        } catch (Throwable t) {\n            // Ignore exceptions\n        }\n    }", "LocalizedBug": "String os = System.getProperty(\"os.name\").toLowerCase();\nif (os.indexOf(\"windows\") < 0) {", "LocalizedPatchLength": 89, "CodeLength": 499}
{"BuggyCode": "public void initDbConnectServer() throws Exception{\n        worldRpcConnectManager.initManager();\n        dbRpcConnnectManngeer.initServers(sdDbServers);\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `com.wolf.shoot.service.rpc.server.RpcServiceDiscovery.initDbConnectServer` indirectly writes to field `this.com.wolf.shoot.service.rpc.server.RpcServiceDiscovery.worldRpcConnectManager.com.wolf.shoot.service.rpc.client.RpcConnectManager.threadPoolExecutor` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public void initDbConnectServer() throws Exception{\n        dbRpcConnnectManngeer.initManager();\n        dbRpcConnnectManngeer.initServers(sdDbServers);\n    }", "LocalizedBug": "worldRpcConnectManager.initManager();", "LocalizedPatchLength": 37, "CodeLength": 159}
{"BuggyCode": "public void handleOpenFailure(Buffer buffer) {\n        int reason = buffer.getInt();\n        String msg = buffer.getString();\n        synchronized (lock) {\n            this.openFailureReason = reason;\n            this.openFailureMsg = msg;\n            this.openFuture.setException(new SshException(msg));\n            this.closeFuture.setClosed();\n            this.doClose();\n            lock.notifyAll();\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.apache.sshd.client.channel.AbstractClientChannel.handleOpenFailure` indirectly reads without synchronization from `buffer.org.apache.sshd.common.util.Buffer.rpos`. Potentially races with write in method `AbstractClientChannel.handleOpenFailure(...)`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public void handleOpenFailure(Buffer buffer) {\n        int reason = buffer.getInt();\n        String msg = buffer.getString();\n        this.openFailureReason = reason;\n        this.openFailureMsg = msg;\n        this.openFuture.setException(new SshException(msg));\n        this.closeFuture.setClosed();\n        this.doClose();\n        notifyStateChanged();\n    }", "LocalizedBug": "synchronized (lock) {\nlock.notifyAll();\n}", "LocalizedPatchLength": 41, "CodeLength": 420}
{"BuggyCode": "public void close() {\n        doClose(lbProxyBean, protobufRpcProxyList);\n        super.close();\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.baidu.jprotobuf.pbrpc.client.ha.HaProtobufRpcProxy.close` reads without synchronization from `this.com.baidu.jprotobuf.pbrpc.client.ha.HaProtobufRpcProxy.lbProxyBean`. Potentially races with write in method `HaProtobufRpcProxy.proxy()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public void close() {\n        Collection<List<ProtobufRpcProxy<T>>> values = protobufRpcProxyListMap.values();\n        for (List<ProtobufRpcProxy<T>> list : values) {\n            doClose(null, list);\n        }\n\n        Collection<LoadBalanceProxyFactoryBean> lbs = lbMap.values();\n        for (LoadBalanceProxyFactoryBean loadBalanceProxyFactoryBean : lbs) {\n            doClose(loadBalanceProxyFactoryBean, null);\n        }\n        super.close();\n    }", "LocalizedBug": "doClose(lbProxyBean, protobufRpcProxyList);", "LocalizedPatchLength": 43, "CodeLength": 102}
{"BuggyCode": "@SuppressWarnings(\"unchecked\")\n    private static Deserializer deserializer(File file, PoijiOptions options) throws FileNotFoundException {\n        final PoijiStream poiParser = new PoijiStream(fileInputStream(file));\n        final PoiWorkbook workbook = PoiWorkbook.workbook(Files.getExtension(file.getName()), poiParser);\n        return Deserializer.instance(workbook, options);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileInputStream` acquired by call to `fileInputStream(...)` at line 34 is not released after line 35.\n**Note**: potential exception at line 35"}, "FixedCode": "@SuppressWarnings(\"unchecked\")\n    private static Deserializer deserializer(File file, PoijiOptions options) {\n        final PoijiStream poiParser = new PoijiStream(file);\n        final PoiWorkbook workbook = PoiWorkbook.workbook(Files.getExtension(file.getName()), poiParser);\n        return Deserializer.instance(workbook, options);\n    }", "LocalizedBug": "private static Deserializer deserializer(File file, PoijiOptions options) throws FileNotFoundException {\nfinal PoijiStream poiParser = new PoijiStream(fileInputStream(file));", "LocalizedPatchLength": 174, "CodeLength": 386}
{"BuggyCode": "@Test\n    public void testEndOfStreamConditionReadingFooters() throws Exception {\n        String s = \"10\\r\\n1234567890123456\\r\\n\" +\n                \"5\\r\\n12345\\r\\n5\\r\\n12345\\r\\n0\\r\\n\";\n        ReadableByteChannel channel = new ReadableByteChannelMockup(\n                new String[] {s}, \"US-ASCII\");\n        HttpParams params = new BasicHttpParams();\n\n        SessionInputBuffer inbuf = new SessionInputBufferImpl(1024, 256, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        ChunkDecoder decoder = new ChunkDecoder(channel, inbuf, metrics);\n\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n\n        int bytesRead = 0;\n        while (dst.hasRemaining() && !decoder.isCompleted()) {\n            int i = decoder.read(dst);\n            if (i > 0) {\n                bytesRead += i;\n            }\n        }\n\n        Assert.assertEquals(26, bytesRead);\n        Assert.assertEquals(\"12345678901234561234512345\", convert(dst));\n        Assert.assertTrue(decoder.isCompleted());\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.http.ReadableByteChannelMockup` acquired by call to `new()` at line 380 is not released after line 400."}, "FixedCode": "@Test\n    public void testEndOfStreamConditionReadingFooters() throws Exception {\n        String s = \"10\\r\\n1234567890123456\\r\\n\" +\n                \"5\\r\\n12345\\r\\n5\\r\\n12345\\r\\n0\\r\\n\";\n        ReadableByteChannel channel = new ReadableByteChannelMock(\n                new String[] {s}, \"US-ASCII\");\n        HttpParams params = new BasicHttpParams();\n\n        SessionInputBuffer inbuf = new SessionInputBufferImpl(1024, 256, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        ChunkDecoder decoder = new ChunkDecoder(channel, inbuf, metrics);\n\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n\n        int bytesRead = 0;\n        while (dst.hasRemaining() && !decoder.isCompleted()) {\n            int i = decoder.read(dst);\n            if (i > 0) {\n                bytesRead += i;\n            }\n        }\n\n        Assert.assertEquals(26, bytesRead);\n        Assert.assertEquals(\"12345678901234561234512345\", convert(dst));\n        Assert.assertTrue(decoder.isCompleted());\n    }", "LocalizedBug": "ReadableByteChannel channel = new ReadableByteChannelMockup(", "LocalizedPatchLength": 60, "CodeLength": 1021}
{"BuggyCode": "public static boolean emptyDirectory(File directory) {\n        boolean result = true;\n        File[] entries = directory.listFiles();\n        for (int i = 0; i < entries.length; i++) {\n            if (!entries[i].delete()) {\n                result = false;\n            }\n        }\n        return result;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `entries` last assigned on line 159 could be null and is dereferenced at line 160."}, "FixedCode": "public static boolean emptyDirectory(File directory) {\n        boolean result = true;\n        File[] entries = directory.listFiles();\n        for (File entry : entries) {\n            if (!entry.delete()) {\n                result = false;\n            }\n        }\n        return result;\n    }", "LocalizedBug": "for (int i = 0; i < entries.length; i++) {\nif (!entries[i].delete()) {", "LocalizedPatchLength": 70, "CodeLength": 309}
{"BuggyCode": "@Override\n    @JsonIgnore\n    public Filter getFilter() {\n        return getInnerQuery().getFilter();\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getInnerQuery()` could be null and is dereferenced at line 183."}, "FixedCode": "@Override\n    @JsonIgnore\n    public Filter getFilter() {\n        return getInnerQueryUnchecked().getFilter();\n    }", "LocalizedBug": "return getInnerQuery().getFilter();", "LocalizedPatchLength": 35, "CodeLength": 107}
{"BuggyCode": "public static Database from(String url, int maxPoolSize) {\n        return Database.from(new NonBlockingConnectionPool(Util.connectionProvider(url), maxPoolSize, 1000));\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.davidmoten.rx.jdbc.pool.NonBlockingConnectionPool` acquired by call to `new()` at line 34 is not released after line 34."}, "FixedCode": "public static Database from(String url, int maxPoolSize) {\n        return Database.from( //\n                Pools.nonBlocking() //\n                        .url(url) //\n                        .maxPoolSize(maxPoolSize) //\n                        .build());\n    }", "LocalizedBug": "return Database.from(new NonBlockingConnectionPool(Util.connectionProvider(url), maxPoolSize, 1000));", "LocalizedPatchLength": 101, "CodeLength": 174}
{"BuggyCode": "@Override\n    protected String getRawFormData(final String formName, final SlingHttpServletRequest request,\n            final SlingHttpServletResponse response) {\n        final String cookieName = getGetLookupKey(formName);\n        final Cookie cookie = CookieUtil.getCookie(request, cookieName);\n\n        if (response != null && cookie != null) {\n            CookieUtil.dropCookies(request, response, ROOT_COOKIE_PATH, cookieName);\n        } else {\n            log.warn(\"SlingHttpServletResponse required for removing cookie. Please use formHelper.getForm({}, slingRequest, slingResponse);\", formName);\n        }\n        // Get the QP lookup for this form\n        return this.decode(cookie.getValue());\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `cookie` last assigned on line 95 could be null and is dereferenced at line 103."}, "FixedCode": "@Override\n    protected String getRawFormData(final String formName, final SlingHttpServletRequest request,\n            final SlingHttpServletResponse response) {\n        final String cookieName = getGetLookupKey(formName);\n        final Cookie cookie = CookieUtil.getCookie(request, cookieName);\n\n        String data = \"\";\n        if (response != null && cookie != null) {\n            CookieUtil.dropCookies(request, response, ROOT_COOKIE_PATH, cookieName);\n            // Get the QP lookup for this form\n            data = this.decode(cookie.getValue());\n        } else {\n            log.warn(\"SlingHttpServletResponse required for removing cookie. Please use formHelper.getForm({}, slingRequest, slingResponse);\", formName);\n        }\n        return data;\n    }", "LocalizedBug": "// Get the QP lookup for this form\nreturn this.decode(cookie.getValue());", "LocalizedPatchLength": 73, "CodeLength": 709}
{"BuggyCode": "@SuppressWarnings( \"unchecked\" )\n    private static List<Principal> getPrincipals(HttpServletRequest request) {\n        List<Principal> principals = null;\n\n        Session session = ThreadLocalSecurityContext.current().getSession( false );\n        if( session != null ) {\n            principals = (List<Principal>) session.getAttribute( PRINCIPALS_SESSION_KEY );\n        } else {\n            HttpSession httpSession = request.getSession( false );\n            if( httpSession != null ) {\n                principals =  (List<Principal>) httpSession.getAttribute( PRINCIPALS_SESSION_KEY );\n            }\n        }\n        return principals;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `current()` could be null and is dereferenced at line 142."}, "FixedCode": "@SuppressWarnings( \"unchecked\" )\n    private static List<Principal> getPrincipals(HttpServletRequest request) {\n        List<Principal> principals = null;\n\n        Session session = (Session) ThreadContext.get( ThreadContext.SESSION_KEY );\n        if( session != null ) {\n            principals = (List<Principal>) session.getAttribute( PRINCIPALS_SESSION_KEY );\n        } else {\n            HttpSession httpSession = request.getSession( false );\n            if( httpSession != null ) {\n                principals =  (List<Principal>) httpSession.getAttribute( PRINCIPALS_SESSION_KEY );\n            }\n        }\n        return principals;\n    }", "LocalizedBug": "Session session = ThreadLocalSecurityContext.current().getSession( false );", "LocalizedPatchLength": 75, "CodeLength": 643}
{"BuggyCode": "private double calculateError(Dataframe trainingData, Map<Object, Double> thitas) {\n        //The cost function as described on http://ufldl.stanford.edu/wiki/index.php/Softmax_Regression\n        //It is optimized for speed to reduce the amount of loops\n        double error=0.0;\n        \n        for(Map.Entry<Integer, Record> e : trainingData.entries()) {\n            Integer rId = e.getKey();\n            Record r = e.getValue();\n            double yPredicted = hypothesisFunction(r.getX(), thitas);\n            trainingData._unsafe_set(rId, new Record(r.getX(), r.getY(), yPredicted, r.getYPredictedProbabilities()));\n            error+=Math.pow(TypeInference.toDouble(r.getY()) -yPredicted, 2);\n        }\n        \n        return error;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `toDouble(r.getY())` could be null and is dereferenced at line 276."}, "FixedCode": "private double calculateError(Dataframe trainingData, Map<Object, Double> thitas) {\n        //The cost function as described on http://ufldl.stanford.edu/wiki/index.php/Softmax_Regression\n        //It is optimized for speed to reduce the amount of loops\n        \n        double error = StreamMethods.stream(trainingData.entries(), isParallelized()).mapToDouble(e -> { \n            Integer rId = e.getKey();\n            Record r = e.getValue();\n            double yPredicted = hypothesisFunction(r.getX(), thitas);\n            trainingData._unsafe_set(rId, new Record(r.getX(), r.getY(), yPredicted, r.getYPredictedProbabilities()));\n            return Math.pow(TypeInference.toDouble(r.getY()) -yPredicted, 2);\n        }).sum();\n        \n        return error;\n    }", "LocalizedBug": "double error=0.0;\nfor(Map.Entry<Integer, Record> e : trainingData.entries()) {\nerror+=Math.pow(TypeInference.toDouble(r.getY()) -yPredicted, 2);", "LocalizedPatchLength": 144, "CodeLength": 746}
{"BuggyCode": "@Test\n    public void testEntriesNeg80To80InRrd() throws IOException, FontFormatException {\n        createGaugeRrd(180);\n        RrdDb rrd = new RrdDb(jrbFileName);\n\n        for(int i=0; i<160; i++) {\n            long timestamp = startTime + 1 + (i * 60);\n            Sample sample = rrd.createSample();\n            sample.setAndUpdate(timestamp + \":\" + (i -80));\n        }\n        rrd.close();\n        prepareGraph();\n\n        // Original\n        expectMinorGridLines(3);\n        expectMajorGridLine(\" -50\");\n        expectMinorGridLines(4);\n        expectMajorGridLine(\"   0\");\n        expectMinorGridLines(4);\n        expectMajorGridLine(\"  50\");\n        expectMinorGridLines(3);\n\n        run();\n\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.rrd4j.core.RrdDb` acquired to `rrd` by call to `RrdDb(...)` at line 301 is not released after line 322.\n**Note**: potential exception at line 306"}, "FixedCode": "@Test\n    public void testEntriesNeg80To80InRrd() throws IOException, FontFormatException {\n        createGaugeRrd(180);\n        RrdDb rrd = RrdDb.getBuilder().setPath(jrbFileName).build();\n\n        for(int i=0; i<160; i++) {\n            long timestamp = startTime + 1 + (i * 60);\n            Sample sample = rrd.createSample();\n            sample.setAndUpdate(timestamp + \":\" + (i -80));\n        }\n        rrd.close();\n        prepareGraph();\n\n        // Original\n        expectMinorGridLines(3);\n        expectMajorGridLine(\" -50\");\n        expectMinorGridLines(4);\n        expectMajorGridLine(\"   0\");\n        expectMinorGridLines(4);\n        expectMajorGridLine(\"  50\");\n        expectMinorGridLines(3);\n\n        run();\n\n    }", "LocalizedBug": "RrdDb rrd = new RrdDb(jrbFileName);", "LocalizedPatchLength": 35, "CodeLength": 705}
{"BuggyCode": "@Override\n    public HWDiskStore[] getDisks() {\n        List<HWDiskStore> result;\n        result = new ArrayList<>();\n\n        Map<String, List<String>> vals = WmiUtil.selectStringsFrom(null, \"Win32_DiskDrive\",\n                \"Name,Manufacturer,Model,SerialNumber,Size\", null);\n        for (int i = 0; i < vals.get(\"Name\").size(); i++) {\n            HWDiskStore ds = new HWDiskStore();\n            ds.setName(vals.get(\"Name\").get(i));\n            ds.setModel(String.format(\"%s %s\", vals.get(\"Model\").get(i), vals.get(\"Manufacturer\").get(i)).trim());\n            // Most vendors store serial # as a hex string; convert\n            ds.setSerial(ParseUtil.hexStringToString(vals.get(\"SerialNumber\").get(i)));\n            // If successful this line is the desired value\n            try {\n                ds.setSize(Long.parseLong(vals.get(\"Size\").get(i)));\n            } catch (NumberFormatException e) {\n                // If we failed to parse, give up\n                // This is expected for an empty string on some drives\n                ds.setSize(0L);\n            }\n            result.add(ds);\n        }\n        return result.toArray(new HWDiskStore[result.size()]);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `vals.get(\"Size\")` could be null and is dereferenced at line 54."}, "FixedCode": "@Override\n    public HWDiskStore[] getDisks() {\n        List<HWDiskStore> result;\n        result = new ArrayList<>();\n        readMap.clear();\n        writeMap.clear();\n        populateReadWriteMaps();\n\n        Map<String, List<Object>> vals = WmiUtil.selectObjectsFrom(null, \"Win32_DiskDrive\",\n                \"Name,Manufacturer,Model,SerialNumber,Size,Index\", null, DRIVE_TYPES);\n        for (int i = 0; i < vals.get(\"Name\").size(); i++) {\n            HWDiskStore ds = new HWDiskStore();\n            ds.setName((String) vals.get(\"Name\").get(i));\n            ds.setModel(String.format(\"%s %s\", vals.get(\"Model\").get(i), vals.get(\"Manufacturer\").get(i)).trim());\n            // Most vendors store serial # as a hex string; convert\n            ds.setSerial(ParseUtil.hexStringToString((String) vals.get(\"SerialNumber\").get(i)));\n            String index = vals.get(\"Index\").get(i).toString();\n            if (readMap.containsKey(index)) {\n                ds.setReads(readMap.get(index));\n            }\n            if (writeMap.containsKey(index)) {\n                ds.setWrites(writeMap.get(index));\n            }\n            // If successful this line is the desired value\n            try {\n                ds.setSize(Long.parseLong((String) vals.get(\"Size\").get(i)));\n            } catch (NumberFormatException e) {\n                // If we failed to parse, give up\n                // This is expected for an empty string on some drives\n                ds.setSize(0L);\n            }\n            result.add(ds);\n        }\n        return result.toArray(new HWDiskStore[result.size()]);\n    }", "LocalizedBug": "Map<String, List<String>> vals = WmiUtil.selectStringsFrom(null, \"Win32_DiskDrive\",", "LocalizedPatchLength": 83, "CodeLength": 1175}
{"BuggyCode": "@Test\n  public void testShortArray_AsIntegers_LittleEndian() throws Exception {\n    assertArrayEquals(new byte []{2,1,4,3}, binStart().ByteOrder(JBBPByteOrder.LITTLE_ENDIAN).Short(0x0102,0x0304).end().toByteArray());\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.igormaznitsa.jbbp.io.JBBPBitOutputStream` acquired by call to `binStart()` at line 155 is not released after line 155.\n**Note**: potential exception at line 155"}, "FixedCode": "@Test\n  public void testShortArray_AsIntegers_LittleEndian() throws Exception {\n    assertArrayEquals(new byte []{2,1,4,3}, BeginBin().ByteOrder(JBBPByteOrder.LITTLE_ENDIAN).Short(0x0102,0x0304).End().toByteArray());\n  }", "LocalizedBug": "assertArrayEquals(new byte []{2,1,4,3}, binStart().ByteOrder(JBBPByteOrder.LITTLE_ENDIAN).Short(0x0102,0x0304).end().toByteArray());", "LocalizedPatchLength": 132, "CodeLength": 220}
{"BuggyCode": "static void doCacheEvict(Object[] arguments, Class targetClass, Method method, CacheEvict evict) {\n        String unless = AnnotationUtil.get(evict.unless());\n        if (Utils.isUnless(unless, method, arguments)) {\n            return;\n        }\n\n        String cacheName = AnnotationUtil.get(evict.name());\n        if (StrUtil.isBlank(cacheName)) {\n            throw new JbootException(String.format(\"CacheEvict.name()  must not empty in method [%s].\",\n                    ClassUtil.buildMethodString(method)));\n        }\n\n        String cacheKey = AnnotationUtil.get(evict.key());\n\n        if (StrUtil.isBlank(cacheKey) || \"*\".equals(cacheKey)) {\n            getAopCache().removeAll(cacheName);\n        } else {\n            cacheKey = Utils.buildCacheKey(cacheKey, targetClass, method, arguments);\n            getAopCache().remove(cacheName, cacheKey);\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `io.jboot.components.cache.interceptor.Utils.doCacheEvict` indirectly reads without synchronization from `config.Utils.io.jboot.app.config.Utils.rootClassPath`. Potentially races with write in method `Utils.getAopCache()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "static void doCacheEvict(Object[] arguments, Class targetClass, Method method, CacheEvict evict) {\n        String unless = AnnotationUtil.get(evict.unless());\n        if (Utils.isUnless(unless, method, arguments)) {\n            return;\n        }\n\n        String cacheName = AnnotationUtil.get(evict.name());\n        if (StrUtil.isBlank(cacheName)) {\n            throw new JbootException(String.format(\"CacheEvict.name()  must not empty in method [%s].\",\n                    ClassUtil.buildMethodString(method)));\n        }\n\n        String cacheKey = AnnotationUtil.get(evict.key());\n\n        if (StrUtil.isBlank(cacheKey) || \"*\".equals(cacheKey)) {\n            AopCache.removeAll(cacheName);\n        } else {\n            cacheKey = Utils.buildCacheKey(cacheKey, targetClass, method, arguments);\n            AopCache.remove(cacheName, cacheKey);\n        }\n    }", "LocalizedBug": "getAopCache().removeAll(cacheName);\ngetAopCache().remove(cacheName, cacheKey);", "LocalizedPatchLength": 78, "CodeLength": 870}
{"BuggyCode": "private void _testEscapeCustom(boolean useStream) throws Exception\n    {\n        JsonFactory f = new JsonFactory().setCharacterEscapes(new MyEscapes());\n        final String STR_IN = \"[abcd/\"+((char) TWO_BYTE_ESCAPED)+\"/\"+((char) THREE_BYTE_ESCAPED)+\"]\";\n        final String STR_OUT = \"[\\\\A\\\\u0062c[D]/\"+TWO_BYTE_ESCAPED_STRING+\"/\"+THREE_BYTE_ESCAPED_STRING+\"]\";\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        JsonGenerator jgen;\n        \n        // First: output normally; should not add escaping\n        if (useStream) {\n            jgen = f.createJsonGenerator(bytes, JsonEncoding.UTF8);\n        } else {\n            jgen = f.createJsonGenerator(new OutputStreamWriter(bytes, \"UTF-8\"));\n        }\n        jgen.writeStartObject();\n        jgen.writeStringField(STR_IN, STR_IN);\n        jgen.writeEndObject();\n        jgen.close();\n        String json = bytes.toString(\"UTF-8\");\n        assertEquals(\"{\"+quote(STR_OUT)+\":\"+quote(STR_OUT)+\"}\", json);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.fasterxml.jackson.core.json.WriterBasedJsonGenerator` acquired by call to `createJsonGenerator(...)` at line 167 is not released after line 175.\n**Note**: potential exception at line 171"}, "FixedCode": "private void _testEscapeCustom(boolean useStream) throws Exception\n    {\n        JsonFactory f = new JsonFactory().setCharacterEscapes(new MyEscapes());\n        final String STR_IN = \"[abcd/\"+((char) TWO_BYTE_ESCAPED)+\"/\"+((char) THREE_BYTE_ESCAPED)+\"]\";\n        final String STR_OUT = \"[\\\\A\\\\u0062c[D]/\"+TWO_BYTE_ESCAPED_STRING+\"/\"+THREE_BYTE_ESCAPED_STRING+\"]\";\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        JsonGenerator jgen;\n        \n        // First: output normally; should not add escaping\n        if (useStream) {\n            jgen = f.createGenerator(bytes, JsonEncoding.UTF8);\n        } else {\n            jgen = f.createGenerator(new OutputStreamWriter(bytes, \"UTF-8\"));\n        }\n        jgen.writeStartObject();\n        jgen.writeStringField(STR_IN, STR_IN);\n        jgen.writeEndObject();\n        jgen.close();\n        String json = bytes.toString(\"UTF-8\");\n        assertEquals(\"{\"+quote(STR_OUT)+\":\"+quote(STR_OUT)+\"}\", json);\n    }", "LocalizedBug": "jgen = f.createJsonGenerator(bytes, JsonEncoding.UTF8);\njgen = f.createJsonGenerator(new OutputStreamWriter(bytes, \"UTF-8\"));", "LocalizedPatchLength": 125, "CodeLength": 985}
{"BuggyCode": "@Override\n    public LookbackQuery withGranularity(Granularity granularity) {\n        return withDataSource(new QueryDataSource(getInnerQuery().withGranularity(granularity)));\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getInnerQuery()` could be null and is dereferenced at line 247."}, "FixedCode": "@Override\n    public LookbackQuery withGranularity(Granularity granularity) {\n        return withDataSource(new QueryDataSource(getInnerQueryUnchecked().withGranularity(granularity)));\n    }", "LocalizedBug": "return withDataSource(new QueryDataSource(getInnerQuery().withGranularity(granularity)));", "LocalizedPatchLength": 89, "CodeLength": 181}
{"BuggyCode": "public void testArUnarchive() throws Exception {\n\t\tfinal File output = new File(dir, \"bla.ar\");\n\t\t{\n\t\t\tfinal File file1 = getFile(\"test1.xml\");\n\t\t\tfinal File file2 = getFile(\"test2.xml\");\n\t\t\t\n\t\t\tfinal OutputStream out = new FileOutputStream(output);\n\t        final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", out);\n\t\t\tos.putArchiveEntry(new ArArchiveEntry(\"test1.xml\", file1.length()));\n\t\t\tIOUtils.copy(new FileInputStream(file1), os);\n\t\t\tos.closeArchiveEntry();\n\t\t\t\n\t\t\tos.putArchiveEntry(new ArArchiveEntry(\"test2.xml\", file2.length()));\n\t\t\tIOUtils.copy(new FileInputStream(file2), os);\n\t\t\tos.closeArchiveEntry();\n\t\t\tos.close();\n\t\t\tout.close();\n\t\t}\n\t\t\n\t\t// UnArArchive Operation\n\t\tfinal File input = output;\n\t\tfinal InputStream is = new FileInputStream(input);\n\t\tfinal ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"ar\", is);\n\t\tfinal ArArchiveEntry entry = (ArArchiveEntry)in.getNextEntry();\n\t\t\n\t\tFile target = new File(dir, entry.getName());\n        final OutputStream out = new FileOutputStream(target);\n        \n        IOUtils.copy(in, out);\n    \n        out.close();\n        in.close();\n        is.close();\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.commons.compress.archivers.ar.ArArchiveInputStream` acquired by call to `createArchiveInputStream(...)` at line 74 is not released after line 85.\n**Note**: potential exception at line 80"}, "FixedCode": "public void testArUnarchive() throws Exception {\n\t\tfinal File output = new File(dir, \"bla.ar\");\n\t\t{\n\t\t\tfinal File file1 = getFile(\"test1.xml\");\n\t\t\tfinal File file2 = getFile(\"test2.xml\");\n\t\t\t\n\t\t\tfinal OutputStream out = new FileOutputStream(output);\n\t        final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", out);\n\t\t\tos.putArchiveEntry(new ArArchiveEntry(\"test1.xml\", file1.length()));\n\t\t\tIOUtils.copy(new FileInputStream(file1), os);\n\t\t\tos.closeArchiveEntry();\n\t\t\t\n\t\t\tos.putArchiveEntry(new ArArchiveEntry(\"test2.xml\", file2.length()));\n\t\t\tIOUtils.copy(new FileInputStream(file2), os);\n\t\t\tos.closeArchiveEntry();\n\t\t\tos.close();\n\t\t\tout.close();\n\t\t}\n\t\t\n\t\t// UnArArchive Operation\n\t\tfinal File input = output;\n\t\tfinal InputStream is = new FileInputStream(input);\n\t\tfinal ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));\n\t\tfinal ArArchiveEntry entry = (ArArchiveEntry)in.getNextEntry();\n\t\t\n\t\tFile target = new File(dir, entry.getName());\n        final OutputStream out = new FileOutputStream(target);\n        \n        IOUtils.copy(in, out);\n    \n        out.close();\n        in.close();\n        is.close();\n\t}", "LocalizedBug": "final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"ar\", is);", "LocalizedPatchLength": 92, "CodeLength": 1185}
{"BuggyCode": "@Test\n    public void testAllocate() throws Exception {\n        long size = 1L << 24; // 31; don't overload cloud-bees\n        DirectStore store = DirectStore.allocate(size);\n        assertEquals(size, store.size());\n        DirectBytes slice = store.createSlice();\n        slice.positionAndSize(0, size);\n        slice.writeLong(0, size);\n        slice.writeLong(size - 8, size);\n        store.free();\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `net.openhft.lang.io.DirectBytes` acquired to `slice` by call to `createSlice()` at line 123 is not released after line 126."}, "FixedCode": "@Test\n    public void testAllocate() throws Exception {\n        long size = 1L << 24; // 31; don't overload cloud-bees\n        DirectStore store = DirectStore.allocate(size);\n        assertEquals(size, store.size());\n        DirectBytes slice = store.bytes();\n        slice.positionAndSize(0, size);\n        slice.writeLong(0, size);\n        slice.writeLong(size - 8, size);\n        store.free();\n    }", "LocalizedBug": "DirectBytes slice = store.createSlice();", "LocalizedPatchLength": 40, "CodeLength": 408}
{"BuggyCode": "@Test\n\tpublic void testWindowPeer() throws Exception {\n    if (Platform.isMacOSX() ||\n        System.getProperty(\"java.version)\").matches(\"1\\\\.6\\\\..*\")) {\n      // Oracle Java and jawt: it's complicated.\n      // See http://forum.lwjgl.org/index.php?topic=4326.0\n      // OpenJDK 6 + Linux seem problematic too.\n      return;\n    }\n\t\tassertEquals(6 * Pointer.SIZE, BridJ.sizeOf(JAWT_DrawingSurface.class));\n\t\tassertEquals(4 * 4, BridJ.sizeOf(JAWT_Rectangle.class));\n\t\t//assertEquals(4 + 5 * Pointer.SIZE, BridJ.sizeOf(JAWT.class));\n\t\t//assertEquals(2 * 4 * 4 + 4 + Pointer.SIZE, BridJ.sizeOf(JAWT_DrawingSurfaceInfo.class));\n\t\t \n\t\t\n\t\tFrame f = new Frame();\n\t\tf.pack();\n\t\t\n\t\tf.setVisible(true);\n    Thread.sleep(500);\n\t\tlong p = JAWTUtils.getNativePeerHandle(f);\n\t\tassertTrue(p != 0);\n\t\tf.setVisible(false);\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getProperty(\"java.version)\")` could be null and is dereferenced at line 46."}, "FixedCode": "@Test\n\tpublic void testWindowPeer() throws Exception {\n    if (Platform.isMacOSX() ||\n        System.getProperty(\"java.version\").matches(\"1\\\\.6\\\\..*\")) {\n      // Oracle Java and jawt: it's complicated.\n      // See http://forum.lwjgl.org/index.php?topic=4326.0\n      // OpenJDK 6 + Linux seem problematic too.\n      return;\n    }\n\t\tassertEquals(6 * Pointer.SIZE, BridJ.sizeOf(JAWT_DrawingSurface.class));\n\t\tassertEquals(4 * 4, BridJ.sizeOf(JAWT_Rectangle.class));\n\t\t//assertEquals(4 + 5 * Pointer.SIZE, BridJ.sizeOf(JAWT.class));\n\t\t//assertEquals(2 * 4 * 4 + 4 + Pointer.SIZE, BridJ.sizeOf(JAWT_DrawingSurfaceInfo.class));\n\t\t \n\t\t\n\t\tFrame f = new Frame();\n\t\tf.pack();\n\t\t\n\t\tf.setVisible(true);\n    Thread.sleep(500);\n\t\tlong p = JAWTUtils.getNativePeerHandle(f);\n\t\tassertTrue(p != 0);\n\t\tf.setVisible(false);\n\t}", "LocalizedBug": "System.getProperty(\"java.version)\").matches(\"1\\\\.6\\\\..*\")) {", "LocalizedPatchLength": 60, "CodeLength": 809}
{"BuggyCode": "private static void clearTerminal() {\n\t\tif (System.getProperty(\"os.name\").contains(\"Windows\")) {\n\t\t\t// hack\n\t\t\tSystem.out.printf(\"%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n\");\n\t\t} else if (System.getProperty(\"vjtop.altClear\") != null) {\n\t\t\tSystem.out.print('\\f');\n\t\t} else {\n\t\t\tSystem.out.print(CLEAR_TERMINAL_ANSI_CMD);\n\t\t}\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getProperty(\"os.name\")` could be null and is dereferenced at line 222."}, "FixedCode": "private static void clearTerminal() {\n\t\tif (Utils.isWindows) {\n\t\t\tSystem.out.printf(\"%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n\");\n\t\t} else {\n\t\t\tSystem.out.print(CLEAR_TERMINAL_ANSI_CMD);\n\t\t}\n\t}", "LocalizedBug": "if (System.getProperty(\"os.name\").contains(\"Windows\")) {\n// hack\n} else if (System.getProperty(\"vjtop.altClear\") != null) {\nSystem.out.print('\\f');\n} else {", "LocalizedPatchLength": 156, "CodeLength": 347}
{"BuggyCode": "public void initGameConnectedServer() throws Exception {\n        gameRpcConnecetMananger.initManager();\n        gameRpcConnecetMananger.initServers(sdGameServers);\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.wolf.shoot.service.rpc.server.RpcServiceDiscovery.initGameConnectedServer` reads without synchronization from `this.com.wolf.shoot.service.rpc.server.RpcServiceDiscovery.sdGameServers`. Potentially races with write in method `RpcServiceDiscovery.init()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public void initGameConnectedServer() throws Exception {\n        gameRpcConnecetMananger.initManager();\n        gameRpcConnecetMananger.initServers(rpcConfig.getSdGameServers());\n    }", "LocalizedBug": "gameRpcConnecetMananger.initServers(sdGameServers);", "LocalizedPatchLength": 51, "CodeLength": 169}
{"BuggyCode": "@Test\n    public void testObjectEncode() throws Exception {\n        Base64 b64 = new Base64();\n        assertEquals(\"SGVsbG8gV29ybGQ=\", new String(b64.encode(\"Hello World\".getBytes(\"UTF-8\"))));\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `b64.encode(\"Hello World\".getBytes(\"UTF-8\"))` could be null and is dereferenced by call to `String(...)` at line 522."}, "FixedCode": "@Test\n    public void testObjectEncode() throws Exception {\n        Base64 b64 = new Base64();\n        assertEquals(\"SGVsbG8gV29ybGQ=\", new String(b64.encode(\"Hello World\".getBytes(Charsets.UTF_8))));\n    }", "LocalizedBug": "assertEquals(\"SGVsbG8gV29ybGQ=\", new String(b64.encode(\"Hello World\".getBytes(\"UTF-8\"))));", "LocalizedPatchLength": 90, "CodeLength": 199}
{"BuggyCode": "public TemplateEngine getTemplateEngine() {\n        if (templateEngine == null) {\n            TemplateEngine engine = ServiceLocator.locate(TemplateEngine.class);\n            setTemplateEngine(engine);\n        }\n\n        return templateEngine;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `engine` last assigned on line 140 could be null and is dereferenced by call to `setTemplateEngine(...)` at line 141."}, "FixedCode": "public TemplateEngine getTemplateEngine() {\n        return templateEngine;\n    }", "LocalizedBug": "if (templateEngine == null) {\nTemplateEngine engine = ServiceLocator.locate(TemplateEngine.class);\nsetTemplateEngine(engine);\n}", "LocalizedPatchLength": 127, "CodeLength": 249}
{"BuggyCode": "public static ZipInputStream createZipInputStream(ZipModel zipModel, FileHeader fileHeader, char[] password)\n      throws ZipException {\n    try {\n      SplitInputStream splitInputStream = new SplitInputStream(zipModel.getZipFile(), zipModel.isSplitArchive(),\n          zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());\n      splitInputStream.prepareExtractionForFileHeader(fileHeader);\n\n      ZipInputStream zipInputStream = new ZipInputStream(splitInputStream, password);\n      if (zipInputStream.getNextEntry(fileHeader) == null) {\n        throw new ZipException(\"Could not locate local file header for corresponding file header\");\n      }\n\n      return zipInputStream;\n    } catch (IOException e) {\n      throw new ZipException(e);\n    }\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `net.lingala.zip4j.io.inputstream.SplitInputStream` acquired to `splitInputStream` by call to `new()` at line 23 is not released after line 32.\n**Note**: potential exception at line 24"}, "FixedCode": "public static ZipInputStream createZipInputStream(ZipModel zipModel, FileHeader fileHeader, char[] password)\n      throws IOException {\n\n    SplitInputStream splitInputStream = null;\n    try {\n      splitInputStream = new SplitInputStream(zipModel.getZipFile(), zipModel.isSplitArchive(),\n          zipModel.getEndOfCentralDirectoryRecord().getNumberOfThisDisk());\n      splitInputStream.prepareExtractionForFileHeader(fileHeader);\n\n      ZipInputStream zipInputStream = new ZipInputStream(splitInputStream, password);\n      if (zipInputStream.getNextEntry(fileHeader) == null) {\n        throw new ZipException(\"Could not locate local file header for corresponding file header\");\n      }\n\n      return zipInputStream;\n    } catch (IOException e) {\n      if (splitInputStream != null) {\n        splitInputStream.close();\n      }\n      throw e;\n    }\n  }", "LocalizedBug": "throws ZipException {\nSplitInputStream splitInputStream = new SplitInputStream(zipModel.getZipFile(), zipModel.isSplitArchive(),\nthrow new ZipException(e);", "LocalizedPatchLength": 155, "CodeLength": 761}
{"BuggyCode": "public List<String> fileToLines(String filename) {\n        List<String> lines = new LinkedList<String>();\n        String line = \"\";\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(filename));\n            while ((line = in.readLine()) != null) {\n                lines.add(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n        return lines;\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileReader` acquired by call to `new()` at line 24 is not released after line 28.\n**Note**: potential exception at line 25"}, "FixedCode": "public List<String> fileToLines(String filename) {\n        List<String> lines = new LinkedList<String>();\n        String line = \"\";\n        BufferedReader in = null;\n        try {\n            in = new BufferedReader(new FileReader(filename));\n            while ((line = in.readLine()) != null) {\n                lines.add(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        } finally {\n\t\t\tif (in != null) {\n\t\t\t\ttry {\n\t\t\t\t\tin.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// ignore ... any errors should already have been\n\t\t\t\t\t// reported via an IOException from the final flush.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return lines;\n    }", "LocalizedBug": "BufferedReader in = new BufferedReader(new FileReader(filename));", "LocalizedPatchLength": 65, "CodeLength": 462}
{"BuggyCode": "public void testDeepPrefixedUnwrappingDeserialize() throws Exception\n    {\n        DeepPrefixUnwrap bean = mapper.readValue(\"{\\\"u.name\\\":\\\"Bubba\\\",\\\"u._x\\\":2,\\\"u._y\\\":3}\",\n                DeepPrefixUnwrap.class);\n        assertNotNull(bean.unwrapped);\n        assertNotNull(bean.unwrapped.location);\n        assertEquals(2, bean.unwrapped.location.x);\n        assertEquals(3, bean.unwrapped.location.y);\n        assertEquals(\"Bubba\", bean.unwrapped.name);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `__cast(TestUnwrappedWithPrefix.mapper.readValue(\"{\\\\\\\"u.name\\\\\\\":\\\\\\\"Bubba\\\\\\\",\\\\\\\"u._x\\\\\\\":2,\\\\\\\"u._y\\\\\\\":3}\",com.fasterxml.jackson.databind.struct.TestUnwrappedWithPrefix$DeepPrefixUnwrap),com.fasterxml.jackson.databind.struct.TestUnwrappedWithPrefix$DeepPrefixUnwrap)` could be null and is dereferenced at line 172."}, "FixedCode": "public void testDeepPrefixedUnwrappingDeserialize() throws Exception\n    {\n        DeepPrefixUnwrap bean = MAPPER.readValue(\"{\\\"u.name\\\":\\\"Bubba\\\",\\\"u._x\\\":2,\\\"u._y\\\":3}\",\n                DeepPrefixUnwrap.class);\n        assertNotNull(bean.unwrapped);\n        assertNotNull(bean.unwrapped.location);\n        assertEquals(2, bean.unwrapped.location.x);\n        assertEquals(3, bean.unwrapped.location.y);\n        assertEquals(\"Bubba\", bean.unwrapped.name);\n    }", "LocalizedBug": "DeepPrefixUnwrap bean = mapper.readValue(\"{\\\"u.name\\\":\\\"Bubba\\\",\\\"u._x\\\":2,\\\"u._y\\\":3}\",", "LocalizedPatchLength": 88, "CodeLength": 461}
{"BuggyCode": "long putAddCount()\n    {\n        return putAddCount;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.caffinitas.ohc.tables.OffHeapMap.putAddCount` reads without synchronization from `this.org.caffinitas.ohc.tables.OffHeapMap.putAddCount`. Potentially races with write in method `OffHeapMap.putEntry(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, AtomicLong freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        int bl = builder.getBucketLength();\n        if (bl <= 0)\n            bl = 8;\n        int buckets = (int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE);\n        entriesPerBucket = (int) Util.roundUpToPowerOf2(bl, MAX_TABLE_SIZE);\n        table = Table.create(buckets, entriesPerBucket);\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        if (lf >= 1d)\n            throw new IllegalArgumentException(\"load factor must not be greater that 1\");\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "long putAddCount()\n{\nreturn putAddCount;", "LocalizedPatchLength": 40, "CodeLength": 58}
{"BuggyCode": "@Test\n\tpublic void newConnectionManager() throws Exception {\n\t\tHttpClientConnectionManager connectionManager = new DefaultApacheHttpClientConnectionManagerFactory()\n\t\t\t\t.newConnectionManager(false, 2, 6);\n\t\tthen(((PoolingHttpClientConnectionManager) connectionManager)\n\t\t\t\t.getDefaultMaxPerRoute()).isEqualTo(6);\n\t\tthen(((PoolingHttpClientConnectionManager) connectionManager).getMaxTotal())\n\t\t\t\t.isEqualTo(2);\n\t\tObject pool = getField(((PoolingHttpClientConnectionManager) connectionManager),\n\t\t\t\t\"pool\");\n\t\tthen((Long) getField(pool, \"timeToLive\")).isEqualTo(new Long(-1));\n\t\tTimeUnit timeUnit = getField(pool, \"tunit\");\n\t\tthen(timeUnit).isEqualTo(TimeUnit.MILLISECONDS);\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.http.impl.conn.PoolingHttpClientConnectionManager` acquired by call to `newConnectionManager(...)` at line 46 is not released after line 51."}, "FixedCode": "@Test\n\tpublic void newConnectionManager() {\n\t\tHttpClientConnectionManager connectionManager = new DefaultApacheHttpClientConnectionManagerFactory()\n\t\t\t\t.newConnectionManager(false, 2, 6);\n\t\tthen(((PoolingHttpClientConnectionManager) connectionManager)\n\t\t\t\t.getDefaultMaxPerRoute()).isEqualTo(6);\n\t\tthen(((PoolingHttpClientConnectionManager) connectionManager).getMaxTotal())\n\t\t\t\t.isEqualTo(2);\n\t\tObject pool = getField((connectionManager), \"pool\");\n\t\tthen((Long) getField(pool, \"timeToLive\")).isEqualTo(new Long(-1));\n\t\tTimeUnit timeUnit = getField(pool, \"timeUnit\");\n\t\tthen(timeUnit).isEqualTo(TimeUnit.MILLISECONDS);\n\t}", "LocalizedBug": "public void newConnectionManager() throws Exception {\nObject pool = getField(((PoolingHttpClientConnectionManager) connectionManager),\nTimeUnit timeUnit = getField(pool, \"tunit\");", "LocalizedPatchLength": 179, "CodeLength": 676}
{"BuggyCode": "@Test\n    public void rendersSingleArtifact() throws Exception {\n        final Farm farm = new PropsFarm(new FkFarm());\n        MatcherAssert.assertThat(\n            XhtmlMatchers.xhtml(\n                new RsPrint(\n                    new TkApp(farm).act(\n                        new RqWithUser.WithInit(\n                            farm,\n                            new RqFake(\n                                \"GET\",\n                                \"/xml/C00000000?file=roles.xml\"\n                            )\n                        )\n                    )\n                ).printBody()\n            ),\n            XhtmlMatchers.hasXPaths(\"/roles\")\n        );\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.FkFarm` acquired by call to `FkFarm()` at line 40 is not released after line 41."}, "FixedCode": "@Test\n    public void rendersSingleArtifact() throws Exception {\n        final Farm farm = FkFarm.props();\n        MatcherAssert.assertThat(\n            XhtmlMatchers.xhtml(\n                new RsPrint(\n                    new TkApp(farm).act(\n                        new RqWithUser.WithInit(\n                            farm,\n                            new RqFake(\n                                \"GET\",\n                                \"/xml/C00000000?file=roles.xml\"\n                            )\n                        )\n                    )\n                ).printBody()\n            ),\n            XhtmlMatchers.hasXPaths(\"/roles\")\n        );\n    }", "LocalizedBug": "final Farm farm = new PropsFarm(new FkFarm());", "LocalizedPatchLength": 46, "CodeLength": 668}
{"BuggyCode": "@Test\n    public void testUsingMongoCollectionAnnotation() {\n        JacksonDBCollection<Owner, String> coll = getCollection(Owner.class, String.class);\n        JacksonDBCollection<Referenced, String> refColl = getCollection(Referenced.class, String.class, \"referenced\");\n\n        refColl.insert(new Referenced(\"hello\", 10));\n        String id = coll.insert(new Owner(new DBRef<Referenced, String>(\"hello\", Referenced.class))).getSavedId();\n\n        Owner saved = coll.findOneById(id);\n        assertThat(saved.ref, notNullValue());\n        assertThat(saved.ref.getId(), equalTo(\"hello\"));\n        assertThat(saved.ref.getCollectionName(), equalTo(\"referenced\"));\n\n        // Try loading it\n        Referenced ref = saved.ref.fetch();\n        assertThat(ref, notNullValue());\n        assertThat(ref._id, equalTo(\"hello\"));\n        assertThat(ref.i, equalTo(10));\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `saved` last assigned on line 80 could be null and is dereferenced at line 81."}, "FixedCode": "@Test\n    public void testUsingMongoCollectionAnnotation() {\n        JacksonDBCollection<Owner, String> coll = getCollection(Owner.class, String.class);\n        JacksonDBCollection<Referenced, String> refColl = getCollection(Referenced.class, String.class, \"referenced\");\n\n        refColl.insert(new Referenced(\"hello\", 10));\n        coll.insert(new Owner(new DBRef<Referenced, String>(\"hello\", Referenced.class)));\n        String id = coll.findOne()._id;\n\n        Owner saved = coll.findOneById(id);\n        assertThat(saved.ref, notNullValue());\n        assertThat(saved.ref.getId(), equalTo(\"hello\"));\n        assertThat(saved.ref.getCollectionName(), equalTo(\"referenced\"));\n\n        // Try loading it\n        Referenced ref = saved.ref.fetch();\n        assertThat(ref, notNullValue());\n        assertThat(ref._id, equalTo(\"hello\"));\n        assertThat(ref.i, equalTo(10));\n    }", "LocalizedBug": "String id = coll.insert(new Owner(new DBRef<Referenced, String>(\"hello\", Referenced.class))).getSavedId();", "LocalizedPatchLength": 106, "CodeLength": 868}
{"BuggyCode": "@Deprecated\n  public static boolean addHotkey(String key, int modifiers, HotkeyListener listener) {\n    return HotkeyManager.getInstance().addHotkey(key, modifiers, listener);\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getInstance()` could be null and is dereferenced at line 177."}, "FixedCode": "@Deprecated\n  public static boolean addHotkey(String key, int modifiers, HotkeyListener listener) {\n    return Key.addHotkey(key, modifiers, listener);\n  }", "LocalizedBug": "return HotkeyManager.getInstance().addHotkey(key, modifiers, listener);", "LocalizedPatchLength": 71, "CodeLength": 179}
{"BuggyCode": "@Test\n  public void shouldCreateFeaturedPlaylistsRequest() {\n    final String accessToken = \"myAccessToken\";\n\n    final Api api = Api.builder()\n        .accessToken(accessToken)\n        .build();\n\n\n    Calendar calendar = Calendar.getInstance();\n    calendar.set(2014, 11, 22, 13, 59, 30);\n    Date timestamp = calendar.getTime();\n\n    final Request request = api\n        .getFeaturedPlaylists()\n        .country(\"SE\")\n        .locale(\"es_MX\")\n        .limit(5)\n        .offset(1)\n        .timestamp(timestamp)\n        .build();\n\n    DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n\n    assertEquals(\"https://api.spotify.com:443/v1/browse/featured-playlists\", request.toString());\n    assertHasHeader(request.toUrl(), \"Authorization\", \"Bearer \" + accessToken);\n    assertHasParameter(request.toUrl(), \"limit\", \"5\");\n    assertHasParameter(request.toUrl(), \"offset\", \"1\");\n    assertHasParameter(request.toUrl(), \"country\", \"SE\");\n    assertHasParameter(request.toUrl(), \"locale\", \"es_MX\");\n    assertHasParameter(request.toUrl(), \"timestamp\", format.format(timestamp));\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `request.toUrl()` could be null and is dereferenced by call to `assertHasHeader(...)` at line 579."}, "FixedCode": "@Test\n  public void shouldCreateFeaturedPlaylistsRequest() {\n    final String accessToken = \"myAccessToken\";\n\n    final Api api = Api.builder()\n        .accessToken(accessToken)\n        .build();\n\n\n    Calendar calendar = Calendar.getInstance();\n    calendar.set(2014, Calendar.DECEMBER, 22, 13, 59, 30);\n    Date timestamp = calendar.getTime();\n\n    final Request request = api\n        .getFeaturedPlaylists()\n        .country(\"SE\")\n        .locale(\"es_MX\")\n        .limit(5)\n        .offset(1)\n        .timestamp(timestamp)\n        .build();\n\n    DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n\n    assertEquals(\"https://api.spotify.com:443/v1/browse/featured-playlists\", request.toString());\n    assertHasHeader(request.toUrl(), \"Authorization\", \"Bearer \" + accessToken);\n    assertHasParameter(request.toUrl(), \"limit\", \"5\");\n    assertHasParameter(request.toUrl(), \"offset\", \"1\");\n    assertHasParameter(request.toUrl(), \"country\", \"SE\");\n    assertHasParameter(request.toUrl(), \"locale\", \"es_MX\");\n    assertHasParameter(request.toUrl(), \"timestamp\", format.format(timestamp));\n  }", "LocalizedBug": "calendar.set(2014, 11, 22, 13, 59, 30);", "LocalizedPatchLength": 39, "CodeLength": 1092}
{"BuggyCode": "@DelayedWrite\n\tpublic short set(int index, short value) {\n\t\tsynchronized (live) {\n\t\t\tlive[index] = value;\n\t\t}\n\t\tint localDirtyIndex = dirtyIndex.getAndIncrement();\n\t\tif (localDirtyIndex < dirtyArray.length) {\n\t\t\tdirtyArray[localDirtyIndex] = index;\n\t\t}\n\t\treturn snapshot[index];\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.getspout.server.util.thread.snapshotable.SnapshotableShortArray.set` writes to field `this.org.getspout.server.util.thread.snapshotable.SnapshotableShortArray.dirtyArray.[_]` outside of synchronization.\n Reporting because this access may occur on a background thread."}, "FixedCode": "@DelayedWrite\n\tpublic short set(int index, short value) {\n\t\tboolean success = false;\n\t\tint divIndex = index >> 1;\n\t\tboolean isZero = (index & 0x1) == 0;\n\t\tshort one;\n\t\tshort zero;\n\t\tshort old = 0;\n\t\t\n\t\twhile (!success) {\n\t\t\tint packed = live.get(divIndex);\n\t\t\tif (isZero) {\n\t\t\t\told = unpackZero(packed);\n\t\t\t\tone = unpackOne(packed);\n\t\t\t\tzero = value;\n\t\t\t} else {\n\t\t\t\told = unpackOne(packed);\n\t\t\t\tone = value;\n\t\t\t\tzero = unpackZero(packed);\n\t\t\t}\n\t\t\tsuccess = live.compareAndSet(divIndex, packed, pack(zero, one));\n\t\t}\n\t\tmarkDirty(index);\n\t\treturn old;\n\t}", "LocalizedBug": "synchronized (live) {\nlive[index] = value;\nint localDirtyIndex = dirtyIndex.getAndIncrement();\nif (localDirtyIndex < dirtyArray.length) {\ndirtyArray[localDirtyIndex] = index;\nreturn snapshot[index];", "LocalizedPatchLength": 198, "CodeLength": 281}
{"BuggyCode": "void resetStatistics()\n    {\n        rehashes = 0L;\n        evictedEntries = 0L;\n        hitCount = 0L;\n        missCount = 0L;\n        putAddCount = 0L;\n        putReplaceCount = 0L;\n        removeCount = 0L;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.caffinitas.ohc.OffHeapMap.resetStatistics` writes to field `this.org.caffinitas.ohc.OffHeapMap.removeCount` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, AtomicLong freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        table = Table.create((int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE));\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "void resetStatistics()\n{\nrehashes = 0L;\nevictedEntries = 0L;\nhitCount = 0L;\nmissCount = 0L;\nputAddCount = 0L;\nputReplaceCount = 0L;\nremoveCount = 0L;", "LocalizedPatchLength": 149, "CodeLength": 215}
{"BuggyCode": "private void sendMessage(String ircCatHost, int ircCatPort, String message, String channel) throws IOException {\n        Socket socket = new Socket(ircCatHost, ircCatPort);\n        Writer out = new OutputStreamWriter(socket.getOutputStream());\n        try {\n            out.write(format(\"%s %s\\n\", channel, message));\n            out.flush();\n        } catch (IOException e) {\n            Closeables.closeQuietly(out);\n            socket.close();\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.net.Socket` acquired to `socket` by call to `new()` at line 82 is not released after line 91."}, "FixedCode": "private void sendMessage(String ircCatHost, int ircCatPort, String message, String channel) throws IOException {\n        Socket socket = new Socket(ircCatHost, ircCatPort);\n        Closer closer = Closer.create();\n        try {\n            Writer out = closer.register(new OutputStreamWriter(socket.getOutputStream()));\n            out.write(format(\"%s %s\\n\", channel, message));\n            out.flush();\n        } catch (IOException e) {\n            socket.close();\n            throw closer.rethrow(e);\n        } finally {\n            closer.close();\n        }\n    }", "LocalizedBug": "try {\nCloseables.closeQuietly(out);\nsocket.close();", "LocalizedPatchLength": 51, "CodeLength": 462}
{"BuggyCode": "@Test\n    public void testExpiredIteratorException() {\n        log.info(\"Starting tests\");\n        when(getRecordsRetrievalStrategy.getRecords(MAX_RECORDS_PER_CALL)).thenThrow(ExpiredIteratorException.class)\n                .thenReturn(getRecordsResponse);\n\n        getRecordsCache.start(sequenceNumber, initialPosition);\n\n        doNothing().when(dataFetcher).restartIterator();\n\n        getRecordsCache.getNextResult();\n\n        sleep(1000);\n\n        verify(dataFetcher).restartIterator();\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `software.amazon.kinesis.retrieval.polling.PrefetchRecordsPublisherTest.testExpiredIteratorException` indirectly reads without synchronization from `this.software.amazon.kinesis.retrieval.polling.PrefetchRecordsPublisherTest.getRecordsCache.software.amazon.kinesis.retrieval.polling.PrefetchRecordsPublisher.started`. Potentially races with write in method `PrefetchRecordsPublisherTest.testNoDeadlockOnFullQueue()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Test\n    public void testExpiredIteratorException() {\n        log.info(\"Starting tests\");\n        when(getRecordsRetrievalStrategy.getRecords(MAX_RECORDS_PER_CALL)).thenThrow(ExpiredIteratorException.class)\n                .thenReturn(getRecordsResponse);\n\n        getRecordsCache.start(sequenceNumber, initialPosition);\n\n        doNothing().when(dataFetcher).restartIterator();\n\n        blockUntilRecordsAvailable(() -> getRecordsCache.pollNextResultAndUpdatePrefetchCounters(), 1000L);\n\n        sleep(1000);\n\n        verify(dataFetcher).restartIterator();\n    }", "LocalizedBug": "getRecordsCache.getNextResult();", "LocalizedPatchLength": 32, "CodeLength": 497}
{"BuggyCode": "public static byte[] getFileAttributes(File file) {\n    try {\n      if (file == null || (!Files.isSymbolicLink(file.toPath()) && !file.exists())) {\n        return new byte[4];\n      }\n\n      Path path = file.toPath();\n\n      String os = System.getProperty(\"os.name\").toLowerCase();\n      if (isWindows(os)) {\n        return getWindowsFileAttributes(path);\n      } else if (isMac(os) || isUnix(os)) {\n        return getPosixFileAttributes(path);\n      } else {\n        return new byte[4];\n      }\n    } catch (NoSuchMethodError e) {\n      return new byte[4];\n    }\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getProperty(\"os.name\")` could be null and is dereferenced at line 63."}, "FixedCode": "public static byte[] getFileAttributes(File file) {\n    try {\n      if (file == null || (!Files.isSymbolicLink(file.toPath()) && !file.exists())) {\n        return new byte[4];\n      }\n\n      Path path = file.toPath();\n\n      if (isWindows()) {\n        return getWindowsFileAttributes(path);\n      } else if (isMac() || isUnix()) {\n        return getPosixFileAttributes(path);\n      } else {\n        return new byte[4];\n      }\n    } catch (NoSuchMethodError e) {\n      return new byte[4];\n    }\n  }", "LocalizedBug": "String os = System.getProperty(\"os.name\").toLowerCase();\nif (isWindows(os)) {\n} else if (isMac(os) || isUnix(os)) {", "LocalizedPatchLength": 115, "CodeLength": 567}
{"BuggyCode": "private void writeToFile(String message, String path) throws IOException{\n\t\tif(StringUtils.isEmpty(message) || StringUtils.isEmpty(path)){\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tRandomAccessFile rf = new RandomAccessFile(path, \"rw\");\n\t\trf.seek(rf.length());\n\t\trf.write(message.getBytes());\n\t\trf.close();\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.RandomAccessFile` acquired to `rf` by call to `RandomAccessFile(...)` at line 255 is not released after line 259.\n**Note**: potential exception at line 257"}, "FixedCode": "private void writeToFile(String message, String path) throws IOException {\n\t\tif(StringUtils.isEmpty(message) || StringUtils.isEmpty(path)){\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tPrintWriter out = null;\n\t\ttry {\n\t\t\tout = new PrintWriter(new BufferedWriter(new FileWriter(path, true)));\n\t\t\tout.println(message);\n\t\t\tout.flush();\n\t\t} finally {\n\t\t\tif( null != out ) {\n\t\t\t\tout.close();\n\t\t\t}\n\t\t}\n\t}", "LocalizedBug": "RandomAccessFile rf = new RandomAccessFile(path, \"rw\");\nrf.seek(rf.length());\nrf.write(message.getBytes());\nrf.close();", "LocalizedPatchLength": 119, "CodeLength": 288}
{"BuggyCode": "public String getProperty(String name) {\n\t\tProperties properties = new Properties();\n\t\tResource resource = new ClassPathResource(\"server.properties\");\n\t\tFileInputStream fileInputStream = null;\n\t\tString value = null;\n\t\ttry {\n\t\t\tfileInputStream = new FileInputStream(resource.getFile());\n\t\t\tproperties.load(new FileInputStream(resource.getFile()));\n\t\t\tvalue = properties.getProperty(name);\n\t\t} catch (Exception e) {\n\t\t\t\n\t\t}finally {\n\t\t\tif(fileInputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\tfileInputStream.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 24 is not released after line 24."}, "FixedCode": "public String getProperty(String name) {\n\t\tProperties properties = new Properties();\n\t\tFileInputStream fileInputStream = null;\n\t\tString value = null;\n\t\ttry {\n\t\t\tfileInputStream = new FileInputStream(this.getProperties());\n\t\t\tproperties.load(fileInputStream);\n\t\t\tvalue = properties.getProperty(name);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tif(fileInputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\tfileInputStream.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}", "LocalizedBug": "Properties properties = new Properties();\nResource resource = new ClassPathResource(\"server.properties\");\nfileInputStream = new FileInputStream(resource.getFile());\nproperties.load(new FileInputStream(resource.getFile()));\n// TODO Auto-generated catch block", "LocalizedPatchLength": 257, "CodeLength": 633}
{"BuggyCode": "public static void useDefaultEngines() {\n        useEngine(new GraphvizCmdLineEngine(), new GraphvizV8Engine(),\n                new GraphvizServerEngine(), new GraphvizJdkEngine());\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `guru.nidi.graphviz.engine.GraphvizJdkEngine` acquired by call to `GraphvizJdkEngine()` at line 68 is not released after line 68."}, "FixedCode": "public static void useDefaultEngines() {\n        useEngine(AVAILABLE_ENGINES);\n    }", "LocalizedBug": "useEngine(new GraphvizCmdLineEngine(), new GraphvizV8Engine(),\nnew GraphvizServerEngine(), new GraphvizJdkEngine());", "LocalizedPatchLength": 116, "CodeLength": 187}
{"BuggyCode": "public void run(ClassGroup one, ClassGroup two)\n\t{\n\t\teone = new Execution(one);\n\t\teone.populateInitialMethods();\n\t\teone.run();\n\t\t\n\t\tetwo = new Execution(two);\n\t\tetwo.populateInitialMethods();\n\t\tetwo.run();\n\t\t\n\t\tprocess(\n\t\t\tone.findClass(\"client\").findMethod(\"init\"),\n\t\t\ttwo.findClass(\"client\").findMethod(\"init\")\n\t\t);\n\n\t\tSystem.out.println(\"done\");\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `one.findClass(\"client\")` could be null and is dereferenced at line 90."}, "FixedCode": "public void run(ClassGroup one, ClassGroup two)\n\t{\n\t\teone = new Execution(one);\n\t\teone.populateInitialMethods();\n\t\tList<Method> initial1 = eone.getInitialMethods().stream().sorted((m1, m2) -> m1.getName().compareTo(m2.getName())).collect(Collectors.toList());\n\t\teone.run();\n\t\t\n\t\tetwo = new Execution(two);\n\t\tetwo.populateInitialMethods();\n\t\tList<Method> initial2 = etwo.getInitialMethods().stream().sorted((m1, m2) -> m1.getName().compareTo(m2.getName())).collect(Collectors.toList());\n\t\tetwo.run();\n\t\t\n\t\tassert initial1.size() == initial2.size();\n\t\t\n\t\tfor (int i = 0; i < initial1.size(); ++i)\n\t\t{\n\t\t\tMethod m1 = initial1.get(i), m2 = initial2.get(i);\n\t\t\t\n\t\t\tobjMap.put(m1, m2);\n\t\t}\n\n//\t\tprocess(\n//\t\t\tinitial1.get(0).getMethod(),\n//\t\t\tinitial2.get(0).getMethod()\n//\t\t);\n//\t\tprocessed.add(initial1.get(0).getMethod());\n\t\tprocess(\n\t\t\tone.findClass(\"class143\").findMethod(\"run\"),\n\t\t\ttwo.findClass(\"class143\").findMethod(\"run\")\n\t\t);\n//\t\tprocessed.add(one.findClass(\"client\").findMethod(\"init\"));\n\t\t\n//\t\tfor (;;)\n//\t\t{\n//\t\t\tOptional next = objMap.keySet().stream()\n//\t\t\t\t.filter(m -> !processed.contains(m))\n//\t\t\t\t.findAny();\n//\t\t\tif (!next.isPresent())\n//\t\t\t\tbreak;\n//\t\t\t\n//\t\t\tMethod m = (Method) next.get();\n//\t\t\tMethod m2 = (Method) objMap.get(m);\n//\t\t\t\n//\t\t\tSystem.out.println(\"Scanning \" + m.getName() + \" -> \" + m2.getName());\n//\t\t\tprocess(m, m2);\n//\t\t\tprocessed.add(m);\n//\t\t}\n\t\t\n\t\tfor (Entry<Object, Object> e : objMap.entrySet())\n\t\t{\n\t\t\tMethod m1 = (Method) e.getKey();\n\t\t\tMethod m2 = (Method) e.getValue();\n\t\t\t\n\t\t\tSystem.out.println(\"FINAL \" + m1.getMethods().getClassFile().getName() + \".\" + m1.getName() + \" -> \" + m2.getMethods().getClassFile().getName() + \".\" + m2.getName());\n\t\t}\n\n\t\tSystem.out.println(\"done\");\n\t}", "LocalizedBug": "one.findClass(\"client\").findMethod(\"init\"),\ntwo.findClass(\"client\").findMethod(\"init\")\n);", "LocalizedPatchLength": 89, "CodeLength": 351}
{"BuggyCode": "int enable_load_extension(boolean enable) throws SQLException\n    {\n        return call(\"sqlite3_enable_load_extension\", handle, enable ? 1 : 0);\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.sqlite.NestedDB.enable_load_extension` reads without synchronization from `this.org.sqlite.NestedDB.handle`. Potentially races with write in method `NestedDB._open(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "int shared_cache(boolean enable) throws SQLException\n    {\n        // The shared cache is per-process, so it is useless as\n        // each nested connection is its own process.\n        return -1;\n    }", "LocalizedBug": "int enable_load_extension(boolean enable) throws SQLException\nreturn call(\"sqlite3_enable_load_extension\", handle, enable ? 1 : 0);", "LocalizedPatchLength": 131, "CodeLength": 151}
{"BuggyCode": "public void install() throws InstallationException {\n        if(nodeDownloadRoot == null || nodeDownloadRoot.isEmpty()){\n            nodeDownloadRoot = DEFAULT_NODEJS_DOWNLOAD_ROOT;\n        }\n        if(npmDownloadRoot == null || npmDownloadRoot.isEmpty()){\n            npmDownloadRoot = DEFAULT_NPM_DOWNLOAD_ROOT;\n        }\n        synchronized (lock) {\n            if (!nodeIsAlreadyInstalled()) {\n                logger.info(\"Installing node version {}\", nodeVersion);\n                if (!nodeVersion.startsWith(\"v\")) {\n                    logger.warn(\"Node version does not start with naming convention 'v'.\");\n                }\n                if (config.getPlatform().isWindows()) {\n                    installNodeForWindows();\n                } else {\n                    installNodeDefault();\n                }\n            }\n            if (!npmIsAlreadyInstalled()) {\n                installNpm();\n            }\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `com.github.eirslett.maven.plugins.frontend.lib.NodeAndNPMInstaller.install` writes to field `this.com.github.eirslett.maven.plugins.frontend.lib.NodeAndNPMInstaller.npmDownloadRoot` outside of synchronization.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public void install() throws InstallationException {\n        // use static lock object for a synchronized block\n        synchronized (LOCK) {\n            if(nodeDownloadRoot == null || nodeDownloadRoot.isEmpty()){\n                nodeDownloadRoot = DEFAULT_NODEJS_DOWNLOAD_ROOT;\n            }\n            if(npmDownloadRoot == null || npmDownloadRoot.isEmpty()){\n                npmDownloadRoot = DEFAULT_NPM_DOWNLOAD_ROOT;\n            }\n            if (!nodeIsAlreadyInstalled()) {\n                logger.info(\"Installing node version {}\", nodeVersion);\n                if (!nodeVersion.startsWith(\"v\")) {\n                    logger.warn(\"Node version does not start with naming convention 'v'.\");\n                }\n                if (config.getPlatform().isWindows()) {\n                    installNodeForWindows();\n                } else {\n                    installNodeDefault();\n                }\n            }\n            if (!npmIsAlreadyInstalled()) {\n                installNpm();\n            }\n        }\n    }", "LocalizedBug": "synchronized (lock) {", "LocalizedPatchLength": 21, "CodeLength": 937}
{"BuggyCode": "@Test\n    public void setsEstimatesOnAssign() throws Exception {\n        final Project project = new FkProject();\n        final PropsFarm farm = new PropsFarm();\n        new Ledger(farm, project).bootstrap().add(\n            new Ledger.Transaction(\n                new Cash.S(\"$1000\"),\n                \"assets\", \"cash\",\n                \"income\", \"sponsor\",\n                \"There is some funding just arrived\"\n            )\n        );\n        final String login = \"dmarkov\";\n        new Rates(project).bootstrap().set(login, new Cash.S(\"$50\"));\n        final String job = \"gh:yegor256/0pdd#19\";\n        final Wbs wbs = new Wbs(project).bootstrap();\n        wbs.add(job);\n        wbs.role(job, \"REV\");\n        final Orders orders = new Orders(farm, project).bootstrap();\n        orders.assign(job, login, \"0\");\n        MatcherAssert.assertThat(\n            new Estimates(farm, project).bootstrap().get(job),\n            Matchers.equalTo(new Cash.S(\"$12.50\"))\n        );\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.farm.fake.FkFarm` acquired by call to `PropsFarm()` at line 53 is not released after line 71."}, "FixedCode": "@Test\n    public void setsEstimatesOnAssign() throws Exception {\n        final Project project = new FkProject();\n        final PropsFarm farm = new PropsFarm();\n        new Ledger(farm, project).bootstrap().add(\n            new Ledger.Transaction(\n                new Cash.S(\"$1000\"),\n                \"assets\", \"cash\",\n                \"income\", \"sponsor\",\n                \"There is some funding just arrived\"\n            )\n        );\n        final String login = \"dmarkov\";\n        new Rates(project).bootstrap().set(login, new Cash.S(\"$50\"));\n        final String job = \"gh:yegor256/0pdd#19\";\n        final Wbs wbs = new Wbs(project).bootstrap();\n        wbs.add(job);\n        wbs.role(job, \"REV\");\n        final Orders orders = new Orders(farm, project).bootstrap();\n        orders.assign(job, login, UUID.randomUUID().toString());\n        MatcherAssert.assertThat(\n            new Estimates(farm, project).bootstrap().get(job),\n            Matchers.equalTo(new Cash.S(\"$12.50\"))\n        );\n    }", "LocalizedBug": "orders.assign(job, login, \"0\");", "LocalizedPatchLength": 31, "CodeLength": 974}
{"BuggyCode": "@Test\n  public void whenDesiredStateIsAdmin_serverStartupCreatesJavaOptionsEnvironment() {\n    configureServer(\"ms1\").withDesiredState(ADMIN_STATE);\n    addWlsServer(\"ms1\");\n\n    invokeStep();\n\n    assertThat(\n        getServerStartupInfo(\"ms1\").getEnvironment(),\n        hasItem(envVar(\"JAVA_OPTIONS\", \"-Dweblogic.management.startupMode=ADMIN\")));\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getServerStartupInfo(\"ms1\")` could be null and is dereferenced at line 326."}, "FixedCode": "@Test\n  public void whenDesiredStateIsAdmin_serverStartupCreatesJavaOptionsEnvironment() {\n    configureServer(\"wls1\").withDesiredState(ADMIN_STATE);\n    addWlsServer(\"wls1\");\n\n    invokeStep();\n\n    assertThat(\n        getServerStartupInfo(\"wls1\").getEnvironment(),\n        hasItem(envVar(\"JAVA_OPTIONS\", \"-Dweblogic.management.startupMode=ADMIN\")));\n  }", "LocalizedBug": "configureServer(\"ms1\").withDesiredState(ADMIN_STATE);\naddWlsServer(\"ms1\");\ngetServerStartupInfo(\"ms1\").getEnvironment(),", "LocalizedPatchLength": 120, "CodeLength": 352}
{"BuggyCode": "@Override\n    protected StreamSinkFrameChannel create(StreamSinkChannel channel, WebSocketFrameType type, long payloadSize) {\n        return new WebSocket08FrameSinkChannel(channel, this, type, payloadSize);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `io.undertow.websockets.version08.WebSocket08FrameSinkChannel` acquired by call to `WebSocket08FrameSinkChannel(...)` at line 80 is not released after line 80.\n**Note**: potential exception at line 80"}, "FixedCode": "@Override\n    protected StreamSinkFrameChannel create(StreamSinkChannel channel, WebSocketFrameType type, long payloadSize) {\n        switch (type) {\n            case TEXT:\n                return new WebSocket08TextFrameSinkChannel(channel, this, payloadSize);\n            case BINARY:\n                return new WebSocket08BinaryFrameSinkChannel(channel, this, payloadSize);\n            case CLOSE:\n                return new WebSocket08CloseFrameSinkChannel(channel, this, payloadSize);\n            case PONG:\n                return new WebSocket08PongFrameSinkChannel(channel, this, payloadSize);\n            case PING:\n                return new WebSocket08PingFrameSinkChannel(channel, this, payloadSize);\n            case CONTINUATION:\n                return new WebSocket08ContinuationFrameSinkChannel(channel, this, payloadSize);\n            default:\n                throw new IllegalArgumentException(\"WebSocketFrameType \" + type + \" is not supported by this WebSocketChannel\");\n        }\n    }", "LocalizedBug": "return new WebSocket08FrameSinkChannel(channel, this, type, payloadSize);", "LocalizedPatchLength": 73, "CodeLength": 213}
{"BuggyCode": "public final boolean generateFailure() {\n        final int numberOfFailedPes = setFailedHostPes();\n        final long hostWorkingPes = host.getNumberOfWorkingPes();\n        final long vmsRequiredPes = getPesSumOfWorkingVms();\n        Log.printFormattedLine(\"\\t%.2f: Generated %d PEs failures for Host %d\", getSimulation().clock(), numberOfFailedPes, host.getId());\n        if(vmsRequiredPes == 0){\n            System.out.printf(\"\\t      Number of VMs: %d\\n\", host.getId(), host.getVmList().size());\n        }\n        System.out.printf(\"\\t      Working PEs: %d | VMs required PEs: %d\\n\", hostWorkingPes, vmsRequiredPes);\n        if(hostWorkingPes == 0){\n            setAllVmsToFailed();  \n        } else if (hostWorkingPes >= vmsRequiredPes) {\n            logNoVmFailure();  \n        } else {\n            deallocateFailedHostPesFromVms();\n        } \n        \n        return numberOfFailedPes > 0;\n    }", "BugInfo": {"bug_type": "CHECKERS_PRINTF_ARGS", "qualifier": "format string arguments don't mach provided arguments in printf(...) at line 142."}, "FixedCode": "public final boolean generateFailure() {\n        final int numberOfFailedPes = setFailedHostPes();\n        final long hostWorkingPes = host.getNumberOfWorkingPes();\n        final long vmsRequiredPes = getPesSumOfWorkingVms();\n        Log.printFormattedLine(\"\\t%.2f: Generated %d PEs failures for %s\", getSimulation().clock(), numberOfFailedPes, host);\n        if(vmsRequiredPes == 0){\n            System.out.printf(\"\\t      Number of VMs: %d\\n\", host.getVmList().size());\n        }\n        System.out.printf(\"\\t      Working PEs: %d | VMs required PEs: %d\\n\", hostWorkingPes, vmsRequiredPes);\n        if(hostWorkingPes == 0){\n            setAllVmsToFailed();  \n        } else if (hostWorkingPes >= vmsRequiredPes) {\n            logNoVmFailure();  \n        } else {\n            deallocateFailedHostPesFromVms();\n        } \n        \n        return numberOfFailedPes > 0;\n    }", "LocalizedBug": "Log.printFormattedLine(\"\\t%.2f: Generated %d PEs failures for Host %d\", getSimulation().clock(), numberOfFailedPes, host.getId());\nSystem.out.printf(\"\\t      Number of VMs: %d\\n\", host.getId(), host.getVmList().size());", "LocalizedPatchLength": 219, "CodeLength": 901}
{"BuggyCode": "protected void processIsInJarAndlastModified() {\n\t\ttry {\n\t\t\tURLConnection conn = url.openConnection();\n\t\t\tif (\"jar\".equals(url.getProtocol()) || conn instanceof JarURLConnection) {\n\t\t\t\tisInJar = true;\n\t\t\t\tlastModified = -1;\n\t\t\t} else {\n\t\t\t\tisInJar = false;\n\t\t\t\tlastModified = conn.getLastModified();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 76 is not released after line 82."}, "FixedCode": "protected void processIsInJarAndlastModified() {\n\t\tif (\"file\".equalsIgnoreCase(url.getProtocol())) {\n\t\t\tisInJar = false;\n\t\t\tlastModified = new File(url.getFile()).lastModified();\n\t\t} else {\t\n\t\t\tisInJar = true;\n\t\t\tlastModified = -1;\n\t\t}\n\t}", "LocalizedBug": "try {\nURLConnection conn = url.openConnection();\nif (\"jar\".equals(url.getProtocol()) || conn instanceof JarURLConnection) {\n} else {\nisInJar = false;\nlastModified = conn.getLastModified();\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n}", "LocalizedPatchLength": 249, "CodeLength": 373}
{"BuggyCode": "@Override\n\tpublic Mono<Payload> requestResponse(Payload payload) {\n\t\tAtomicReference<Timer.Sample> timer = new AtomicReference<>();\n\t\tGatewayExchange exchange = GatewayExchange.fromPayload(REQUEST_RESPONSE, payload);\n\t\tTags tags = getTags(exchange);\n\t\treturn findRSocketOrCreatePending(exchange)\n\t\t\t\t.flatMap(rSocket -> rSocket.requestResponse(payload))\n\t\t\t\t.doOnSubscribe(s -> timer.set(Timer.start(meterRegistry)))\n\t\t\t\t.doOnError(t -> count(\"forward.request.response.error\", tags))\n\t\t\t\t.doFinally(s -> timer.get().stop(meterRegistry.timer(\"forward.request.response\", tags)));\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `exchange.routingMetadata` last assigned on line 138 could be null and is dereferenced by call to `getTags(...)` at line 139."}, "FixedCode": "@Override\n\tpublic Mono<Payload> requestResponse(Payload payload) {\n\t\tAtomicReference<Timer.Sample> timer = new AtomicReference<>();\n\t\tGatewayExchange exchange = createExchange(REQUEST_RESPONSE, payload);\n\t\treturn findRSocketOrCreatePending(exchange)\n\t\t\t\t.flatMap(rSocket -> rSocket.requestResponse(payload))\n\t\t\t\t.doOnSubscribe(s -> timer.set(Timer.start(meterRegistry)))\n\t\t\t\t.doOnError(t -> count(exchange, \"error\"))\n\t\t\t\t.doFinally(s -> timer.get().stop(meterRegistry.timer(getMetricName(exchange), exchange.getTags())));\n\t}", "LocalizedBug": "GatewayExchange exchange = GatewayExchange.fromPayload(REQUEST_RESPONSE, payload);\nTags tags = getTags(exchange);\n.doOnError(t -> count(\"forward.request.response.error\", tags))\n.doFinally(s -> timer.get().stop(meterRegistry.timer(\"forward.request.response\", tags)));", "LocalizedPatchLength": 266, "CodeLength": 580}
{"BuggyCode": "private static String ihVal(String key, Document doc) {\n        return doc.select(\"th:contains(\" + key + \") + td\").first().text();\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `doc.select(__new(java.lang.StringBuilder).append(\"th:contains(\").append(key).append(\") + td\").toString()).first()` could be null and is dereferenced at line 83."}, "FixedCode": "private static String ihVal(String key, Document doc) {\n        final Element first = doc.select(\"th:contains(\" + key + \") + td\").first();\n        return first != null ? first.text() : null;\n    }", "LocalizedBug": "return doc.select(\"th:contains(\" + key + \") + td\").first().text();", "LocalizedPatchLength": 66, "CodeLength": 136}
{"BuggyCode": "protected static void denormalizeX(Dataset data, Map<Object, Double> minColumnValues, Map<Object, Double> maxColumnValues) {\n        for(Integer rId : data) {\n            Record r = data.get(rId);\n            for(Object column : minColumnValues.keySet()) {\n                Double value = r.getX().getDouble(column);\n                if(value==null) { //if we have a missing value don't perform any denormalization\n                    continue;\n                }\n                \n                Double min = minColumnValues.get(column);\n                Double max = maxColumnValues.get(column);\n                \n                if(min.equals(max)) {\n                    r.getX().put(column, min);\n                }\n                else {\n                    r.getX().put(column, value*(max-min) + min);\n                }\n            }\n            \n            //do nothing for the response variable Y\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `r.getX()` could be null and is dereferenced at line 146."}, "FixedCode": "protected static void denormalizeX(Dataset data, Map<Object, Double> minColumnValues, Map<Object, Double> maxColumnValues) {\n        for(Integer rId : data) {\n            Record r = data.get(rId);\n            AssociativeArray xData = new AssociativeArray(r.getX());\n            \n            for(Object column : minColumnValues.keySet()) {\n                Double value = xData.getDouble(column);\n                if(value==null) { //if we have a missing value don't perform any denormalization\n                    continue;\n                }\n                \n                Double min = minColumnValues.get(column);\n                Double max = maxColumnValues.get(column);\n                \n                if(min.equals(max)) {\n                    xData.put(column, min);\n                }\n                else {\n                    xData.put(column, value*(max-min) + min);\n                }\n            }\n            \n            r = new Record(xData, r.getY(), r.getYPredicted(), r.getYPredictedProbabilities());\n            data.set(rId, r);\n        }\n    }", "LocalizedBug": "Double value = r.getX().getDouble(column);\nr.getX().put(column, min);\nr.getX().put(column, value*(max-min) + min);\n//do nothing for the response variable Y\n}\n}", "LocalizedPatchLength": 159, "CodeLength": 915}
{"BuggyCode": "public U fetchUser(@Valid @Email @NotNull String email) {\n\t\t\n\t\tSaUser loggedIn = SaUtil.getSessionUser();\n\n\t\tU user = userRepository.findByEmail(email);\n\t\t\n\t\tif (user == null) {\n\t\t\t////////////////// throw SaFormException\n\t\t}\n\n\t\tuser.setPassword(null);\n\t\t\n\t\tif (loggedIn == null ||\tloggedIn.getId() != user.getId() && !loggedIn.isAdmin())\n\t\t\t\tuser.setEmail(\"Confidential\");\n\t\t\n\t\treturn user;\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `user` last assigned on line 152 could be null and is dereferenced at line 158."}, "FixedCode": "public U fetchUser(@Valid @Email @NotNull String email) {\n\t\t\n\t\tSaUser loggedIn = SaUtil.getSessionUser();\n\n\t\tU user = userRepository.findByEmail(email);\n\t\t\n\t\tif (user == null) {\n\t\t\tthrow new FormException(\"email\", \"userNotFound\");\n\t\t}\n\n\t\tuser.setPassword(null);\n\t\t\n\t\tif (loggedIn == null ||\tloggedIn.getId() != user.getId() && !loggedIn.isAdmin())\n\t\t\t\tuser.setEmail(\"Confidential\");\n\t\t\n\t\treturn user;\n\t}", "LocalizedBug": "////////////////// throw SaFormException", "LocalizedPatchLength": 40, "CodeLength": 394}
{"BuggyCode": "<T extends GHMetaExamples.GHMetaExample> GHMetaExamples.GHMetaExample getMetaExample(Class<T> clazz)\n            throws IOException {\n        return retrieve().to(\"/meta\", clazz);\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.kohsuke.github.GitHub.getMetaExample` indirectly writes to field `n$28.org.kohsuke.github.GHRateLimit$Record.resetDate` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "GitHub(String apiUrl, String login, String oauthAccessToken, String jwtToken, String password,\n            HttpConnector connector, RateLimitHandler rateLimitHandler, AbuseLimitHandler abuseLimitHandler)\n            throws IOException {\n        if (apiUrl.endsWith(\"/\"))\n            apiUrl = apiUrl.substring(0, apiUrl.length() - 1); // normalize\n        this.apiUrl = apiUrl;\n        if (null != connector)\n            this.connector = connector;\n\n        if (oauthAccessToken != null) {\n            encodedAuthorization = \"token \" + oauthAccessToken;\n        } else {\n            if (jwtToken != null) {\n                encodedAuthorization = \"Bearer \" + jwtToken;\n            } else if (password != null) {\n                String authorization = (login + ':' + password);\n                String charsetName = Charsets.UTF_8.name();\n                encodedAuthorization = \"Basic \"\n                        + new String(Base64.encodeBase64(authorization.getBytes(charsetName)), charsetName);\n            } else {// anonymous access\n                encodedAuthorization = null;\n            }\n        }\n\n        users = new ConcurrentHashMap<String, GHUser>();\n        orgs = new ConcurrentHashMap<String, GHOrganization>();\n        this.rateLimitHandler = rateLimitHandler;\n        this.abuseLimitHandler = abuseLimitHandler;\n\n        if (login == null && encodedAuthorization != null && jwtToken == null)\n            login = getMyself().getLogin();\n        this.login = login;\n    }", "LocalizedBug": "<T extends GHMetaExamples.GHMetaExample> GHMetaExamples.GHMetaExample getMetaExample(Class<T> clazz)\nreturn retrieve().to(\"/meta\", clazz);\n}", "LocalizedPatchLength": 140, "CodeLength": 185}
{"BuggyCode": "public void onExternalViewChange(ExternalView externalView, IdealState idealState) {\n    try {\n      String resourceName = externalView.getId();\n      if (!_resourceMbeanMap.containsKey(resourceName)) {\n        synchronized (this) {\n          if (!_resourceMbeanMap.containsKey(resourceName)) {\n            ResourceMonitor bean = new ResourceMonitor(_clusterName, resourceName);\n            String beanName =\n                CLUSTER_DN_KEY + \"=\" + _clusterName + \",\" + RESOURCE_DN_KEY + \"=\" + resourceName;\n            register(bean, getObjectName(beanName));\n            _resourceMbeanMap.put(resourceName, bean);\n          }\n        }\n      }\n      _resourceMbeanMap.get(resourceName).updateExternalView(externalView, idealState);\n    } catch (Exception e) {\n      LOG.warn(e);\n    }\n  }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.apache.helix.monitoring.mbeans.ClusterStatusMonitor.onExternalViewChange` indirectly writes to field `n$70.org.apache.helix.monitoring.mbeans.ResourceMonitor._numOfPartitions` outside of synchronization.\n Reporting because this access may occur on a background thread.\n\nNote that the prefix path n$70 has been contaminated during the execution, so the reported race on n$70.org.apache.helix.monitoring.mbeans.ResourceMonitor._numOfPartitions might be a false positive."}, "FixedCode": "public void onExternalViewChange(ExternalView externalView, IdealState idealState) {\n    try {\n      String resourceName = externalView.getId();\n      if (!_resourceMbeanMap.containsKey(resourceName)) {\n        synchronized (this) {\n          if (!_resourceMbeanMap.containsKey(resourceName)) {\n            ResourceMonitor bean = new ResourceMonitor(_clusterName, resourceName);\n            bean.updateExternalView(externalView, idealState);\n            registerResources(Arrays.asList(bean));\n          }\n        }\n      }\n      ResourceMonitor bean = _resourceMbeanMap.get(resourceName);\n      String oldSensorName = bean.getSensorName();\n      bean.updateExternalView(externalView, idealState);\n      String newSensorName = bean.getSensorName();\n      if (!oldSensorName.equals(newSensorName)) {\n        unregisterResources(Arrays.asList(resourceName));\n        registerResources(Arrays.asList(bean));\n      }\n    } catch (Exception e) {\n      LOG.warn(e);\n    }\n  }", "LocalizedBug": "String beanName =\nCLUSTER_DN_KEY + \"=\" + _clusterName + \",\" + RESOURCE_DN_KEY + \"=\" + resourceName;\nregister(bean, getObjectName(beanName));\n_resourceMbeanMap.put(resourceName, bean);\n}\n}\n}\n_resourceMbeanMap.get(resourceName).updateExternalView(externalView, idealState);", "LocalizedPatchLength": 271, "CodeLength": 789}
{"BuggyCode": "@Override\n    public Future<JsonArray> groupAsync(final String sigma) {\n        /*\n         * Build condition of `sigma`\n         */\n        final JsonObject condition = new JsonObject();\n        condition.put(KeField.SIGMA, sigma);\n        /*\n         * Permission Groups processing\n         */\n        return Ux.Jooq.on(SPermissionDao.class)\n                .countByAsync(condition, \"group\", \"identifier\");\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `on(cn.vertxup.rbac.domain.tables.daos.SPermissionDao)` could be null and is dereferenced at line 37."}, "FixedCode": "@Override\n    public Future<JsonArray> groupAsync(final String sigma) {\n        /*\n         * Build condition of `sigma`\n         */\n        final JsonObject condition = new JsonObject();\n        condition.put(KeField.SIGMA, sigma);\n        /*\n         * Permission Groups processing\n         *\u300cUpgrade\u300d\n         * Old method because `GROUP` is in S_PERMISSION\n         * return Ux.Jooq.on(SPermissionDao.class).countByAsync(condition, \"group\", \"identifier\");\n         * New version: S_PERM_SET processing\n         */\n        return Ux.Jooq.on(SPermSetDao.class).fetchJAsync(condition);\n    }", "LocalizedBug": "*/", "LocalizedPatchLength": 2, "CodeLength": 414}
{"BuggyCode": "private byte[] processDatabaseEncryption(boolean encrypt, byte[] database, KeePassHeader header, byte[] aesKey)\n\t\t\tthrows IOException {\n\t\tbyte[] metaData = new byte[KeePassHeader.VERSION_SIGNATURE_LENGTH + header.getHeaderSize()];\n\t\tBufferedInputStream bufferedInputStream = new BufferedInputStream(new ByteArrayInputStream(database));\n\t\tbufferedInputStream.read(metaData);\n\n\t\tbyte[] payload = StreamUtils.toByteArray(bufferedInputStream);\n\t\tbyte[] processedPayload;\n\t\tif (encrypt) {\n\t\t\tprocessedPayload = Aes.encrypt(aesKey, header.getEncryptionIV(), payload);\n\t\t} else {\n\t\t\tprocessedPayload = Aes.decrypt(aesKey, header.getEncryptionIV(), payload);\n\t\t}\n\n\t\tByteArrayOutputStream output = new ByteArrayOutputStream();\n\t\toutput.write(metaData);\n\t\toutput.write(processedPayload);\n\n\t\treturn output.toByteArray();\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.BufferedInputStream` acquired to `bufferedInputStream` by call to `new()` at line 28 is not released after line 31."}, "FixedCode": "private byte[] processDatabaseEncryption(boolean encrypt, byte[] database, KeePassHeader header, byte[] aesKey)\n\t\t\tthrows IOException {\n\t\tbyte[] metaData = new byte[KeePassHeader.VERSION_SIGNATURE_LENGTH + header.getHeaderSize()];\n\t\tSafeInputStream inputStream = new SafeInputStream(new BufferedInputStream(new ByteArrayInputStream(database)));\n\t\tinputStream.readSafe(metaData);\n\n\t\tbyte[] payload = StreamUtils.toByteArray(inputStream);\n\t\tbyte[] processedPayload;\n\t\tif (encrypt) {\n\t\t\tprocessedPayload = Aes.encrypt(aesKey, header.getEncryptionIV(), payload);\n\t\t} else {\n\t\t\tprocessedPayload = Aes.decrypt(aesKey, header.getEncryptionIV(), payload);\n\t\t}\n\n\t\tByteArrayOutputStream output = new ByteArrayOutputStream();\n\t\toutput.write(metaData);\n\t\toutput.write(processedPayload);\n\n\t\treturn output.toByteArray();\n\t}", "LocalizedBug": "BufferedInputStream bufferedInputStream = new BufferedInputStream(new ByteArrayInputStream(database));\nbufferedInputStream.read(metaData);\nbyte[] payload = StreamUtils.toByteArray(bufferedInputStream);", "LocalizedPatchLength": 201, "CodeLength": 812}
{"BuggyCode": "public void runTestDataStream(){\n    final int bufferSize = 1024*1024;\n    final int bufferNum = 10;\n    final DataStreamOutput out = client.stream();\n\n    //send request\n    final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n    futures.add(sendRequest(out, 1024));\n\n    //send data\n    final int halfBufferSize = bufferSize/2;\n    int dataSize = 0;\n    for(int i = 0; i < bufferNum; i++) {\n      final int size = halfBufferSize + ThreadLocalRandom.current().nextInt(halfBufferSize);\n      final ByteBuffer bf = initBuffer(dataSize, size);\n      futures.add(out.streamAsync(bf));\n      dataSize += size;\n    }\n\n    //join all requests\n    for(CompletableFuture<DataStreamReply> f : futures) {\n      f.join();\n    }\n    Assert.assertEquals(dataSize, byteWritten);\n    shutDownSetup();\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.ratis.client.impl.DataStreamClientImpl$DataStreamOutputImpl` acquired by call to `stream()` at line 140 is not released after line 157."}, "FixedCode": "public void runTestDataStream(){\n    final int bufferSize = 1024*1024;\n    final int bufferNum = 10;\n    final DataStreamOutput out = client.stream();\n    DataStreamClientImpl.DataStreamOutputImpl impl = (DataStreamClientImpl.DataStreamOutputImpl) out;\n\n    final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n\n    // add header\n    futures.add(impl.getHeaderFuture());\n\n    //send data\n    final int halfBufferSize = bufferSize/2;\n    int dataSize = 0;\n    for(int i = 0; i < bufferNum; i++) {\n      final int size = halfBufferSize + ThreadLocalRandom.current().nextInt(halfBufferSize);\n      final ByteBuffer bf = initBuffer(dataSize, size);\n      futures.add(out.writeAsync(bf));\n      dataSize += size;\n    }\n\n    //join all requests\n    for(CompletableFuture<DataStreamReply> f : futures) {\n      f.join();\n    }\n\n    Assert.assertEquals(writeRequest.getClientId(), impl.getHeader().getClientId());\n    Assert.assertEquals(writeRequest.getCallId(), impl.getHeader().getCallId());\n    Assert.assertEquals(writeRequest.getRaftGroupId(), impl.getHeader().getRaftGroupId());\n    Assert.assertEquals(writeRequest.getServerId(), impl.getHeader().getServerId());\n\n    Assert.assertEquals(dataSize, byteWritten);\n    shutDownSetup();\n  }", "LocalizedBug": "//send request\nfutures.add(sendRequest(out, 1024));\nfutures.add(out.streamAsync(bf));", "LocalizedPatchLength": 85, "CodeLength": 813}
{"BuggyCode": "protected void fireInstancesRemoved(int... instanceIds) {\n        if (listener != null) {\n            listener.objectInstancesRemoved(this, instanceIds);\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.eclipse.leshan.client.resource.BaseObjectEnabler.fireInstancesRemoved` indirectly reads without synchronization from `this.org.eclipse.leshan.client.resource.BaseObjectEnabler.listener.org.eclipse.leshan.client.resource.TransactionalObjectListener.inTransaction`. Potentially races with write in method `BaseObjectEnabler.write(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "protected void fireInstancesRemoved(int... instanceIds) {\n        transactionalListener.objectInstancesRemoved(this, instanceIds);\n    }", "LocalizedBug": "if (listener != null) {\nlistener.objectInstancesRemoved(this, instanceIds);\n}", "LocalizedPatchLength": 77, "CodeLength": 169}
{"BuggyCode": "@Override\n\tpublic int getNumberOfFeatures(){\n\t\tList<?> coefs = getCoefs();\n\n\t\tNDArray input = (NDArray)coefs.get(0);\n\n\t\tint[] shape = NDArrayUtil.getShape(input);\n\n\t\treturn shape[0];\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `coefs` last assigned on line 38 could be null and is dereferenced at line 40."}, "FixedCode": "@Override\n\tpublic int getNumberOfFeatures(){\n\t\tList<? extends HasArray> coefs = getCoefs();\n\n\t\treturn NeuralNetworkUtil.getNumberOfFeatures(coefs);\n\t}", "LocalizedBug": "NDArray input = (NDArray)coefs.get(0);\nint[] shape = NDArrayUtil.getShape(input);\nreturn shape[0];", "LocalizedPatchLength": 98, "CodeLength": 185}
{"BuggyCode": "long freeCapacity()\n    {\n        return freeCapacity;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.caffinitas.ohc.linked.OffHeapMap.freeCapacity` reads without synchronization from `this.org.caffinitas.ohc.linked.OffHeapMap.freeCapacity`. Potentially races with write in method `OffHeapMap.updateFreeCapacity(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, long freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        this.throwOOME = builder.isThrowOOME();\n\n        this.lock = builder.isUnlocked() ? null : new ReentrantLock();\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        table = Table.create((int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE), throwOOME);\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "{\nreturn freeCapacity;", "LocalizedPatchLength": 22, "CodeLength": 60}
{"BuggyCode": "float negativeSampling(int target, float lr) {\n        float loss = 0.0f;\n        grad_.zero();\n        for (int n = 0; n <= args_.neg; n++) {\n            if (n == 0) {\n                loss += binaryLogistic(target, true, lr);\n            } else {\n                loss += binaryLogistic(getNegative(target), false, lr);\n            }\n        }\n        return loss;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `zemberek.embedding.fasttext.Model.negativeSampling` indirectly writes to field `this.zemberek.embedding.fasttext.Model.grad_.zemberek.embedding.fasttext.Vector.data_.[_]` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "Model(Matrix wi,\n          Matrix wo,\n          Args args,\n          int seed) {\n        hidden_ = new Vector(args.dim);\n        output_ = new Vector(wo.m_);\n        grad_ = new Vector(args.dim);\n        random = new Random(seed);\n        wi_ = wi;\n        wo_ = wo;\n        args_ = args;\n        isz_ = wi.m_;\n        osz_ = wo.m_;\n        hsz_ = args.dim;\n        negpos = 0;\n        loss_ = 0.0f;\n        nexamples_ = 1;\n    }", "LocalizedBug": "float negativeSampling(int target, float lr) {\nfloat loss = 0.0f;\ngrad_.zero();\nfor (int n = 0; n <= args_.neg; n++) {\nif (n == 0) {\nloss += binaryLogistic(target, true, lr);\n} else {\nloss += binaryLogistic(getNegative(target), false, lr);\n}\n}\nreturn loss;\n}", "LocalizedPatchLength": 258, "CodeLength": 370}
{"BuggyCode": "public Index read() throws IOException {\n        PackedDataInputStream stream = new PackedDataInputStream(new BufferedInputStream(input));\n        if (stream.readInt() != MAGIC) {\n            stream.close();\n            throw new IllegalArgumentException(\"Not a jandex index\");\n        }\n        byte version = stream.readByte();\n\n        IndexReaderImpl reader = getReader(stream, version);\n        if (reader == null) {\n            stream.close();\n            throw new UnsupportedVersion(\"Version: \" + version);\n        }\n\n        return reader.read(version);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.jboss.jandex.PackedDataInputStream` acquired by call to `PackedDataInputStream(...)` at line 71 is not released after line 84."}, "FixedCode": "public Index read() throws IOException {\n        if(version == -1) {\n            readVersion();\n        }\n        IndexReaderImpl reader = getReader(input, version);\n        if (reader == null) {\n            input.close();\n            throw new UnsupportedVersion(\"Version: \" + version);\n        }\n        return reader.read(version);\n    }", "LocalizedBug": "PackedDataInputStream stream = new PackedDataInputStream(new BufferedInputStream(input));\nif (stream.readInt() != MAGIC) {\nstream.close();\nthrow new IllegalArgumentException(\"Not a jandex index\");\nbyte version = stream.readByte();\nIndexReaderImpl reader = getReader(stream, version);\nstream.close();", "LocalizedPatchLength": 299, "CodeLength": 568}
{"BuggyCode": "public CodeGenerator newCodeGenerator(AviatorClassLoader classLoader) {\n    switch (getOptimizeLevel()) {\n      case AviatorEvaluator.COMPILE:\n        ASMCodeGenerator asmCodeGenerator = new ASMCodeGenerator(this, classLoader,\n            traceOutputStream, (Boolean) getOption(Options.TRACE));\n        asmCodeGenerator.start();\n        return asmCodeGenerator;\n      case AviatorEvaluator.EVAL:\n        return new OptimizeCodeGenerator(this, classLoader, traceOutputStream,\n            (Boolean) getOption(Options.TRACE));\n      default:\n        throw new IllegalArgumentException(\"Unknow option \" + getOptimizeLevel());\n    }\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getOption(com.googlecode.aviator.Options.TRACE)` could be null and is dereferenced at line 646."}, "FixedCode": "public CodeGenerator newCodeGenerator(AviatorClassLoader classLoader) {\n    switch (getOptimizeLevel()) {\n      case AviatorEvaluator.COMPILE:\n        ASMCodeGenerator asmCodeGenerator = new ASMCodeGenerator(this, classLoader,\n            traceOutputStream, getOptionValue(Options.TRACE).bool);\n        asmCodeGenerator.start();\n        return asmCodeGenerator;\n      case AviatorEvaluator.EVAL:\n        return new OptimizeCodeGenerator(this, classLoader, traceOutputStream,\n            getOptionValue(Options.TRACE).bool);\n      default:\n        throw new IllegalArgumentException(\"Unknow option \" + getOptimizeLevel());\n    }\n  }", "LocalizedBug": "traceOutputStream, (Boolean) getOption(Options.TRACE));\n(Boolean) getOption(Options.TRACE));", "LocalizedPatchLength": 92, "CodeLength": 631}
{"BuggyCode": "@Parameterized.Parameters\n    public static Collection<String> parametricTest() throws IOException {\n\n        FileReader file = new FileReader(relativePath + timeCategory + listFileName);\n        BufferedReader br = new BufferedReader(file);\n        String line = \"\";\n        List<String> list = new ArrayList<String>();\n        int i = 0;\n        while ((line = br.readLine())!=null) {\n            list.add(i, line);\n            i++;\n        }\n        return list;\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileReader` acquired by call to `new()` at line 48 is not released after line 57.\n**Note**: potential exception at line 53"}, "FixedCode": "@Parameterized.Parameters\n    public static Collection<String> parametricTest() throws IOException {\n\n\n        return fileReader(timeCategory);\n    }", "LocalizedBug": "FileReader file = new FileReader(relativePath + timeCategory + listFileName);\nBufferedReader br = new BufferedReader(file);\nString line = \"\";\nList<String> list = new ArrayList<String>();\nint i = 0;\nwhile ((line = br.readLine())!=null) {\nlist.add(i, line);\ni++;\nreturn list;\n}", "LocalizedPatchLength": 275, "CodeLength": 471}
{"BuggyCode": "@Override\n    public long appendMessage(MimeMessage message,\n                              Flags flags,\n                              Date receivedDate) {\n        long uid = nextUid;\n        nextUid++;\n\n        try {\n            message.setFlags(flags, true);\n            message.setFlag(Flags.Flag.RECENT, true);\n        } catch (MessagingException e) {\n            throw new IllegalStateException(\"Can not set flags\", e);\n        }\n        StoredMessage storedMessage = new StoredMessage(message,\n                receivedDate, uid);\n\n        int newMsn;\n        synchronized (mailMessages) {\n            mailMessages.add(storedMessage);\n            newMsn = mailMessages.size();\n        }\n\n        // Notify all the listeners of the new message\n        synchronized (_mailboxListeners) {\n            for (FolderListener _mailboxListener : _mailboxListeners) {\n                _mailboxListener.added(newMsn);\n            }\n        }\n\n        return uid;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `com.icegreen.greenmail.store.HierarchicalFolder.appendMessage` writes to field `this.com.icegreen.greenmail.store.HierarchicalFolder.nextUid` outside of synchronization.\n Reporting because this access may occur on a background thread."}, "FixedCode": "@Override\n    public long appendMessage(MimeMessage message,\n                              Flags flags,\n                              Date receivedDate) {\n        final long uid = nextUid.getAndIncrement();\n\n        try {\n            message.setFlags(flags, true);\n            message.setFlag(Flags.Flag.RECENT, true);\n        } catch (MessagingException e) {\n            throw new IllegalStateException(\"Can not set flags\", e);\n        }\n        StoredMessage storedMessage = new StoredMessage(message,\n                receivedDate, uid);\n\n        int newMsn;\n        synchronized (mailMessages) {\n            mailMessages.add(storedMessage);\n            newMsn = mailMessages.size();\n        }\n\n        // Notify all the listeners of the new message\n        synchronized (_mailboxListeners) {\n            for (FolderListener _mailboxListener : _mailboxListeners) {\n                _mailboxListener.added(newMsn);\n            }\n        }\n\n        return uid;\n    }", "LocalizedBug": "long uid = nextUid;\nnextUid++;", "LocalizedPatchLength": 30, "CodeLength": 960}
{"BuggyCode": "public void stop() {\n        if (clientThread != null) {\n            clientThread.interrupt();\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.yahoo.omid.notifications.client.NotificationDispatcher.stop` reads without synchronization from `this.com.yahoo.omid.notifications.client.NotificationDispatcher.clientThread`. Potentially races with write in method `NotificationDispatcher.serverStarted(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public void stop() {\n        for (NotificationClient client : clients.values()) {\n            client.stop();\n        }\n    }", "LocalizedBug": "if (clientThread != null) {\nclientThread.interrupt();", "LocalizedPatchLength": 53, "CodeLength": 110}
{"BuggyCode": "@Override\n  public void onPageLoad() {\n    System.err.println(\"new page loaded\");\n    pageLoaded = true;\n    reset();\n    try {\n      Thread.sleep(5000);\n      System.out.println(\n          \"on page load:\" + session.getWebInspector().getProtocol().sendCommand(DOM.getDocument())\n              .optJSONObject(\"root\").optString(\"documentURL\"));\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.uiautomation.ios.server.DOMContext.onPageLoad` indirectly writes to field `n$6.org.uiautomation.ios.mobileSafari.DebugProtocol.commandId` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not.\n\nNote that the prefix path n$6 has been contaminated during the execution, so the reported race on n$6.org.uiautomation.ios.mobileSafari.DebugProtocol.commandId might be a false positive."}, "FixedCode": "@Override\n  public void onPageLoad() {\n    pageLoaded = true;\n    reset();\n  }", "LocalizedBug": "System.err.println(\"new page loaded\");\ntry {\nThread.sleep(5000);\nSystem.out.println(\n\"on page load:\" + session.getWebInspector().getProtocol().sendCommand(DOM.getDocument())\n.optJSONObject(\"root\").optString(\"documentURL\"));\n} catch (Exception e) {\ne.printStackTrace();\n}\n}", "LocalizedPatchLength": 272, "CodeLength": 407}
{"BuggyCode": "public void await(long timeout, TimeUnit unit, boolean cancelOnTimeout) throws InterruptedException, TimeoutException {\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\t\twhile (!isDone() && System.currentTimeMillis() < end) {\n\t\t\tsynchronized (signal) {\n\t\t\t\tsignal.wait(end - System.currentTimeMillis());\n\t\t\t}\n\t\t}\n\t\tif (!isDone()) {\n\t\t\tif (cancelOnTimeout) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t\tthrow new TimeoutException();\n\t\t}\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `net.rithms.riot.api.request.AsyncRequest.await` indirectly reads without synchronization from `this.net.rithms.riot.api.request.Request.state`. Potentially races with write in method `AsyncRequest.setState(...)`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public void await(long timeout, TimeUnit unit, boolean cancelOnTimeout) throws InterruptedException, TimeoutException {\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\t\tif (!isDone() && System.currentTimeMillis() < end) {\n\t\t\tsynchronized (signal) {\n\t\t\t\twhile (!isDone() && System.currentTimeMillis() < end) {\n\t\t\t\t\tsignal.wait(end - System.currentTimeMillis());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!isDone()) {\n\t\t\tif (cancelOnTimeout) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t\tthrow new TimeoutException();\n\t\t}\n\t}", "LocalizedBug": "while (!isDone() && System.currentTimeMillis() < end) {", "LocalizedPatchLength": 55, "CodeLength": 440}
{"BuggyCode": "@Test\n    public void testTransactedReturnGeneratedKeys2() {\n        Database db = db();\n        // note is a table with auto increment\n        Flowable<Integer> a = db.update(\"insert into note(text) values(?)\") //\n                .parameters(\"HI\", \"THERE\") //\n                .transacted() //\n                .returnGeneratedKeys() //\n                .valuesOnly() //\n                .getAs(Integer.class);\n\n        db.update(\"insert into note(text) values(?)\") //\n                .parameters(\"ME\", \"TOO\") //\n                .transacted() //\n                .returnGeneratedKeys() //\n                .valuesOnly() //\n                .getAs(Integer.class)//\n                .startWith(a) //\n                .test() //\n                .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS) //\n                .assertValues(1, 2, 3, 4) //\n                .assertComplete();\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.davidmoten.rx.jdbc.Database` acquired by call to `db()` at line 1364 is not released after line 1374."}, "FixedCode": "@Test\n    public void testTransactedReturnGeneratedKeys2() {\n        try (Database db = db()) {\n            // note is a table with auto increment\n            Flowable<Integer> a = db.update(\"insert into note(text) values(?)\") //\n                    .parameters(\"HI\", \"THERE\") //\n                    .transacted() //\n                    .returnGeneratedKeys() //\n                    .valuesOnly() //\n                    .getAs(Integer.class);\n\n            db.update(\"insert into note(text) values(?)\") //\n                    .parameters(\"ME\", \"TOO\") //\n                    .transacted() //\n                    .returnGeneratedKeys() //\n                    .valuesOnly() //\n                    .getAs(Integer.class)//\n                    .startWith(a) //\n                    .test() //\n                    .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS) //\n                    .assertValues(1, 2, 3, 4) //\n                    .assertComplete();\n        }\n    }", "LocalizedBug": "Database db = db();", "LocalizedPatchLength": 19, "CodeLength": 868}
{"BuggyCode": "public void testCpioUnarchive() throws Exception {\n\t\tfinal File output = new File(dir, \"bla.cpio\");\n\t\t{\n\t\t\tfinal File file1 = getFile(\"test1.xml\");\n\t\t\tfinal File file2 = getFile(\"test2.xml\");\n\t\t\t\n\t\t\tfinal OutputStream out = new FileOutputStream(output);\n\t        final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n\t\t\tos.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n\t\t\tIOUtils.copy(new FileInputStream(file1), os);\n\t\t\tos.closeArchiveEntry();\n\t\t\t\n\t\t\tos.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n\t\t\tIOUtils.copy(new FileInputStream(file2), os);\n\t\t\tos.closeArchiveEntry();\n\t\t\tos.close();\n\t\t}\n\t\t\n\t\t// Unarchive Operation\n\t\tfinal File input = output;\n\t\tfinal InputStream is = new FileInputStream(input);\n\t\tfinal ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n\t\tfinal CpioArchiveEntry entry = (CpioArchiveEntry)in.getNextEntry();\n\t\t\n\t\tFile target = new File(dir, entry.getName());\n        final OutputStream out = new FileOutputStream(target);\n        \n        IOUtils.copy(in, out);\n    \n        out.close();\n        in.close();\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.commons.compress.archivers.ar.ArArchiveInputStream` acquired by call to `createArchiveInputStream(...)` at line 73 is not released after line 83.\n**Note**: potential exception at line 79"}, "FixedCode": "public void testCpioUnarchive() throws Exception {\n        final File output = new File(dir, \"bla.cpio\");\n        {\n            final File file1 = getFile(\"test1.xml\");\n            final File file2 = getFile(\"test2.xml\");\n\n            final OutputStream out = new FileOutputStream(output);\n            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n            os.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n            IOUtils.copy(new FileInputStream(file1), os);\n            os.closeArchiveEntry();\n\n            os.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n            IOUtils.copy(new FileInputStream(file2), os);\n            os.closeArchiveEntry();\n\n            os.close();\n            out.close();\n        }\n\n        // Unarchive Operation\n        final File input = output;\n        final InputStream is = new FileInputStream(input);\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n\n\n        Map result = new HashMap();\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            File target = new File(dir, entry.getName());\n            final OutputStream out = new FileOutputStream(target);\n            IOUtils.copy(in, out);\n            out.close();\n            result.put(entry.getName(), target);\n        }\n        in.close();\n\n        int lineSepLength = System.getProperty(\"line.separator\").length();\n\n        File t = (File)result.get(\"test1.xml\");\n        assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n        assertEquals(\"length of \" + t.getAbsolutePath(),\n                     72 + 4 * lineSepLength, t.length());\n\n        t = (File)result.get(\"test2.xml\");\n        assertTrue(\"Expected \" + t.getAbsolutePath() + \" to exist\", t.exists());\n        assertEquals(\"length of \" + t.getAbsolutePath(),\n                     73 + 5 * lineSepLength, t.length());\n    }", "LocalizedBug": "final CpioArchiveEntry entry = (CpioArchiveEntry)in.getNextEntry();", "LocalizedPatchLength": 67, "CodeLength": 1163}
{"BuggyCode": "public static boolean execute(final File source, final File destination, final boolean deleteSource, final int level)\n        throws IOException {\n        if (source.exists()) {\n            final FileInputStream fis = new FileInputStream(source);\n            final FileOutputStream fos = new FileOutputStream(destination);\n            final ZipOutputStream zos = new ZipOutputStream(fos);\n            zos.setLevel(level);\n\n            final ZipEntry zipEntry = new ZipEntry(source.getName());\n            zos.putNextEntry(zipEntry);\n\n            final byte[] inbuf = new byte[BUF_SIZE];\n            int n;\n\n            while ((n = fis.read(inbuf)) != -1) {\n                zos.write(inbuf, 0, n);\n            }\n\n            zos.close();\n            fis.close();\n\n            if (deleteSource && !source.delete()) {\n                LOGGER.warn(\"Unable to delete \" + source.toString() + '.');\n            }\n\n            return true;\n        }\n\n        return false;\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileInputStream` acquired to `fis` by call to `FileInputStream(...)` at line 103 is not released after line 128.\n**Note**: potential exception at line 104"}, "FixedCode": "public static boolean execute(final File source, final File destination, final boolean deleteSource, final int level)\n            throws IOException {\n        if (source.exists()) {\n            try (final FileInputStream fis = new FileInputStream(source);\n                    final ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(destination))) {\n                zos.setLevel(level);\n\n                final ZipEntry zipEntry = new ZipEntry(source.getName());\n                zos.putNextEntry(zipEntry);\n\n                final byte[] inbuf = new byte[BUF_SIZE];\n                int n;\n\n                while ((n = fis.read(inbuf)) != -1) {\n                    zos.write(inbuf, 0, n);\n                }\n            }\n\n            if (deleteSource && !source.delete()) {\n                LOGGER.warn(\"Unable to delete \" + source.toString() + '.');\n            }\n\n            return true;\n        }\n\n        return false;\n    }", "LocalizedBug": "final FileOutputStream fos = new FileOutputStream(destination);\nfinal ZipOutputStream zos = new ZipOutputStream(fos);\nzos.close();\nfis.close();", "LocalizedPatchLength": 143, "CodeLength": 969}
{"BuggyCode": "@Test\n  public void testStartupArgsWithoutUrl() {\n    try {\n      SqlLine sqlLine = new SqlLine();\n      ByteArrayOutputStream os = new ByteArrayOutputStream();\n      PrintStream sqllineOutputStream =\n          new PrintStream(os, false, StandardCharsets.UTF_8.name());\n      sqlLine.setOutputStream(sqllineOutputStream);\n      sqlLine.setErrorStream(sqllineOutputStream);\n      String[] args = {\n          \"-d\",\n          \"org.hsqldb.jdbcDriver\",\n          \"-n\",\n          \"SCOTT\",\n          \"-p\",\n          \"TIGER\"\n      };\n      DispatchCallback callback = new DispatchCallback();\n      sqlLine.initArgs(args, callback);\n      assertThat(os.toString(\"UTF8\"), containsString(sqlLine.loc(\"no-url\")));\n    } catch (Throwable e) {\n      // fail\n      throw new RuntimeException(e);\n    }\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.PrintStream` acquired by call to `setOutputStream(...)` at line 2418 is not released after line 2430."}, "FixedCode": "@Test\n  public void testStartupArgsWithoutUrl() {\n    try {\n      ByteArrayOutputStream os = new ByteArrayOutputStream();\n      PrintStream sqllineOutputStream =\n          new PrintStream(os, false, StandardCharsets.UTF_8.name());\n      sqlLine.setOutputStream(sqllineOutputStream);\n      sqlLine.setErrorStream(sqllineOutputStream);\n      String[] args = {\n          \"-d\",\n          \"org.hsqldb.jdbcDriver\",\n          \"-n\",\n          \"SCOTT\",\n          \"-p\",\n          \"TIGER\"\n      };\n      DispatchCallback callback = new DispatchCallback();\n      sqlLine.initArgs(args, callback);\n      assertThat(os.toString(\"UTF8\"), containsString(sqlLine.loc(\"no-url\")));\n    } catch (Throwable e) {\n      // fail\n      throw new RuntimeException(e);\n    }\n  }", "LocalizedBug": "SqlLine sqlLine = new SqlLine();", "LocalizedPatchLength": 32, "CodeLength": 790}
{"BuggyCode": "private void importNodeIndexes(File file, String indexName, String indexType) throws IOException {\n    \tBatchInserterIndex index;\n    \tif (indexType.equals(\"fulltext\")) {\n    \t\tindex = lucene.nodeIndex( indexName, stringMap( \"type\", \"fulltext\" ) );\n    \t} else {\n    \t\tindex = lucene.nodeIndex( indexName, EXACT_CONFIG );\n    \t}\n        \n        BufferedReader bf = new BufferedReader(new FileReader(file));\n        \n        final Data data = new Data(bf.readLine(), \"\\t\", 1);\n        Object[] node = new Object[1];\n        String line;\n        report.reset();\n        while ((line = bf.readLine()) != null) {        \n            final Map<String, Object> properties = map(data.update(line, node));\n            index.add(id(node[0]), properties);\n            report.dots();\n        }\n                \n        report.finishImport(\"Nodes into \" + indexName + \" Index\");\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileReader` acquired by call to `new()` at line 194 is not released after line 207.\n**Note**: potential exception at line 200"}, "FixedCode": "private void importNodeIndexes(File file, String indexName, String indexType) throws IOException {\n    \tBatchInserterIndex index;\n    \tif (indexType.equals(\"fulltext\")) {\n    \t\tindex = lucene.nodeIndex( indexName, FULLTEXT_CONFIG );\n    \t} else {\n    \t\tindex = lucene.nodeIndex( indexName, EXACT_CONFIG );\n    \t}\n        \n        BufferedReader bf = new BufferedReader(new FileReader(file));\n        \n        final Data data = new Data(bf.readLine(), \"\\t\", 1);\n        Object[] node = new Object[1];\n        String line;\n        report.reset();\n        while ((line = bf.readLine()) != null) {        \n            final Map<String, Object> properties = data.update(line, node);\n            index.add(id(node[0]), properties);\n            report.dots();\n        }\n                \n        report.finishImport(\"Nodes into \" + indexName + \" Index\");\n    }", "LocalizedBug": "index = lucene.nodeIndex( indexName, stringMap( \"type\", \"fulltext\" ) );\nfinal Map<String, Object> properties = map(data.update(line, node));", "LocalizedPatchLength": 140, "CodeLength": 873}
{"BuggyCode": "void resetStatistics()\n    {\n        rehashes = 0L;\n        evictedEntries = 0L;\n        hitCount = 0L;\n        missCount = 0L;\n        putAddCount = 0L;\n        putReplaceCount = 0L;\n        removeCount = 0L;\n        lruCompactions = 0L;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.caffinitas.ohc.tables.OffHeapMap.resetStatistics` writes to field `this.org.caffinitas.ohc.tables.OffHeapMap.putAddCount` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, AtomicLong freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        int bl = builder.getBucketLength();\n        if (bl <= 0)\n            bl = 8;\n        int buckets = (int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE);\n        entriesPerBucket = (int) Util.roundUpToPowerOf2(bl, MAX_TABLE_SIZE);\n        table = Table.create(buckets, entriesPerBucket);\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        if (lf >= 1d)\n            throw new IllegalArgumentException(\"load factor must not be greater that 1\");\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "void resetStatistics()\n{\nrehashes = 0L;\nevictedEntries = 0L;\nhitCount = 0L;\nmissCount = 0L;\nputAddCount = 0L;\nputReplaceCount = 0L;\nremoveCount = 0L;\nlruCompactions = 0L;", "LocalizedPatchLength": 170, "CodeLength": 244}
{"BuggyCode": "public void disconnect() {\n        if (rawConnection != null && rawConnection.isConnected()) {\n            rawConnection.close();\n        }\n\n        if (bcmConnection != null && bcmConnection.isConnected()) {\n            bcmConnection.close();\n        }\n\n        url = null;\n\n        notifyListenersConnection();\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `com.github.kayak.core.Bus.disconnect` writes to field `this.com.github.kayak.core.Bus.url` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public void disconnect() {\n        if (rawConnection != null && rawConnection.isConnected()) {\n            rawConnection.close();\n        }\n\n        if (bcmConnection != null && bcmConnection.isConnected()) {\n            bcmConnection.close();\n        }\n\n        notifyListenersConnection();\n    }", "LocalizedBug": "url = null;", "LocalizedPatchLength": 11, "CodeLength": 318}
{"BuggyCode": "private static File getJarDirectory() {\n        String[] classPath = System.getProperty(\"java.class.path\").split(\";\");\n        return classPath.length > 1 ? new File(System.getProperty(\"user.dir\")) : new File(classPath[0]).getParentFile();\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getProperty(\"java.class.path\")` could be null and is dereferenced at line 225."}, "FixedCode": "private static File getJarDirectory() {\n        return Utils.class.getResource(\"/rip.properties\").toString().contains(\"jar:\") ? new File(System.getProperty(\"java.class.path\")).getParentFile() : new File(System.getProperty(\"user.dir\"));\n    }", "LocalizedBug": "String[] classPath = System.getProperty(\"java.class.path\").split(\";\");\nreturn classPath.length > 1 ? new File(System.getProperty(\"user.dir\")) : new File(classPath[0]).getParentFile();", "LocalizedPatchLength": 183, "CodeLength": 245}
{"BuggyCode": "@Benchmark\n    public void fastjson() {\n        JSONScanner scanner = new JSONScanner(JsoniterBenchmarkState.inputString);\n        scanner.nextToken();\n        do {\n            scanner.nextToken();\n            scanner.intValue();\n            scanner.nextToken();\n        } while (scanner.token() == JSONToken.COMMA);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.alibaba.fastjson.parser.JSONScanner` acquired by call to `new()` at line 18 is not released after line 25."}, "FixedCode": "@Benchmark\n    public void fastjson() {\n        JSON.parseObject(JsoniterBenchmarkState.inputString, byte[].class);\n    }", "LocalizedBug": "JSONScanner scanner = new JSONScanner(JsoniterBenchmarkState.inputString);\nscanner.nextToken();\ndo {\nscanner.nextToken();\nscanner.intValue();\nscanner.nextToken();\n} while (scanner.token() == JSONToken.COMMA);\n}", "LocalizedPatchLength": 210, "CodeLength": 322}
{"BuggyCode": "public void downloadProblem(URL url, String message) {\n        if (observer == null) {\n            return;\n        }\n        synchronized(observer) {\n            itemsPending.remove(url);\n            itemsErrored.put(url, message);\n            observer.update(this, new RipStatusMessage(STATUS.DOWNLOAD_WARN, url + \" : \" + message));\n            observer.notifyAll();\n        }\n        checkIfComplete();\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.rarchives.ripme.ripper.AbstractRipper.downloadProblem` indirectly reads without synchronization from `this.com.rarchives.ripme.ripper.AbstractRipper.observer`. Potentially races with write in method `AbstractRipper.setObserver(...)`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public void downloadProblem(URL url, String message) {\n        if (observer == null) {\n            return;\n        }\n        \n        itemsPending.remove(url);\n        itemsErrored.put(url, message);\n        observer.update(this, new RipStatusMessage(STATUS.DOWNLOAD_WARN, url + \" : \" + message));\n            \n        \n        checkIfComplete();\n    }", "LocalizedBug": "synchronized(observer) {\nobserver.notifyAll();\n}", "LocalizedPatchLength": 48, "CodeLength": 410}
{"BuggyCode": "@Before\n  public void setup() throws DBException {\n    orientDBClient = new OrientDBClient();\n\n    Properties p = new Properties();\n    // TODO: Extract the property names into final variables in OrientDBClient\n    p.setProperty(\"orientdb.url\", TEST_DB_URL);\n\n    orientDBClient.setProperties(p);\n    orientDBClient.init();\n    orientDBConnection = new ODatabaseDocumentTx(TEST_DB_URL).open(\"admin\",\"admin\");\n    orientDBDictionary = orientDBConnection.getMetadata().getIndexManager().getDictionary();\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx` acquired by call to `new()` at line 59 is not released after line 59."}, "FixedCode": "@Before\n  public void setup() throws DBException {\n    orientDBClient = new OrientDBClient();\n\n    Properties p = new Properties();\n    // TODO: Extract the property names into final variables in OrientDBClient\n    p.setProperty(\"orientdb.url\", TEST_DB_URL);\n\n    orientDBClient.setProperties(p);\n    orientDBClient.init();\n    orientDBDictionary = orientDBClient.db.getDictionary();\n  }", "LocalizedBug": "orientDBConnection = new ODatabaseDocumentTx(TEST_DB_URL).open(\"admin\",\"admin\");\norientDBDictionary = orientDBConnection.getMetadata().getIndexManager().getDictionary();", "LocalizedPatchLength": 169, "CodeLength": 505}
{"BuggyCode": "public static OptionType getOptionType(OptionName opt_name){\n        return syntaxConstraints.get(opt_name).opt_type;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `de.uniluebeck.itm.spitfire.nCoap.message.options.OptionRegistry.syntaxConstraints.get(opt_name)` could be null and is dereferenced at line 250."}, "FixedCode": "public static OptionType getOptionType(OptionName opt_name){\n        OptionSyntaxConstraints osc = syntaxConstraints.get(opt_name);\n        if(osc == null) {\n            throw new NullPointerException(\"OptionSyntaxConstraints does not exists!\");\n        }\n        return osc.opt_type;\n    }", "LocalizedBug": "return syntaxConstraints.get(opt_name).opt_type;", "LocalizedPatchLength": 48, "CodeLength": 123}
{"BuggyCode": "static String rootPath() {\n        String path = System.getProperty(\"java.io.tmpdir\");\n        String sep = System.getProperty(\"file.separator\");\n\n        if (!path.endsWith(sep)) {\n            path += sep;\n        }\n\n        return path + \"chronicle-log4j1\";\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `path` last assigned on line 34 could be null and is dereferenced at line 37."}, "FixedCode": "static String rootPath() {\n        String path = OS.getTarget();\n        String sep = System.getProperty(\"file.separator\");\n\n        if (!path.endsWith(sep)) {\n            path += sep;\n        }\n\n        return path + \"chronicle-log4j1\" + Time.uniqueId();\n    }", "LocalizedBug": "String path = System.getProperty(\"java.io.tmpdir\");", "LocalizedPatchLength": 51, "CodeLength": 265}
{"BuggyCode": "public void readExternal(ObjectInput in) throws IOException,\n\t\t\tClassNotFoundException {\n\t\tsuper.readExternal(in);\n\t\tfragmenter = External.readObject(in);\n\t\ttag = External.readUTF(in);\n\t\tmaxDocChar = in.readInt();\n\t\tseparator = External.readUTF(in);\n\t\tmaxSnippetSize = in.readInt();\n\t\tmaxSnippetNumber = in.readInt();\n\t\tint l = in.readInt();\n\t\tif (l > 0) {\n\t\t\tsearchTerms = new String[l];\n\t\t\tExternal.readArray(in, searchTerms);\n\t\t} else\n\t\t\tsearchTerms = null;\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.jaeksoft.searchlib.highlight.HighlightField.readExternal` reads without synchronization from `this.com.jaeksoft.searchlib.highlight.HighlightField.searchTerms`. Potentially races with write in method `HighlightField.initSearchTerms(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public void readExternal(ObjectInput in) throws IOException,\n\t\t\tClassNotFoundException {\n\t\tsuper.readExternal(in);\n\t\tfragmenter = External.readObject(in);\n\t\ttag = External.readUTF(in);\n\t\tmaxDocChar = in.readInt();\n\t\tseparator = External.readUTF(in);\n\t\tmaxSnippetSize = in.readInt();\n\t\tmaxSnippetNumber = in.readInt();\n\t\tsearchTerms = External.readStringArray(in);\n\t}", "LocalizedBug": "int l = in.readInt();\nif (l > 0) {\nsearchTerms = new String[l];\nExternal.readArray(in, searchTerms);\n} else\nsearchTerms = null;\n}", "LocalizedPatchLength": 129, "CodeLength": 463}
{"BuggyCode": "static String rootPath() {\n        String path = System.getProperty(\"java.io.tmpdir\");\n        String sep = System.getProperty(\"file.separator\");\n\n        if (!path.endsWith(sep)) {\n            path += sep;\n        }\n\n        return path + \"chronicle-log4j2\";\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `path` last assigned on line 35 could be null and is dereferenced at line 38."}, "FixedCode": "static String rootPath() {\n        String path = OS.getTarget();\n        String sep = System.getProperty(\"file.separator\");\n\n        if (!path.endsWith(sep)) {\n            path += sep;\n        }\n\n        return path + \"chronicle-log4j2\" + Time.uniqueId();\n    }", "LocalizedBug": "String path = System.getProperty(\"java.io.tmpdir\");", "LocalizedPatchLength": 51, "CodeLength": 265}
{"BuggyCode": "public int getResponseCode() {\n\t\tif (response == null) {\n\t\t\tthrow new IllegalStateException(\"The request must first be executed\");\n\t\t}\n\t\treturn response.getCode();\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `net.rithms.riot.api.request.Request.getResponseCode` reads without synchronization from `this.net.rithms.riot.api.request.Request.response`. Potentially races with write in method `Request.execute()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public int getResponseCode() {\n\t\trequireSucceededRequestState();\n\t\treturn responseCode;\n\t}", "LocalizedBug": "if (response == null) {\nthrow new IllegalStateException(\"The request must first be executed\");\n}\nreturn response.getCode();", "LocalizedPatchLength": 123, "CodeLength": 166}
{"BuggyCode": "@Override\n    public String toString()\n    {\n        final StringBuffer sb;\n\n        sb = new StringBuffer(\"AsteriskAgent[\");\n        sb.append(\"agentId='\").append(getAgentId()).append(\"',\");\n        sb.append(\"name='\").append(getName()).append(\"',\");\n        sb.append(\"state=\").append(getStatus()).append(\",\");\n        sb.append(\"systemHashcode=\").append(System.identityHashCode(this));\n        sb.append(\"]\");\n\n        return sb.toString();\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.asteriskjava.live.internal.AsteriskAgentImpl.toString` indirectly reads without synchronization from `this.org.asteriskjava.live.internal.AsteriskAgentImpl.status`. Potentially races with write in method `AsteriskAgentImpl.updateStatus(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n    public String toString()\n    {\n        final StringBuffer sb;\n\n        sb = new StringBuffer(\"AsteriskAgent[\");\n        sb.append(\"agentId='\").append(getAgentId()).append(\"',\");\n        sb.append(\"name='\").append(getName()).append(\"',\");\n        sb.append(\"state=\").append(getState()).append(\",\");\n        sb.append(\"systemHashcode=\").append(System.identityHashCode(this));\n        sb.append(\"]\");\n\n        return sb.toString();\n    }", "LocalizedBug": "sb.append(\"state=\").append(getStatus()).append(\",\");", "LocalizedPatchLength": 52, "CodeLength": 449}
{"BuggyCode": "void resetStatistics()\n    {\n        rehashes = 0L;\n        evictedEntries = 0L;\n        hitCount = 0L;\n        missCount = 0L;\n        putAddCount = 0L;\n        putReplaceCount = 0L;\n        removeCount = 0L;\n        lruCompactions = 0L;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.caffinitas.ohc.tables.OffHeapMap.resetStatistics` writes to field `this.org.caffinitas.ohc.tables.OffHeapMap.rehashes` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, AtomicLong freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        int bl = builder.getBucketLength();\n        if (bl <= 0)\n            bl = 8;\n        int buckets = (int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE);\n        entriesPerBucket = (int) Util.roundUpToPowerOf2(bl, MAX_TABLE_SIZE);\n        table = Table.create(buckets, entriesPerBucket);\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        if (lf >= 1d)\n            throw new IllegalArgumentException(\"load factor must not be greater that 1\");\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "void resetStatistics()\n{\nrehashes = 0L;\nevictedEntries = 0L;\nhitCount = 0L;\nmissCount = 0L;\nputAddCount = 0L;\nputReplaceCount = 0L;\nremoveCount = 0L;\nlruCompactions = 0L;", "LocalizedPatchLength": 170, "CodeLength": 244}
{"BuggyCode": "@Override\n    @SuppressWarnings(\"unchecked\")\n    public boolean removeAll(Collection<?> c) {\n        Iterator<? extends Model> iterator = (Iterator<? extends Model>) c\n                .iterator();\n        boolean success = true;\n        while (iterator.hasNext()) {\n            T element = (T) iterator.next();\n            success &= internalRemove(element, false);\n        }\n        refreshStorage(true);\n        return success;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `redis.clients.johm.collections.RedisSet.removeAll` indirectly writes to field `this.redis.clients.johm.collections.RedisSet.nest.redis.clients.johm.Nest.sb` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n    @SuppressWarnings(\"unchecked\")\n    public boolean removeAll(Collection<?> c) {\n        Iterator<? extends Model> iterator = (Iterator<? extends Model>) c\n                .iterator();\n        boolean success = true;\n        while (iterator.hasNext()) {\n            T element = (T) iterator.next();\n            success &= internalRemove(element);\n        }\n        return success;\n    }", "LocalizedBug": "success &= internalRemove(element, false);\nrefreshStorage(true);", "LocalizedPatchLength": 64, "CodeLength": 435}
{"BuggyCode": "@Override\n    public void releaseSub() {\n        try {\n            if (info != null) {\n                info.session.close();\n                info.conn.close();\n            }\n        } catch (final JMSException ex) {\n            LOGGER.error(\"Error closing \" + getName(), ex);\n        } finally {\n            info = null;\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.apache.logging.log4j.core.net.JMSQueueManager.releaseSub` writes to field `this.org.apache.logging.log4j.core.net.JMSQueueManager.info` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n    public void releaseSub() {\n        if (info != null) {\n            cleanup(false);\n        }\n    }", "LocalizedBug": "public void releaseSub() {\ntry {\ninfo.session.close();\ninfo.conn.close();\n} catch (final JMSException ex) {\nLOGGER.error(\"Error closing \" + getName(), ex);\n} finally {\ninfo = null;\n}\n}", "LocalizedPatchLength": 184, "CodeLength": 336}
{"BuggyCode": "@Test\n    public void testValidMapStatementAndTrimMultipleWhitSpaces() throws Exception {\n        ForLoopStatement statement = transformer.transform(\"   k,    v     in  collection  \");\n        Assert.assertEquals(ForLoopStatement.Type.MAP, statement.getType());\n        Assert.assertEquals(\"k v\", statement.getVarName());\n        Assert.assertEquals(\"collection\", statement.getCollectionExpression());\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `statement` last assigned on line 119 could be null and is dereferenced at line 120."}, "FixedCode": "@Test\n    public void testValidMapStatementAndTrimMultipleWhitSpaces() throws Exception {\n        ForLoopStatement statement = transformer.transform(\"   k,    v     in  collection  \");\n        MapForLoopStatement mapForLoopStatement  = validateMapForLoopStatement(statement);\n        Assert.assertEquals(\"k\", mapForLoopStatement.getKeyName());\n        Assert.assertEquals(\"v\", mapForLoopStatement.getValueName());\n        Assert.assertEquals(\"collection\", statement.getCollectionExpression());\n    }", "LocalizedBug": "Assert.assertEquals(ForLoopStatement.Type.MAP, statement.getType());\nAssert.assertEquals(\"k v\", statement.getVarName());", "LocalizedPatchLength": 120, "CodeLength": 407}
{"BuggyCode": "private void verifyArchivedNotContainingItself(WorkflowRun run) throws IOException {\n        assertTrue(\"Build should have artifacts\", run.getHasArtifacts());\n        Run<WorkflowJob, WorkflowRun>.Artifact artifact = run.getArtifacts().get(0);\n        VirtualFile file = run.getArtifactManager().root().child(artifact.relativePath);\n        ZipInputStream zip = new ZipInputStream(file.open());\n        for(ZipEntry entry = zip.getNextEntry(); entry != null; entry = zip.getNextEntry()) {\n            assertNotEquals(\"The zip output file shouldn't contain itself\", entry.getName(), artifact.getFileName());\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.util.zip.ZipInputStream` acquired to `zip` by call to `new()` at line 213 is not released after line 217.\n**Note**: potential exception at line 214"}, "FixedCode": "private void verifyArchivedNotContainingItself(WorkflowRun run) throws IOException {\n        assertTrue(\"Build should have artifacts\", run.getHasArtifacts());\n        Run<WorkflowJob, WorkflowRun>.Artifact artifact = run.getArtifacts().get(0);\n        VirtualFile file = run.getArtifactManager().root().child(artifact.relativePath);\n        try (ZipInputStream zip = new ZipInputStream(file.open())) {\n            for (ZipEntry entry = zip.getNextEntry(); entry != null; entry = zip.getNextEntry()) {\n                assertNotEquals(\"The zip output file shouldn't contain itself\", entry.getName(), artifact.getFileName());\n            }\n        }\n    }", "LocalizedBug": "ZipInputStream zip = new ZipInputStream(file.open());", "LocalizedPatchLength": 53, "CodeLength": 622}
{"BuggyCode": "@Test public void readerUnusedPromotionDoesntPersist() throws Exception {\n    JsonReader reader = new JsonReader(new Buffer().writeUtf8(\"[{},{\\\"a\\\":5}]\"));\n    reader.beginArray();\n    reader.beginObject();\n    reader.promoteNameToValue();\n    reader.endObject();\n    reader.beginObject();\n    try {\n      reader.nextString();\n      fail();\n    } catch (JsonDataException expected) {\n    }\n    assertThat(reader.nextName()).isEqualTo(\"a\");\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.squareup.moshi.JsonReader` acquired to `reader` by call to `new()` at line 148 is not released after line 160.\n**Note**: potential exception at line 149"}, "FixedCode": "@Test public void readerUnusedPromotionDoesntPersist() throws Exception {\n    JsonReader reader = newReader(\"[{},{\\\"a\\\":5}]\");\n    reader.beginArray();\n    reader.beginObject();\n    reader.promoteNameToValue();\n    reader.endObject();\n    reader.beginObject();\n    try {\n      reader.nextString();\n      fail();\n    } catch (JsonDataException expected) {\n    }\n    assertThat(reader.nextName()).isEqualTo(\"a\");\n  }", "LocalizedBug": "JsonReader reader = new JsonReader(new Buffer().writeUtf8(\"[{},{\\\"a\\\":5}]\"));", "LocalizedPatchLength": 77, "CodeLength": 443}
{"BuggyCode": "@Override\n    public Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder cb) {\n        Specifications<T> combinedSpecs = null;\n        for (Specification<T> spec : innerSpecs) {\n            if (combinedSpecs == null) {\n                combinedSpecs = Specifications.where(spec);\n            } else {\n                combinedSpecs = combinedSpecs.or(spec);\n            }\n        }\n        return combinedSpecs.toPredicate(root, query, cb);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `combinedSpecs` last assigned on line 51 could be null and is dereferenced at line 59."}, "FixedCode": "@Override\n    public Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder cb) {\n        Specification<T> combinedSpecs = null;\n        for (Specification<T> spec : innerSpecs) {\n            if (combinedSpecs == null) {\n                combinedSpecs = Specification.where(spec);\n            } else {\n                combinedSpecs = combinedSpecs.or(spec);\n            }\n        }\n        return combinedSpecs.toPredicate(root, query, cb);\n    }", "LocalizedBug": "Specifications<T> combinedSpecs = null;\ncombinedSpecs = Specifications.where(spec);", "LocalizedPatchLength": 83, "CodeLength": 468}
{"BuggyCode": "public void run() {\n\t\tif( thread == null )\n\t\t\tthread = Thread.currentThread();\n\t\tinterruptableRun();\n\n\t\ttry {\n\t\t\tif( selector != null ) // if the initialization in <code>tryToConnect</code> fails, it could be null\n\t\t\t\tselector.close();\n\t\t} catch ( IOException e ) {\n\t\t\tonError( e );\n\t\t}\n\t\tcloselock.lock();\n\t\tselector = null;\n\t\tcloselock.unlock();\n\t\ttry {\n\t\t\tchannel.close();\n\t\t} catch ( IOException e ) {\n\t\t\tonError( e );\n\t\t}\n\t\tchannel = null;\n\t\tthread = null;\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.java_websocket.client.WebSocketClient.run` reads without synchronization from `this.org.java_websocket.client.WebSocketClient.channel`. Potentially races with write in method `WebSocketClient.run()`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public void run() {\n\t\tif( thread == null )\n\t\t\tthread = Thread.currentThread();\n\t\tinterruptableRun();\n\t\t\n\t\tassert ( !channel.isOpen() );\n\n\t\ttry {\n\t\t\tif( selector != null ) // if the initialization in <code>tryToConnect</code> fails, it could be null\n\t\t\t\tselector.close();\n\t\t} catch ( IOException e ) {\n\t\t\tonError( e );\n\t\t}\n\n\t}", "LocalizedBug": "closelock.lock();\nselector = null;\ncloselock.unlock();\ntry {\nchannel.close();\n} catch ( IOException e ) {\nonError( e );\n}\nchannel = null;\nthread = null;\n}", "LocalizedPatchLength": 154, "CodeLength": 464}
{"BuggyCode": "@Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Latency min/avg/max: \" + getMinLatency() + \"/\" + getAvgLatency() + \"/\" + getMaxLatency() + \"\\n\");\n        sb.append(\"Received: \" + getPacketsReceived() + \"\\n\");\n        sb.append(\"Sent: \" + getPacketsSent() + \"\\n\");\n        if (provider != null) {\n            sb.append(\"Outstanding: \" + getOutstandingRequests() + \"\\n\");\n            sb.append(\"Zxid: 0x\" + Long.toHexString(getLastProcessedZxid()) + \"\\n\");\n        }\n        sb.append(\"Mode: \" + getServerState() + \"\\n\");\n        return sb.toString();\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.apache.bookkeeper.proto.ServerStats.toString` reads without synchronization from `this.org.apache.bookkeeper.proto.ServerStats.provider`. Potentially races with write in method `ServerStats.setStatsProvider(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Latency min/avg/max: \" + getMinLatency() + \"/\" + getAvgLatency() + \"/\" + getMaxLatency() + \"\\n\");\n        sb.append(\"Received: \" + getPacketsReceived() + \"\\n\");\n        sb.append(\"Sent: \" + getPacketsSent() + \"\\n\");\n        return sb.toString();\n    }", "LocalizedBug": "if (provider != null) {\nsb.append(\"Outstanding: \" + getOutstandingRequests() + \"\\n\");\nsb.append(\"Zxid: 0x\" + Long.toHexString(getLastProcessedZxid()) + \"\\n\");\n}\nsb.append(\"Mode: \" + getServerState() + \"\\n\");", "LocalizedPatchLength": 207, "CodeLength": 615}
{"BuggyCode": "@Test\n    public void testStepPublishValues() throws Exception {\n        URL resource = getClass().getResource(\"/yaml/binding_scope_flow.sl\");\n        URI operation = getClass().getResource(\"/yaml/binding_scope_op.sl\").toURI();\n        Set<SlangSource> path = Sets.newHashSet(SlangSource.fromFile(operation));\n        CompilationArtifact compilationArtifact = slang.compile(SlangSource.fromFile(resource.toURI()), path);\n\n        Map<String, Value> userInputs = Collections.emptyMap();\n        Set<SystemProperty> systemProperties = Collections.emptySet();\n\n        // trigger ExecutionPlan\n        RuntimeInformation runtimeInformation = triggerWithData(compilationArtifact, userInputs, systemProperties);\n\n        Map<String, StepData> executionData = runtimeInformation.getSteps();\n\n        StepData stepData = executionData.get(FIRST_STEP_PATH);\n        Assert.assertNotNull(\"step data is null\", stepData);\n\n        verifyStepPublishValues(stepData);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `stepData` last assigned on line 58 could be null and is dereferenced by call to `verifyStepPublishValues(...)` at line 61."}, "FixedCode": "@Test\n    public void testStepPublishValues() throws Exception {\n        URL resource = getClass().getResource(\"/yaml/binding_scope_flow.sl\");\n        URI operation = getClass().getResource(\"/yaml/binding_scope_op.sl\").toURI();\n        Set<SlangSource> path = Sets.newHashSet(SlangSource.fromFile(operation));\n        CompilationArtifact compilationArtifact = slang.compile(SlangSource.fromFile(resource.toURI()), path);\n\n        Map<String, Value> userInputs = Collections.emptyMap();\n        Set<SystemProperty> systemProperties = Collections.emptySet();\n\n        // trigger ExecutionPlan\n        RuntimeInformation runtimeInformation = triggerWithData(compilationArtifact, userInputs, systemProperties);\n\n        Map<String, StepData> executionData = runtimeInformation.getSteps();\n\n        StepData stepData = executionData.get(FIRST_STEP_PATH);\n        Assert.assertNotNull(\"step data is null\", stepData);\n    }", "LocalizedBug": "verifyStepPublishValues(stepData);", "LocalizedPatchLength": 34, "CodeLength": 960}
{"BuggyCode": "protected void callOnFinalState(final State<C> state, final C context) {\n        try {\n            if (onFinalStateHandler != null) {\n                if (isTrace())\n                    log.debug(\"when final state {} for {} <<<\", state, context);\n\n                onFinalStateHandler.call(state, context);\n\n                if (isTrace())\n                    log.debug(\"when final state {} for {} >>>\", state, context);\n            }\n\n            synchronized (context) {\n                callOnTerminate(context);\n                context.notifyAll();\n            }\n\n        } catch (Exception e) {\n            callOnError(new ExecutionError(state, null, e,\n                \"Execution Error in [EasyFlow.whenFinalState] handler\", context));\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `au.com.ds.ef.EasyFlow.callOnFinalState` reads without synchronization from `this.au.com.ds.ef.EasyFlow.onFinalStateHandler`. Potentially races with write in method `EasyFlow.whenFinalState(...)`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "protected void callOnFinalState(final State<C> state, final C context) {\n        try {\n            if (onFinalStateHandler != null) {\n                if (isTrace())\n                    log.debug(\"when final state {} for {} <<<\", state, context);\n\n                onFinalStateHandler.call(state, context);\n\n                if (isTrace())\n                    log.debug(\"when final state {} for {} >>>\", state, context);\n            }\n\n            callOnTerminate(context);\n        } catch (Exception e) {\n            callOnError(new ExecutionError(state, null, e,\n                \"Execution Error in [EasyFlow.whenFinalState] handler\", context));\n        }\n    }", "LocalizedBug": "synchronized (context) {\ncontext.notifyAll();\n}", "LocalizedPatchLength": 47, "CodeLength": 753}
{"BuggyCode": "public static V8 createV8Runtime(final String globalAlias, final String tempDirectory) {\n        if (!nativeLibraryLoaded) {\n            synchronized (lock) {\n                if (!nativeLibraryLoaded) {\n                    load(tempDirectory);\n                }\n            }\n        }\n        checkNativeLibraryLoaded();\n        if (!initialized) {\n            _setFlags(v8Flags);\n            initialized = true;\n        }\n        if (debugThread == null) {\n            debugThread = Thread.currentThread();\n        }\n        V8 runtime = new V8(globalAlias);\n        synchronized (lock) {\n            runtimeCounter++;\n        }\n        return runtime;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `com.eclipsesource.v8.V8.createV8Runtime` writes to field `v8.V8.com.eclipsesource.v8.V8.debugThread` outside of synchronization.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public static V8 createV8Runtime(final String globalAlias, final String tempDirectory) {\n        if (!nativeLibraryLoaded) {\n            synchronized (lock) {\n                if (!nativeLibraryLoaded) {\n                    load(tempDirectory);\n                }\n            }\n        }\n        checkNativeLibraryLoaded();\n        if (!initialized) {\n            _setFlags(v8Flags);\n            initialized = true;\n        }\n        V8 runtime = new V8(globalAlias);\n        synchronized (lock) {\n            runtimeCounter++;\n        }\n        return runtime;\n    }", "LocalizedBug": "if (debugThread == null) {\ndebugThread = Thread.currentThread();\n}", "LocalizedPatchLength": 66, "CodeLength": 660}
{"BuggyCode": "@Test\n    public void canFindOne() throws Exception {\n        /* given */\n        String id = collection.save(this.people);\n\n        /* when */\n        People people = collection.findOne(\"{name:#}\", \"John\").as(People.class);\n\n        /* then */\n        assertThat(people.getId()).isEqualTo(id);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `people` last assigned on line 51 could be null and is dereferenced at line 54."}, "FixedCode": "@Test\n    public void canFindOne() throws Exception {\n        /* given */\n        String id = collection.save(new People(\"John\", new Coordinate(1, 1)));\n\n        /* when */\n        People result = collection.findOne(\"{name:#}\", \"John\").as(People.class);\n\n        /* then */\n        assertThat(result.getId()).isEqualTo(id);\n    }", "LocalizedBug": "String id = collection.save(this.people);\nPeople people = collection.findOne(\"{name:#}\", \"John\").as(People.class);\nassertThat(people.getId()).isEqualTo(id);", "LocalizedPatchLength": 156, "CodeLength": 300}
{"BuggyCode": "@Override\n\tpublic <T> T get(Class<? extends T> clazz, long id) throws EntityNotFoundException\n\t{\n\t\t// The cast gets rid of \"no unique maximal instance exists\" compiler error\n\t\treturn (T)this.get(this.factory.createKey(clazz, id));\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `ObjectifyImpl.factory.createKey(clazz,id)` could be null and is dereferenced by call to `get(...)` at line 92."}, "FixedCode": "@Override\n\tpublic <T> T get(Class<? extends T> clazz, long id) throws EntityNotFoundException\n\t{\n\t\t// The cast gets rid of \"no unique maximal instance exists\" compiler error\n\t\treturn (T)this.get(new OKey<T>(clazz, id));\n\t}", "LocalizedBug": "return (T)this.get(this.factory.createKey(clazz, id));", "LocalizedPatchLength": 54, "CodeLength": 233}
{"BuggyCode": "@Nonnull\n    private static RoleMap retrieveRoleMap(@Nonnull CNode config, @Nonnull String name, Configurator<RoleDefinition> configurator) throws ConfiguratorException {\n        Mapping map = config.asMapping();\n        final Sequence c = map.get(name).asSequence();\n\n        TreeMap<Role, Set<String>> resMap = new TreeMap<>();\n        if (c == null) {\n            // we cannot return emptyMap here due to the Role Strategy code\n            return new RoleMap(resMap);\n        }\n\n        for (CNode entry : c) {\n            RoleDefinition definition = configurator.configure(entry);\n            resMap.put(definition.getRole(), definition.getAssignments());\n        }\n\n        return new RoleMap(resMap);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `map.get(name)` could be null and is dereferenced at line 71."}, "FixedCode": "@Nonnull\n    private static RoleMap retrieveRoleMap(@Nonnull CNode config, @Nonnull String name, Configurator<RoleDefinition> configurator) throws ConfiguratorException {\n        Mapping map = config.asMapping();\n        final CNode c = map.get(name);\n\n        TreeMap<Role, Set<String>> resMap = new TreeMap<>();\n        if (c == null || c.asSequence() == null) {\n            // we cannot return emptyMap here due to the Role Strategy code\n            return new RoleMap(resMap);\n        }\n\n        for (CNode entry : c.asSequence()) {\n            RoleDefinition definition = configurator.configure(entry);\n            resMap.put(definition.getRole(), definition.getAssignments());\n        }\n\n        return new RoleMap(resMap);\n    }", "LocalizedBug": "final Sequence c = map.get(name).asSequence();", "LocalizedPatchLength": 46, "CodeLength": 712}
{"BuggyCode": "@Test\n  public void testCommandHandlerOnStartup() {\n    SqlLine sqlLine = new SqlLine();\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    final String[] args = {\n        \"-e\", \"!set maxwidth 80\",\n        \"-ch\", \"sqlline.extensions.HelloWorldCommandHandler\"};\n    begin(sqlLine, os, false, args);\n\n    try {\n      sqlLine.runCommands(new DispatchCallback(), \"!hello\");\n      String output = os.toString(\"UTF8\");\n      assertThat(output, containsString(\"HELLO WORLD\"));\n      os.reset();\n      sqlLine.runCommands(new DispatchCallback(), \"!test\");\n      output = os.toString(\"UTF8\");\n      assertThat(output, containsString(\"HELLO WORLD\"));\n      os.reset();\n      sqlLine.runCommands(new DispatchCallback(), \"!help hello\");\n      output = os.toString(\"UTF8\");\n      assertThat(output, containsString(\"help for hello test\"));\n      sqlLine.runCommands(new DispatchCallback(), \"!quit\");\n      assertTrue(sqlLine.isExit());\n    } catch (Exception e) {\n      // fail\n      throw new RuntimeException(e);\n    }\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.PrintStream` acquired by call to `SqlLine()` at line 1104 is not released after line 1109."}, "FixedCode": "@Test\n  public void testCommandHandlerOnStartup() {\n    ByteArrayOutputStream os = new ByteArrayOutputStream();\n    final String[] args = {\n        \"-e\", \"!set maxwidth 80\",\n        \"-ch\", \"sqlline.extensions.HelloWorldCommandHandler\"};\n    begin(sqlLine, os, false, args);\n\n    try {\n      sqlLine.runCommands(new DispatchCallback(), \"!hello\");\n      String output = os.toString(\"UTF8\");\n      assertThat(output, containsString(\"HELLO WORLD\"));\n      os.reset();\n      sqlLine.runCommands(new DispatchCallback(), \"!test\");\n      output = os.toString(\"UTF8\");\n      assertThat(output, containsString(\"HELLO WORLD\"));\n      os.reset();\n      sqlLine.runCommands(new DispatchCallback(), \"!help hello\");\n      output = os.toString(\"UTF8\");\n      assertThat(output, containsString(\"help for hello test\"));\n      sqlLine.runCommands(new DispatchCallback(), \"!quit\");\n      assertTrue(sqlLine.isExit());\n    } catch (Exception e) {\n      // fail\n      throw new RuntimeException(e);\n    }\n  }", "LocalizedBug": "SqlLine sqlLine = new SqlLine();", "LocalizedPatchLength": 32, "CodeLength": 1023}
{"BuggyCode": "protected void beginTransaction() {\n        if (listener != null) {\n            listener.beginTransaction();\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.eclipse.leshan.client.resource.BaseObjectEnabler.beginTransaction` indirectly writes to field `this.org.eclipse.leshan.client.resource.BaseObjectEnabler.listener.org.eclipse.leshan.client.resource.TransactionalObjectListener.inTransaction` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "protected void beginTransaction() {\n        transactionalListener.beginTransaction();\n    }", "LocalizedBug": "if (listener != null) {\nlistener.beginTransaction();\n}", "LocalizedPatchLength": 54, "CodeLength": 124}
{"BuggyCode": "public long getDownloaded() {\n    return this.downloaded;\n  }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.turn.ttorrent.client.SharedTorrent.getDownloaded` reads without synchronization from `this.com.turn.ttorrent.client.SharedTorrent.downloaded`. Potentially races with write in method `SharedTorrent.handlePieceCompleted(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public long getDownloaded() {\n    return myTorrentStatistic.getDownloadedBytes();\n  }", "LocalizedBug": "return this.downloaded;", "LocalizedPatchLength": 23, "CodeLength": 61}
{"BuggyCode": "@Test\n    public void reactsToMessage() throws Exception {\n        final Reaction reaction = Mockito.mock(Reaction.class);\n        new TkViber(new FkFarm(), reaction).act(\n            new RqWithBody(\n                new RqFake(\"POST\", \"/\"),\n                new TextOf(\n                    TkViberTest.class.getResourceAsStream(\"message.json\")\n                ).asString()\n            )\n        );\n        Mockito.verify(reaction)\n            .react(Mockito.any(), Mockito.any(), Mockito.any());\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.farm.fake.FkFarm` acquired by call to `FkFarm()` at line 57 is not released after line 57.\n**Note**: potential exception at line 57"}, "FixedCode": "@Test\n    public void reactsToMessage() throws Exception {\n        final Reaction reaction = Mockito.mock(Reaction.class);\n        final FkFarm farm = new FkFarm();\n        final VbBot bot = new VbBot();\n        final String callback = new TextOf(\n            TkViberTest.class.getResourceAsStream(\"message.json\")\n        ).asString();\n        new TkViber(farm, bot, reaction).act(\n            new RqWithBody(\n                new RqFake(\"POST\", \"/\"),\n                callback\n            )\n        );\n        Mockito.verify(reaction)\n            .react(\n                Mockito.eq(bot), Mockito.eq(farm), Mockito.argThat(\n                    event -> event.json()\n                        .equals(\n                            Json.createReader(new StringReader(callback))\n                                .readObject()\n                        )\n                )\n            );\n    }", "LocalizedBug": "new TkViber(new FkFarm(), reaction).act(\nnew TextOf(\nTkViberTest.class.getResourceAsStream(\"message.json\")\n).asString()\n.react(Mockito.any(), Mockito.any(), Mockito.any());", "LocalizedPatchLength": 172, "CodeLength": 500}
{"BuggyCode": "public void installSnapshot(Peer peer) {\n        Raft.InstallSnapshotRequest.Builder requestBuilder = Raft.InstallSnapshotRequest.newBuilder();\n        requestBuilder.setServerId(localServer.getServerId());\n        requestBuilder.setTerm(currentTerm);\n        // send snapshot\n        try {\n            snapshotLock.readLock().lock();\n            Raft.InstallSnapshotRequest request = this.buildInstallSnapshotRequest(\n                    null, 0, 0);\n            peer.getRpcClient().asyncCall(\"RaftConsensusService.installSnapshot\",\n                    request, new InstallSnapshotResponseCallback(peer, request));\n            isSnapshoting = true;\n        } finally {\n            snapshotLock.readLock().unlock();\n        }\n\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.github.wenweihu86.raft.RaftNode.installSnapshot` reads without synchronization from `this.com.github.wenweihu86.raft.RaftNode.currentTerm`. Potentially races with write in method `RaftNode.stepDown(...)`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public void installSnapshot(Peer peer) {\n        Raft.InstallSnapshotRequest.Builder requestBuilder = Raft.InstallSnapshotRequest.newBuilder();\n        requestBuilder.setServerId(localServer.getServerId());\n        requestBuilder.setTerm(currentTerm);\n        // send snapshot\n        Raft.InstallSnapshotRequest request = this.buildInstallSnapshotRequest(\n                null, 0, 0);\n        peer.getRpcClient().asyncCall(\"RaftConsensusService.installSnapshot\",\n                request, new InstallSnapshotResponseCallback(peer, request));\n        isSnapshoting = true;\n\n    }", "LocalizedBug": "try {\nsnapshotLock.readLock().lock();\n} finally {\nsnapshotLock.readLock().unlock();\n}\n}", "LocalizedPatchLength": 87, "CodeLength": 732}
{"BuggyCode": "public static V8 createV8Runtime(final String globalAlias, final String tempDirectory) {\n        if (!nativeLibraryLoaded) {\n            synchronized (lock) {\n                if (!nativeLibraryLoaded) {\n                    load(tempDirectory);\n                }\n            }\n        }\n        checkNativeLibraryLoaded();\n        if (!initialized) {\n            _setFlags(v8Flags);\n            initialized = true;\n        }\n        if (debugThread == null) {\n            debugThread = Thread.currentThread();\n        }\n        V8 runtime = new V8(globalAlias);\n        synchronized (lock) {\n            runtimeCounter++;\n        }\n        return runtime;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.eclipsesource.v8.V8.createV8Runtime` reads without synchronization from `v8.V8.com.eclipsesource.v8.V8.debugThread`. Potentially races with write in method `V8.createV8Runtime(...)`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public static V8 createV8Runtime(final String globalAlias, final String tempDirectory) {\n        if (!nativeLibraryLoaded) {\n            synchronized (lock) {\n                if (!nativeLibraryLoaded) {\n                    load(tempDirectory);\n                }\n            }\n        }\n        checkNativeLibraryLoaded();\n        if (!initialized) {\n            _setFlags(v8Flags);\n            initialized = true;\n        }\n        V8 runtime = new V8(globalAlias);\n        synchronized (lock) {\n            runtimeCounter++;\n        }\n        return runtime;\n    }", "LocalizedBug": "if (debugThread == null) {\ndebugThread = Thread.currentThread();\n}", "LocalizedPatchLength": 66, "CodeLength": 660}
{"BuggyCode": "void resetStatistics()\n    {\n        rehashes = 0L;\n        evictedEntries = 0L;\n        hitCount = 0L;\n        missCount = 0L;\n        putAddCount = 0L;\n        putReplaceCount = 0L;\n        removeCount = 0L;\n        lruCompactions = 0L;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.caffinitas.ohc.tables.OffHeapMap.resetStatistics` writes to field `this.org.caffinitas.ohc.tables.OffHeapMap.removeCount` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, AtomicLong freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        int bl = builder.getBucketLength();\n        if (bl <= 0)\n            bl = 8;\n        int buckets = (int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE);\n        entriesPerBucket = (int) Util.roundUpToPowerOf2(bl, MAX_TABLE_SIZE);\n        table = Table.create(buckets, entriesPerBucket);\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        if (lf >= 1d)\n            throw new IllegalArgumentException(\"load factor must not be greater that 1\");\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "void resetStatistics()\n{\nrehashes = 0L;\nevictedEntries = 0L;\nhitCount = 0L;\nmissCount = 0L;\nputAddCount = 0L;\nputReplaceCount = 0L;\nremoveCount = 0L;\nlruCompactions = 0L;", "LocalizedPatchLength": 170, "CodeLength": 244}
{"BuggyCode": "@Test\n    public void multiThreadedReloadTest() throws Throwable {\n        Object lock = new Object();\n\n        ReaderThread[] readers = newArray(20, new ReaderThread(reloadableConfig, lock, 100));\n        WriterThread[] writers = newArray(5, new WriterThread(reloadableConfig, lock, 70));\n\n        start(readers, writers);\n\n        synchronized (lock) {\n            lock.notifyAll();\n        }\n\n        join(readers, writers);\n\n        assertNoErrors(readers, writers);\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.aeonbits.owner.multithread.MultiThreadReloadTest.multiThreadedReloadTest` indirectly reads without synchronization from `multithread.ThreadBase.org.aeonbits.owner.multithread.ThreadBase.counter`. Potentially races with write in method `MultiThreadReloadTest.multiThreadedReloadTest()`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "@Test\n    public void multiThreadedReloadTest() throws Throwable {\n        Object lock = new Object();\n\n        ReaderThread[] readers = newArray(20, new ReaderThread(reloadableConfig, lock, 100));\n        WriterThread[] writers = newArray(5, new WriterThread(reloadableConfig, lock, 70));\n\n        start(readers, writers);\n\n        notifyAll(lock);\n\n        join(readers, writers);\n\n        assertNoErrors(readers, writers);\n    }", "LocalizedBug": "synchronized (lock) {\nlock.notifyAll();\n}", "LocalizedPatchLength": 41, "CodeLength": 476}
{"BuggyCode": "@Test\n    public void testBackslashEscaping2() throws IOException {\n\n        // To avoid confusion over the need for escaping chars in java code,\n        // We will test with a forward slash as the escape char, and a single\n        // quote as the encapsulator.\n\n        String code = \"\"\n                + \" , , \\n\"           // 1)\n                + \" \\t ,  , \\n\"       // 2)\n                + \" // , /, , /,\\n\"   // 3)\n                + \"\";\n        String[][] res = {\n                {\" \", \" \", \" \"},         // 1\n                {\" \\t \", \"  \", \" \"},     // 2\n                {\" / \", \" , \", \" ,\"},    // 3\n        };\n\n\n        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, true, \"\\r\\n\", null);\n\n        CSVParser parser = new CSVParser(code, format);\n        List<CSVRecord> records = parser.getRecords();\n        assertTrue(records.size() > 0);\n\n        assertTrue(CSVPrinterTest.equals(res, records));\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.PushbackReader` acquired by call to `CSVParser(...)` at line 317 is not released after line 318."}, "FixedCode": "@Test\n    public void testBackslashEscaping2() throws IOException {\n\n        // To avoid confusion over the need for escaping chars in java code,\n        // We will test with a forward slash as the escape char, and a single\n        // quote as the encapsulator.\n\n        String code = \"\"\n                + \" , , \\n\"           // 1)\n                + \" \\t ,  , \\n\"       // 2)\n                + \" // , /, , /,\\n\"   // 3)\n                + \"\";\n        String[][] res = {\n                {\" \", \" \", \" \"},         // 1\n                {\" \\t \", \"  \", \" \"},     // 2\n                {\" / \", \" , \", \" ,\"},    // 3\n        };\n\n\n        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, \"\\r\\n\", null);\n\n        CSVParser parser = new CSVParser(code, format);\n        List<CSVRecord> records = parser.getRecords();\n        assertTrue(records.size() > 0);\n\n        assertTrue(CSVPrinterTest.equals(res, records));\n    }", "LocalizedBug": "CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, true, \"\\r\\n\", null);", "LocalizedPatchLength": 125, "CodeLength": 969}
{"BuggyCode": "@Test\n    public void parsesJson() throws Exception {\n        MatcherAssert.assertThat(\n            new TkGithub(\n                new PropsFarm(),\n                new Rebound.Fake(\"nothing\")\n            ).act(\n                new RqWithBody(\n                    new RqFake(\"POST\", \"/\"),\n                    String.format(\n                        \"payload=%s\",\n                        URLEncoder.encode(\n                            \"{\\\"foo\\\": \\\"bar\\\"}\",\n                            StandardCharsets.UTF_8.displayName()\n                        )\n                    )\n                )\n            ),\n            new HmRsStatus(HttpURLConnection.HTTP_OK)\n        );\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.farm.props.PropsFarm` acquired by call to `PropsFarm()` at line 40 is not released after line 44.\n**Note**: potential exception at line 44"}, "FixedCode": "@Test\n    public void parsesJson() throws Exception {\n        final Farm farm = new PropsFarm(new FkFarm());\n        final Take take = new TkGithub(\n            farm, (frm, github, event) -> \"nothing\"\n        );\n        MatcherAssert.assertThat(\n            take.act(\n                new RqWithBody(\n                    new RqFake(\"POST\", \"/\"),\n                    String.format(\n                        \"payload=%s\",\n                        URLEncoder.encode(\n                            \"{\\\"foo\\\": \\\"bar\\\"}\",\n                            StandardCharsets.UTF_8.displayName()\n                        )\n                    )\n                )\n            ),\n            new HmRsStatus(HttpURLConnection.HTTP_OK)\n        );\n    }", "LocalizedBug": "new TkGithub(\nnew PropsFarm(),\nnew Rebound.Fake(\"nothing\")\n).act(", "LocalizedPatchLength": 65, "CodeLength": 669}
{"BuggyCode": "public static void main(String[] args)\n\t{\n\t\ttry\n\t\t{\n\t\t\tString ls_1;\n\t\t\tProcess process =null;\n\t\t\tFile handle = new File(\"./tmpdata/ctb/data3\");\n\t\t\tBufferedWriter bout = new BufferedWriter(new OutputStreamWriter(\n\t\t\t\t\tnew FileOutputStream(\"./tmpdata/malt.train\"), \"UTF-8\"));\n\t\t\tfor (File sub : Arrays.asList(handle.listFiles())){\n\t\t\t\tString str = sub.getAbsolutePath();\n\t\t\t\tprocess = Runtime.getRuntime().exec(\"cmd /c java -jar ./tmpdata/ctb/Penn2Malt.jar \"+str+\" ./tmpdata/ctb/headrules.txt 3 2 chtb\");\t\t\t\n\t\t\t\tBufferedReader bufferedReader = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(process.getInputStream()));\n\t\t\t\twhile ( (ls_1=bufferedReader.readLine()) != null)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(ls_1);\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\tcatch(IOException e)\n\t\t{\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.lang.Process` acquired to `process` by call to `exec(...)` at line 47 is not released after line 49."}, "FixedCode": "public static void main(String[] args)\n\t{\n\t\ttry\n\t\t{\n\t\t\tString ls_1;\n\t\t\tProcess process =null;\n//\t\t\tFile handle = new File(\"../tmp/ctb_v1/data\");\n\t\t\tFile handle = new File(\"../tmp/ctb_v6/data/bracketed\");\n\t\t\t\n\t\t\tBufferedWriter bout = new BufferedWriter(new OutputStreamWriter(\n\t\t\t\t\tnew FileOutputStream(\"../tmp/malt.train\"), \"UTF-8\"));\n\t\t\tfor (File sub : Arrays.asList(handle.listFiles())){\n\t\t\t\tString file = sub.getAbsolutePath();\n\t\t\t\tif(!file.endsWith(\".fid\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tclean(file);\n\t\t\t\tprocess = Runtime.getRuntime().exec(\"cmd /c java -jar ../tmp/Penn2Malt.jar \"+file+\" ../tmp/headrules.txt 3 2 chtb\");\t\t\t\n\t\t\t\tBufferedReader bufferedReader = new BufferedReader(\n\t\t\t\t\t\tnew InputStreamReader(process.getInputStream()));\n\t\t\t\twhile ( (ls_1=bufferedReader.readLine()) != null)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(ls_1);\n\t\t\t\t}\n\t\t\t\tbufferedReader = new BufferedReader(\n\t\t\t\t\t\tnew InputStreamReader(process.getErrorStream()));\n\t\t\t\twhile ( (ls_1=bufferedReader.readLine()) != null)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(ls_1);\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\tcatch(IOException e)\n\t\t{\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}", "LocalizedBug": "File handle = new File(\"./tmpdata/ctb/data3\");\nnew FileOutputStream(\"./tmpdata/malt.train\"), \"UTF-8\"));\nString str = sub.getAbsolutePath();\nprocess = Runtime.getRuntime().exec(\"cmd /c java -jar ./tmpdata/ctb/Penn2Malt.jar \"+str+\" ./tmpdata/ctb/headrules.txt 3 2 chtb\");", "LocalizedPatchLength": 269, "CodeLength": 785}
{"BuggyCode": "@Override\n\tpublic Object getParamValue(Req req, Class<?> paramType, String paramName, Map<String, Object> properties) throws Exception {\n\t\treturn req.custom().jackson().convertValue(properties, paramType);\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `req.custom().jackson()` could be null and is dereferenced at line 36."}, "FixedCode": "@Override\n\tpublic Object getParamValue(Req req, Class<?> paramType, String paramName, Map<String, Object> properties) throws Exception {\n\t\treturn Customization.of(req).jackson().convertValue(properties, paramType);\n\t}", "LocalizedBug": "return req.custom().jackson().convertValue(properties, paramType);", "LocalizedPatchLength": 66, "CodeLength": 208}
{"BuggyCode": "public static TSOState getState(TSOServerConfig config){\n        TSOState returnValue;\n        if(config.getZkServers() == null){\n            LOG.warn(\"Logger is disabled\");\n            returnValue = new TSOState(new TimestampOracle());\n        } else {\n            BookKeeperStateBuilder builder = new BookKeeperStateBuilder(config);\n            \n            try{\n                returnValue = builder.buildState();\n                LOG.info(\"State built\");\n            } catch (Throwable e) {\n                LOG.error(\"Error while building the state.\", e);\n                returnValue = null;\n            } finally {\n                builder.shutdown();\n            }\n        }\n        return returnValue;        \n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `com.yahoo.omid.tso.persistence.BookKeeperStateBuilder.getState` indirectly writes to field `tso.TSOServerConfig.com.yahoo.omid.tso.TSOServerConfig.config` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public static TSOState getState(TSOServerConfig config){\n        TSOState returnValue;\n        if(!config.isRecoveryEnabled()){\n            LOG.warn(\"Logger is disabled\");\n            returnValue = new TSOState(new TimestampOracle());\n        } else {\n            BookKeeperStateBuilder builder = new BookKeeperStateBuilder(config);\n            \n            try{\n                returnValue = builder.buildState();\n                LOG.info(\"State built\");\n            } catch (Throwable e) {\n                LOG.error(\"Error while building the state.\", e);\n                returnValue = null;\n            } finally {\n                builder.shutdown();\n            }\n        }\n        return returnValue;        \n    }", "LocalizedBug": "if(config.getZkServers() == null){", "LocalizedPatchLength": 34, "CodeLength": 720}
{"BuggyCode": "protected Packet callAndGetResult(Packet request) {\n\t\tCall c = createCall(request);\n\t    synchronized (c) {\n\t\t\ttry {\n\t\t\t\tout.enQueue(c);\n\t\t\t\tc.wait();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t    \n\t    Packet response = c.getResponse();\n\t\treturn response;\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `com.hazelcast.client.ClientProxy.callAndGetResult` indirectly writes to field `request.com.hazelcast.client.Packet.callId` outside of synchronization.\n Reporting because this access may occur on a background thread."}, "FixedCode": "protected Packet callAndGetResult(Packet request) {\n\t\tCall c = createCall(request);\n\t    return doCall(c);\n\t}", "LocalizedBug": "synchronized (c) {\ntry {\nout.enQueue(c);\nc.wait();\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n}\nPacket response = c.getResponse();\nreturn response;\n}", "LocalizedPatchLength": 164, "CodeLength": 290}
{"BuggyCode": "@BeforeClass\n    public static void setupClass() throws Exception {\n        // MockContextFactory becomes the primary JNDI provider\n        final StatusConsoleListener l = new StatusConsoleListener(Level.ERROR);\n        StatusLogger.getLogger().registerListener(l);\n        MockContextFactory.setAsInitial();\n        context = new InitialContext();\n        context.rebind(FACTORY_NAME, new QueueConnectionFactoryImpl() );\n        context.rebind(QUEUE_NAME, new MockQueue(QUEUE_NAME));\n        ((LoggerContext) LogManager.getContext()).reconfigure();\n        receiver = new JmsQueueReceiver(FACTORY_NAME, QUEUE_NAME, null, null);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.logging.log4j.status.StatusConsoleListener` acquired to `l` by call to `StatusConsoleListener(...)` at line 67 is not released after line 68."}, "FixedCode": "@BeforeClass\n    public static void setupClass() throws Exception {\n        // MockContextFactory becomes the primary JNDI provider\n        final StatusConsoleListener listener = new StatusConsoleListener(Level.ERROR);\n        StatusLogger.getLogger().registerListener(listener);\n        MockContextFactory.setAsInitial();\n        context = new InitialContext();\n        context.rebind(FACTORY_NAME, new QueueConnectionFactoryImpl() );\n        context.rebind(QUEUE_NAME, new MockQueue(QUEUE_NAME));\n        ((LoggerContext) LogManager.getContext()).reconfigure();\n        receiver = new JmsQueueReceiver(FACTORY_NAME, QUEUE_NAME, null, null);\n    }", "LocalizedBug": "final StatusConsoleListener l = new StatusConsoleListener(Level.ERROR);\nStatusLogger.getLogger().registerListener(l);", "LocalizedPatchLength": 117, "CodeLength": 634}
{"BuggyCode": "@Test\n\tpublic void TestWhitespace() throws IOException {\n\t\t//int [] recordBreaks = new int[] { 0, 57, 111, ,  };\n\t\tint[] rslt = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 222), true);\n\t\tAssert.assertEquals(4, rslt.length);\n\t\tint[] before = null, after = null;\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 56), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 56, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 57), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 57, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 58), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 58, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.InputStreamReader` acquired by call to `getReaderFor(...)` at line 100 is not released after line 100."}, "FixedCode": "@Test\n\tpublic void TestWhitespace() throws Exception {\n\t\t//int [] recordBreaks = new int[] { 0, 57, 111, ,  };\n\t\tint[] rslt = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 222), true);\n\t\tAssert.assertEquals(4, rslt.length);\n\t\tint[] before = null, after = null;\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 56), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 56, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 57), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 57, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 58), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 58, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t}", "LocalizedBug": "public void TestWhitespace() throws IOException {", "LocalizedPatchLength": 49, "CodeLength": 1032}
{"BuggyCode": "long getSequenceNumber() {\n        return sequenceNumber;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `amannaly.DBMetaData.getSequenceNumber` reads without synchronization from `this.amannaly.DBMetaData.sequenceNumber`. Potentially races with write in method `DBMetaData.loadFromFile()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "DBMetaData(String dbDirectory) {\n        this.dbDirectory = dbDirectory;\n    }", "LocalizedBug": "long getSequenceNumber() {\nreturn sequenceNumber;", "LocalizedPatchLength": 49, "CodeLength": 63}
{"BuggyCode": "public int reputation(final String uid) throws IOException {\n        if (!this.exists(uid)) {\n            throw new IllegalArgumentException(\n                new Par(\"Person @%s doesn't exist\").say(uid)\n            );\n        }\n        try (final Item item = this.item()) {\n            return new NumberOf(\n                new Xocument(item.path()).xpath(\n                    String.format(\n                        \"/people/person[@id='%s']/reputation/text()\",\n                        uid\n                    ),\n                    \"0\"\n                )\n            ).intValue();\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.farm.fake.FkFarm` acquired by call to `Par(...)` at line 682 is not released after line 683."}, "FixedCode": "public int reputation(final String uid) throws IOException {\n        this.checkExisting(uid);\n        try (final Item item = this.item()) {\n            return new NumberOf(\n                new Xocument(item.path()).xpath(\n                    String.format(\n                        \"/people/person[@id='%s']/reputation/text()\",\n                        uid\n                    ),\n                    \"0\"\n                )\n            ).intValue();\n        }\n    }", "LocalizedBug": "if (!this.exists(uid)) {\nthrow new IllegalArgumentException(\nnew Par(\"Person @%s doesn't exist\").say(uid)\n);\n}", "LocalizedPatchLength": 110, "CodeLength": 595}
{"BuggyCode": "@Override\n\tpublic void encodeChildren(FacesContext context) throws IOException {\n\t\tif (!TRUE.equals(getApplicationAttribute(context, Socket.class.getName()))) {\n\t\t\tthrow new IllegalStateException(ERROR_ENDPOINT_NOT_ENABLED);\n\t\t}\n\n\t\tString channel = getChannel();\n\n\t\tif (channel == null || !PATTERN_CHANNEL.matcher(channel).matches()) {\n\t\t\tthrow new IllegalArgumentException(String.format(ERROR_INVALID_CHANNEL, channel));\n\t\t}\n\n\t\tboolean connected = isConnected();\n\t\tBoolean switched = hasSwitched(context, channel, connected);\n\t\tString script = null;\n\n\t\tif (switched == null) {\n\t\t\tInteger port = getPort();\n\t\t\tString host = (port != null ? \":\" + port : \"\") + getRequestContextPath(context);\n\t\t\tString channelId = getReference(SocketChannelManager.class).register(channel, getScope(), getUser());\n\t\t\tString functions = getOnopen() + \",\" + getOnmessage() + \",\" + getOnclose();\n\t\t\tscript = String.format(SCRIPT_INIT, host, channelId, functions, getBehaviorScripts(), connected);\n\t\t}\n\t\telse if (switched) {\n\t\t\tscript = String.format(connected ? SCRIPT_OPEN : SCRIPT_CLOSE, channel);\n\t\t}\n\n\t\tif (script != null) {\n\t\t\tcontext.getResponseWriter().write(script);\n\t\t}\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getReference(org.omnifaces.cdi.push.SocketChannelManager,__new_array(java.lang.annotation.Annotation*[_*_]))` could be null and is dereferenced at line 743."}, "FixedCode": "@Override\n\tpublic void encodeChildren(FacesContext context) throws IOException {\n\t\tif (!TRUE.equals(getApplicationAttribute(context, Socket.class.getName()))) {\n\t\t\tthrow new IllegalStateException(ERROR_ENDPOINT_NOT_ENABLED);\n\t\t}\n\n\t\tString channel = getChannel();\n\n\t\tif (channel == null || !PATTERN_CHANNEL.matcher(channel).matches()) {\n\t\t\tthrow new IllegalArgumentException(String.format(ERROR_INVALID_CHANNEL, channel));\n\t\t}\n\n\t\tboolean connected = isConnected();\n\t\tBoolean switched = hasSwitched(context, channel, connected);\n\t\tString script = null;\n\n\t\tif (switched == null) {\n\t\t\tInteger port = getPort();\n\t\t\tString host = (port != null ? \":\" + port : \"\") + getRequestContextPath(context);\n\t\t\tString channelId = getReference(SocketChannelManager.class).register(channel, getScope(), getUser());\n\t\t\tString functions = getOnopen() + \",\" + getOnmessage() + \",\" + getOnclose();\n\t\t\tscript = String.format(SCRIPT_INIT, host, channelId, functions, getBehaviorScripts(), connected);\n\t\t}\n\t\telse if (switched) {\n\t\t\tscript = String.format(connected ? SCRIPT_OPEN : SCRIPT_CLOSE, channel);\n\t\t}\n\n\t\tif (script != null) {\n\t\t\tcontext.getResponseWriter().write(script);\n\t\t}\n\n\t\trendered = super.isRendered();\n\t}", "LocalizedBug": "}", "LocalizedPatchLength": 1, "CodeLength": 1160}
{"BuggyCode": "public InputStream openClassfile(String classname) {\n        try {\n            if (packageName == null || classname.startsWith(packageName)) {\n                String jarname\n                    = directory + classname.replace('.', '/') + \".class\";\n                URLConnection con = fetchClass0(hostname, port, jarname);\n                return con.getInputStream();\n            }\n        }\n        catch (IOException e) {}\n        return null;    // not found\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.net.HttpURLConnection` acquired by call to `fetchClass0(...)` at line 72 is not released after line 73."}, "FixedCode": "public InputStream openClassfile(String classname) {\n        try {\n            URLConnection con = openClassfile0(classname);\n            if (con != null)\n                return con.getInputStream();\n        }\n        catch (IOException e) {}\n        return null;        // not found\n    }", "LocalizedBug": "if (packageName == null || classname.startsWith(packageName)) {\nString jarname\n= directory + classname.replace('.', '/') + \".class\";\nURLConnection con = fetchClass0(hostname, port, jarname);\n}", "LocalizedPatchLength": 192, "CodeLength": 466}
{"BuggyCode": "@Override\n    protected Object createTest() throws Exception {\n        ensureHierarchicalFixturesAreValid();\n        return instances.getLast();\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `de.bechte.junit.runners.context.ContextHierarchyLevelClassRunner.createTest` reads without synchronization from `this.de.bechte.junit.runners.context.ContextHierarchyLevelClassRunner.instances`. Potentially races with write in method `ContextHierarchyLevelClassRunner.ensureHierarchicalFixturesAreValid()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n    protected Object createTest() throws Exception {\n        instances = createHierarchicalFixtures();\n        return instances.getLast();\n    }", "LocalizedBug": "ensureHierarchicalFixturesAreValid();", "LocalizedPatchLength": 37, "CodeLength": 150}
{"BuggyCode": "private String getUrlContents(String urlString) throws Exception {\n    System.setProperty (\"jsse.enableSNIExtension\", \"false\");\n    URL url = new URL(urlString);\n    BufferedReader in = new BufferedReader(\n      new InputStreamReader(url.openStream()));\n\n    String inputLine;\n    StringBuilder contents = new StringBuilder();\n    while ((inputLine = in.readLine()) != null)\n      contents.append(inputLine);\n    in.close();\n    return contents.toString();\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 232 is not released after line 239.\n**Note**: potential exception at line 236"}, "FixedCode": "private String getUrlContents(String urlString) throws Exception {\n    System.setProperty (\"jsse.enableSNIExtension\", \"false\");\n\n    URL url = new URL(urlString);\n\n    URLConnection urlc = url.openConnection();\n    urlc.setRequestProperty(\"Accept\", \"application/json, */*\");\n    urlc.connect();\n\n    StringBuilder contents = new StringBuilder();\n    InputStream in = urlc.getInputStream();\n    for(int i = 0;i!= -1;i= in.read()){\n      char c = (char)i;\n      if(!Character.isISOControl(c))\n        contents.append((char)i);\n    }\n    in.close();\n\n    return contents.toString();\n  }", "LocalizedBug": "BufferedReader in = new BufferedReader(\nnew InputStreamReader(url.openStream()));\nString inputLine;\nwhile ((inputLine = in.readLine()) != null)\ncontents.append(inputLine);", "LocalizedPatchLength": 171, "CodeLength": 460}
{"BuggyCode": "public int launch() throws Throwable {\n        int returnCode = -1;\n        Thread t = Thread.currentThread();\n        String currentThreadName = t.getName();\n        t.setName(\"Executing \"+ env.displayName());\n        before();\n        try {\n            // so that test code has all the access to the system\n            ACL.impersonate(ACL.SYSTEM);\n            ClassLoader cl = new ClassLoaderBuilder(jenkins.getPluginManager().uberClassLoader)\n                    .collectJars(new File(bootstrap.appRepo, \"io/jenkins/jenkinsfile-runner/payload\"))\n                    .make();\n\n            Class<?> c = cl.loadClass(\"io.jenkins.jenkinsfile.runner.Runner\");\n            returnCode = (int)c.getMethod(\"run\", Bootstrap.class).invoke(c.newInstance(), bootstrap);\n        } finally {\n            after();\n            t.setName(currentThreadName);\n        }\n\n        return returnCode;\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.net.URLClassLoader` acquired by call to `make()` at line 130 is not released after line 132."}, "FixedCode": "public int launch() throws Throwable {\n        int returnCode = -1;\n        Thread t = Thread.currentThread();\n        String currentThreadName = t.getName();\n        t.setName(\"Executing \"+ env.displayName());\n        before();\n        try {\n            // so that test code has all the access to the system\n            ACL.impersonate(ACL.SYSTEM);\n            Class<?> c = bootstrap.hasClass(RUNNER_CLASS_NAME)? Class.forName(RUNNER_CLASS_NAME) : getRunnerClassFromJar();\n            returnCode = (int)c.getMethod(\"run\", Bootstrap.class).invoke(c.newInstance(), bootstrap);\n        } finally {\n            after();\n            t.setName(currentThreadName);\n        }\n\n        return returnCode;\n    }", "LocalizedBug": "ClassLoader cl = new ClassLoaderBuilder(jenkins.getPluginManager().uberClassLoader)\n.collectJars(new File(bootstrap.appRepo, \"io/jenkins/jenkinsfile-runner/payload\"))\n.make();\nClass<?> c = cl.loadClass(\"io.jenkins.jenkinsfile.runner.Runner\");", "LocalizedPatchLength": 242, "CodeLength": 886}
{"BuggyCode": "public static PublicSuffixMatcher load(final URL url) throws IOException {\n        Args.notNull(url, \"URL\");\n        final InputStream in = url.openStream();\n        try {\n            final PublicSuffixList list = new PublicSuffixListParser().parse(\n                    new InputStreamReader(in, Consts.UTF_8));\n            return new PublicSuffixMatcher(list.getRules(), list.getExceptions());\n        } finally {\n            in.close();\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 51 is not released after line 51.\n**Note**: potential exception at line 51"}, "FixedCode": "public static PublicSuffixMatcher load(final URL url) throws IOException {\n        Args.notNull(url, \"URL\");\n        final InputStream in = url.openStream();\n        try {\n            return load(in);\n        } finally {\n            in.close();\n        }\n    }", "LocalizedBug": "final PublicSuffixList list = new PublicSuffixListParser().parse(\nnew InputStreamReader(in, Consts.UTF_8));\nreturn new PublicSuffixMatcher(list.getRules(), list.getExceptions());", "LocalizedPatchLength": 178, "CodeLength": 454}
{"BuggyCode": "public JSONObject getInfo() throws EvtSdkException {\n        Info info = new Info();\n        return info.get(netParams, null);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `null` could be null and is dereferenced by call to `get(...)` at line 28."}, "FixedCode": "public JSONObject getInfo() throws EvtSdkException {\n        Info info = new Info();\n        return info.get(RequestParams.of(netParams));\n    }", "LocalizedBug": "return info.get(netParams, null);", "LocalizedPatchLength": 33, "CodeLength": 132}
{"BuggyCode": "public void fetchLogs() {\n        try {\n            callback.open();\n            this.request = getLogRequest(false);\n            final HttpResponse respone = client.execute(request);\n            parseResponse(respone);\n        } catch (LogCallback.DoneException e) {\n            finish();\n        } catch (IOException exp) {\n            callback.error(exp.getMessage());\n        } finally {\n            callback.close();\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `io.fabric8.maven.docker.access.log.LogRequestor.fetchLogs` indirectly writes to field `this.io.fabric8.maven.docker.access.log.LogRequestor.exception` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public void fetchLogs() {\n        try {\n            callback.open();\n            this.request = getLogRequest(false);\n            final HttpResponse response = client.execute(request);\n            parseResponse(response);\n        } catch (LogCallback.DoneException e) {\n            // Signifies we're finished with the log stream.\n        } catch (IOException exp) {\n            callback.error(exp.getMessage());\n        } finally {\n            callback.close();\n        }\n    }", "LocalizedBug": "final HttpResponse respone = client.execute(request);\nparseResponse(respone);\nfinish();", "LocalizedPatchLength": 87, "CodeLength": 437}
{"BuggyCode": "public void atBinExpr(BinExpr expr) throws CompileError {\n        int token = expr.getOperator();\n        int k = CodeGen.lookupBinOp(token);\n        if (k >= 0) {\n            /* arithmetic operators: +, -, *, /, %, |, ^, &, <<, >>, >>>\n             */\n            if (token == '+') {\n                Expr e = atPlusExpr(expr);\n                if (e != null) {\n                    /* String concatenation has been translated into\n                     * an expression using StringBuffer.\n                     */\n                    e = CallExpr.makeCall(Expr.make('.', e,\n                                            new Member(\"toString\")), null);\n                    expr.setLeft(e);\n                    expr.setOprand2(null);    // <---- look at this!\n                    className = jvmJavaLangString;\n                }\n            }\n            else {\n                expr.oprand1().accept(this);\n                int type1 = exprType;\n                expr.oprand2().accept(this);\n                computeBinExprType(expr, token, type1);\n            }\n        }\n        else {\n            /* equation: &&, ||, ==, !=, <=, >=, <, >\n            */\n            booleanExpr(expr);\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `expr.oprand2()` could be null and is dereferenced at line 252."}, "FixedCode": "public void atBinExpr(BinExpr expr) throws CompileError {\n        int token = expr.getOperator();\n        int k = CodeGen.lookupBinOp(token);\n        if (k >= 0) {\n            /* arithmetic operators: +, -, *, /, %, |, ^, &, <<, >>, >>>\n             */\n            if (token == '+') {\n                Expr e = atPlusExpr(expr);\n                if (e != null) {\n                    /* String concatenation has been translated into\n                     * an expression using StringBuffer.\n                     */\n                    e = CallExpr.makeCall(Expr.make('.', e,\n                                            new Member(\"toString\")), null);\n                    expr.setOprand1(e);\n                    expr.setOprand2(null);    // <---- look at this!\n                    className = jvmJavaLangString;\n                }\n            }\n            else {\n                ASTree left = expr.oprand1();\n                ASTree right = expr.oprand2();\n                left.accept(this);\n                int type1 = exprType;\n                right.accept(this);\n                if (!isConstant(expr, token, left, right))\n                    computeBinExprType(expr, token, type1);\n            }\n        }\n        else {\n            /* equation: &&, ||, ==, !=, <=, >=, <, >\n            */\n            booleanExpr(expr);\n        }\n    }", "LocalizedBug": "expr.setLeft(e);\nexpr.oprand2().accept(this);", "LocalizedPatchLength": 45, "CodeLength": 1193}
{"BuggyCode": "@Test\n\tpublic void writeXml_missing_both() {\n\t\tGeo prop = new Geo(null, null);\n\n\t\tDocument actual = xcalProperty(marshaller);\n\t\tmarshaller.writeXml(prop, XmlUtils.getRootElement(actual));\n\n\t\tDocument expected = xcalProperty(marshaller, \"\");\n\t\tassertXMLEqual(expected, actual);\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getRootElement(actual)` could be null and is dereferenced by call to `writeXml(...)` at line 168."}, "FixedCode": "@Test\n\tpublic void writeXml_missing_both() {\n\t\tGeo prop = new Geo(null, null);\n\t\tassertWriteXml(\"\", prop, marshaller);\n\t}", "LocalizedBug": "Document actual = xcalProperty(marshaller);\nmarshaller.writeXml(prop, XmlUtils.getRootElement(actual));\nDocument expected = xcalProperty(marshaller, \"\");\nassertXMLEqual(expected, actual);", "LocalizedPatchLength": 187, "CodeLength": 279}
{"BuggyCode": "@Test\n    public void dbRefWithObjectIdShouldBeSavedAsDbRef() {\n        JacksonDBCollection<ObjectIdOwner, String> coll = getCollection(ObjectIdOwner.class, String.class);\n        JacksonDBCollection<ObjectIdReferenced, byte[]> refColl = getCollection(ObjectIdReferenced.class, byte[].class);\n\n        byte[] refId = refColl.insert(new ObjectIdReferenced(10)).getSavedId();\n        String id = coll.insert(new ObjectIdOwner(new DBRef<ObjectIdReferenced, byte[]>(refId, refColl.getName()))).getSavedId();\n\n        ObjectIdOwner saved = coll.findOneById(id);\n        assertThat(saved.ref, notNullValue());\n        assertThat(saved.ref.getId(), equalTo(refId));\n        assertThat(saved.ref.getCollectionName(), equalTo(refColl.getName()));\n\n        // Try loading it\n        ObjectIdReferenced ref = saved.ref.fetch();\n        assertThat(ref, notNullValue());\n        assertThat(ref._id, equalTo(refId));\n        assertThat(ref.i, equalTo(10));\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `saved` last assigned on line 60 could be null and is dereferenced at line 61."}, "FixedCode": "@Test\n    public void dbRefWithObjectIdShouldBeSavedAsDbRef() {\n        JacksonDBCollection<ObjectIdOwner, String> coll = getCollection(ObjectIdOwner.class, String.class);\n        JacksonDBCollection<ObjectIdReferenced, byte[]> refColl = getCollection(ObjectIdReferenced.class, byte[].class);\n\n        byte[] refId = new org.bson.types.ObjectId().toByteArray();\n        refColl.insert(new ObjectIdReferenced(refId, 10));\n        coll.insert(new ObjectIdOwner(new DBRef<ObjectIdReferenced, byte[]>(refId, refColl.getName())));\n        String id = coll.findOne()._id;\n\n        ObjectIdOwner saved = coll.findOneById(id);\n        assertThat(saved.ref, notNullValue());\n        assertThat(saved.ref.getId(), equalTo(refId));\n        assertThat(saved.ref.getCollectionName(), equalTo(refColl.getName()));\n\n        // Try loading it\n        ObjectIdReferenced ref = saved.ref.fetch();\n        assertThat(ref, notNullValue());\n        assertThat(ref._id, equalTo(refId));\n        assertThat(ref.i, equalTo(10));\n    }", "LocalizedBug": "byte[] refId = refColl.insert(new ObjectIdReferenced(10)).getSavedId();\nString id = coll.insert(new ObjectIdOwner(new DBRef<ObjectIdReferenced, byte[]>(refId, refColl.getName()))).getSavedId();", "LocalizedPatchLength": 193, "CodeLength": 948}
{"BuggyCode": "@Test\n\tpublic void TestWhitespace() throws IOException {\n\t\t//int [] recordBreaks = new int[] { 0, 57, 111, ,  };\n\t\tint[] rslt = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 222), true);\n\t\tAssert.assertEquals(4, rslt.length);\n\t\tint[] before = null, after = null;\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 56), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 56, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 57), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 57, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 58), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 58, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.InputStreamReader` acquired by call to `getReaderFor(...)` at line 96 is not released after line 96."}, "FixedCode": "@Test\n\tpublic void TestWhitespace() throws Exception {\n\t\t//int [] recordBreaks = new int[] { 0, 57, 111, ,  };\n\t\tint[] rslt = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 222), true);\n\t\tAssert.assertEquals(4, rslt.length);\n\t\tint[] before = null, after = null;\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 56), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 56, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 57), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 57, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t\tbefore = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 0, 58), true);\n\t\tafter = getRecordIndexesInReader(getReaderFor(\"unenclosed-json-return.json\", 58, 222), true);\n\t\tAssert.assertEquals(4, before.length + after.length);\n\t}", "LocalizedBug": "public void TestWhitespace() throws IOException {", "LocalizedPatchLength": 49, "CodeLength": 1032}
{"BuggyCode": "private void escapeParameters(MustDef output) {\n    for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n      Var v = i.next();\n      if (v.getParentNode().getType() == Token.LP) {\n        // Assume we no longer know where the parameter comes from\n        // anymore.\n        output.reachingDef.put(v, null);\n      }\n    }\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `v.getParentNode()` could be null and is dereferenced at line 358."}, "FixedCode": "private void escapeParameters(MustDef output) {\n    for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n      Var v = i.next();\n      if (isParameter(v)) {\n        // Assume we no longer know where the parameter comes from\n        // anymore.\n        output.reachingDef.put(v, null);\n      }\n    }\n\n    // Also, assume we no longer know anything that depends on a parameter.\n    for (Entry<Var, Definition> pair: output.reachingDef.entrySet()) {\n      Definition value = pair.getValue();\n      if (value == null) {\n        continue;\n      }\n      for (Var dep : value.depends) {\n        if (isParameter(dep)) {\n          output.reachingDef.put(pair.getKey(), null);\n        }\n      }\n    }\n  }", "LocalizedBug": "if (v.getParentNode().getType() == Token.LP) {", "LocalizedPatchLength": 46, "CodeLength": 332}
{"BuggyCode": "public static boolean execute(final File source, final File destination, final boolean deleteSource)\n        throws IOException {\n        if (source.exists()) {\n            final FileInputStream fis = new FileInputStream(source);\n            final FileOutputStream fos = new FileOutputStream(destination);\n            final GZIPOutputStream gzos = new GZIPOutputStream(fos);\n            final BufferedOutputStream os = new BufferedOutputStream(gzos);\n            final byte[] inbuf = new byte[BUF_SIZE];\n            int n;\n\n            while ((n = fis.read(inbuf)) != -1) {\n                os.write(inbuf, 0, n);\n            }\n\n            os.close();\n            fis.close();\n\n            if (deleteSource && !source.delete()) {\n                LOGGER.warn(\"Unable to delete \" + source.toString() + '.');\n            }\n\n            return true;\n        }\n\n        return false;\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileInputStream` acquired to `fis` by call to `FileInputStream(...)` at line 94 is not released after line 115.\n**Note**: potential exception at line 101"}, "FixedCode": "public static boolean execute(final File source, final File destination, final boolean deleteSource)\n            throws IOException {\n        if (source.exists()) {\n            try (final FileInputStream fis = new FileInputStream(source);\n                    final BufferedOutputStream os = new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream(\n                            destination)))) {\n                final byte[] inbuf = new byte[BUF_SIZE];\n                int n;\n\n                while ((n = fis.read(inbuf)) != -1) {\n                    os.write(inbuf, 0, n);\n                }\n            }\n\n            if (deleteSource && !source.delete()) {\n                LOGGER.warn(\"Unable to delete \" + source.toString() + '.');\n            }\n\n            return true;\n        }\n\n        return false;\n    }", "LocalizedBug": "final FileOutputStream fos = new FileOutputStream(destination);\nfinal GZIPOutputStream gzos = new GZIPOutputStream(fos);\nfinal BufferedOutputStream os = new BufferedOutputStream(gzos);\nos.close();\nfis.close();", "LocalizedPatchLength": 209, "CodeLength": 884}
{"BuggyCode": "@Test\n    public void finishSpan_userSuppliedDuration() {\n        Span finished = new Span().setTimestamp(1000L); // set in start span\n        finished.startTick = 500L; // set in start span\n        state.setCurrentLocalSpan(finished);\n\n        localTracer.finishSpan(500L);\n\n        verify(mockCollector).collect(finished);\n        verifyNoMoreInteractions(mockCollector);\n\n        assertEquals(500L, finished.getDuration().longValue());\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `finished.getDuration()` could be null and is dereferenced at line 210."}, "FixedCode": "@Test\n    public void finishSpan_userSuppliedDuration() {\n        Span finished = new Span().setName(\"foo\").setTimestamp(1000L); // set in start span\n        finished.startTick = 500L; // set in start span\n        state.setCurrentLocalSpan(finished);\n\n        localTracer.finishSpan(500L);\n\n        verify(mockReporter).report(finished.toZipkin());\n        verifyNoMoreInteractions(mockReporter);\n\n        assertEquals(500L, finished.getDuration().longValue());\n    }", "LocalizedBug": "verify(mockCollector).collect(finished);\nverifyNoMoreInteractions(mockCollector);", "LocalizedPatchLength": 81, "CodeLength": 444}
{"BuggyCode": "private void populateReadWriteMaps() {\n        // Although the field names say \"PerSec\" this is the Raw Data from which\n        // the associated fields are populated in the Formatted Data class, so\n        // in fact this is the data we want\n        Map<String, List<String>> vals = WmiUtil.selectStringsFrom(null, \"Win32_PerfRawData_PerfDisk_PhysicalDisk\",\n                \"Name,DiskReadBytesPerSec,DiskWriteBytesPerSec\", null);\n        for (int i = 0; i < vals.get(\"Name\").size(); i++) {\n            String index = vals.get(\"Name\").get(i).split(\"\\\\s+\")[0];\n            readMap.put(index, ParseUtil.parseLongOrDefault(vals.get(\"DiskReadBytesPerSec\").get(i), 0L));\n            writeMap.put(index, ParseUtil.parseLongOrDefault(vals.get(\"DiskWriteBytesPerSec\").get(i), 0L));\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `vals.get(\"Name\")` could be null and is dereferenced at line 82."}, "FixedCode": "private void populateReadWriteMaps() {\n        // Although the field names say \"PerSec\" this is the Raw Data from which\n        // the associated fields are populated in the Formatted Data class, so\n        // in fact this is the data we want\n        Map<String, List<Object>> vals = WmiUtil.selectObjectsFrom(null, \"Win32_PerfRawData_PerfDisk_PhysicalDisk\",\n                \"Name,DiskReadsPerSec,DiskReadBytesPerSec,DiskWritesPerSec,DiskWriteBytesPerSec,PercentDiskTime\", null,\n                READ_WRITE_TYPES);\n        for (int i = 0; i < vals.get(\"Name\").size(); i++) {\n            String index = ((String) vals.get(\"Name\").get(i)).split(\"\\\\s+\")[0];\n            readMap.put(index, (long) vals.get(\"DiskReadsPerSec\").get(i));\n            readByteMap.put(index, ParseUtil.parseLongOrDefault((String) vals.get(\"DiskReadBytesPerSec\").get(i), 0L));\n            writeMap.put(index, (long) vals.get(\"DiskWritesPerSec\").get(i));\n            writeByteMap.put(index, ParseUtil.parseLongOrDefault((String) vals.get(\"DiskWriteBytesPerSec\").get(i), 0L));\n            // Units are 100-ns, divide to get ms\n            xferTimeMap.put(index,\n                    ParseUtil.parseLongOrDefault((String) vals.get(\"PercentDiskTime\").get(i), 0L) / 10000L);\n        }\n    }", "LocalizedBug": "Map<String, List<String>> vals = WmiUtil.selectStringsFrom(null, \"Win32_PerfRawData_PerfDisk_PhysicalDisk\",", "LocalizedPatchLength": 107, "CodeLength": 789}
{"BuggyCode": "private static char[] readPassword(String msg) {\n\t\tConsole console = System.console();\n\n\t\tif (console != null) {\n\t\t\treturn console.readPassword(msg);\n\n\t\t} else {\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tU.print(msg);\n\t\t\ttry {\n\t\t\t\treturn reader.readLine().toCharArray();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow U.rte(e);\n\t\t\t}\n\t\t}\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 76 is not released after line 79."}, "FixedCode": "private static char[] readPassword(String msg) {\n\t\tConsole console = System.console();\n\n\t\tif (console != null) {\n\t\t\treturn console.readPassword(msg);\n\n\t\t} else {\n\t\t\tU.print(msg);\n\t\t\treturn readLine().toCharArray();\n\t\t}\n\t}", "LocalizedBug": "BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\ntry {\nreturn reader.readLine().toCharArray();\n} catch (IOException e) {\nthrow U.rte(e);\n}\n}", "LocalizedPatchLength": 169, "CodeLength": 373}
{"BuggyCode": "boolean wasPending (kvmsg msg)\n    {\n        Iterator<kvmsg> it = pending.iterator();\n        while (it.hasNext()) {\n            if (msg.UUID().equals(it.next().UUID())) {\n                it.remove();\n                return true;\n            }\n\n        }\n        return false;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `msg.UUID()` could be null and is dereferenced at line 373."}, "FixedCode": "boolean wasPending (kvmsg msg)\n    {\n        Iterator<kvmsg> it = pending.iterator();\n        while (it.hasNext()) {\n            if(java.util.Arrays.equals(msg.UUID(), it.next().UUID())){\n                it.remove();\n                return true;\n            }\n\n        }\n        return false;\n    }", "LocalizedBug": "if (msg.UUID().equals(it.next().UUID())) {", "LocalizedPatchLength": 42, "CodeLength": 282}
{"BuggyCode": "@Test\n    public void testZeroLengthDecoding() throws Exception {\n        ReadableByteChannel channel = new ReadableByteChannelMockup(\n                new String[] {\"stuff\"}, \"US-ASCII\");\n        HttpParams params = new BasicHttpParams();\n\n        SessionInputBuffer inbuf = new SessionInputBufferImpl(1024, 256, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedDecoder decoder = new LengthDelimitedDecoder(\n                channel, inbuf, metrics, 0);\n\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n\n        int bytesRead = decoder.read(dst);\n        Assert.assertEquals(-1, bytesRead);\n        Assert.assertTrue(decoder.isCompleted());\n        Assert.assertEquals(0, metrics.getBytesTransferred());\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.http.ReadableByteChannelMockup` acquired by call to `new()` at line 505 is not released after line 518."}, "FixedCode": "@Test\n    public void testZeroLengthDecoding() throws Exception {\n        ReadableByteChannel channel = new ReadableByteChannelMock(\n                new String[] {\"stuff\"}, \"US-ASCII\");\n        HttpParams params = new BasicHttpParams();\n\n        SessionInputBuffer inbuf = new SessionInputBufferImpl(1024, 256, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedDecoder decoder = new LengthDelimitedDecoder(\n                channel, inbuf, metrics, 0);\n\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n\n        int bytesRead = decoder.read(dst);\n        Assert.assertEquals(-1, bytesRead);\n        Assert.assertTrue(decoder.isCompleted());\n        Assert.assertEquals(0, metrics.getBytesTransferred());\n    }", "LocalizedBug": "ReadableByteChannel channel = new ReadableByteChannelMockup(", "LocalizedPatchLength": 60, "CodeLength": 770}
{"BuggyCode": "public static void getTraceMask(String host, int port) {\n        try {\n            byte[] reqBytes = new byte[12];\n            ByteBuffer req = ByteBuffer.wrap(reqBytes);\n            req.putInt(ByteBuffer.wrap(\"gtmk\".getBytes()).getInt());\n\n            Socket s = null;\n            s = new Socket();\n            s.setSoLinger(false, 10);\n            s.setSoTimeout(20000);\n            s.connect(new InetSocketAddress(host, port));\n\n            InputStream is = s.getInputStream();\n            OutputStream os = s.getOutputStream();\n\n            os.write(reqBytes);\n\n            byte[] resBytes = new byte[8];\n\n            int rc = is.read(resBytes);\n            ByteBuffer res = ByteBuffer.wrap(resBytes);\n            long retv = res.getLong();\n            System.out.println(\"rc=\" + rc + \" retv=0\"\n                    + Long.toOctalString(retv));\n        } catch (IOException ioe) {\n            LOG.warn(\"Unexpected exception\", ioe);\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.InputStream` acquired to `is` by call to `Socket()` at line 211 is not released after line 223."}, "FixedCode": "public static void getTraceMask(String host, int port) {\n        Socket s = null;\n        try {\n            byte[] reqBytes = new byte[12];\n            ByteBuffer req = ByteBuffer.wrap(reqBytes);\n            req.putInt(ByteBuffer.wrap(\"gtmk\".getBytes()).getInt());\n\n            s = new Socket();\n            s.setSoLinger(false, 10);\n            s.setSoTimeout(20000);\n            s.connect(new InetSocketAddress(host, port));\n\n            InputStream is = s.getInputStream();\n            OutputStream os = s.getOutputStream();\n\n            os.write(reqBytes);\n\n            byte[] resBytes = new byte[8];\n\n            int rc = is.read(resBytes);\n            ByteBuffer res = ByteBuffer.wrap(resBytes);\n            long retv = res.getLong();\n            System.out.println(\"rc=\" + rc + \" retv=0\"\n                    + Long.toOctalString(retv));\n        } catch (IOException e) {\n            LOG.warn(\"Unexpected exception\", e);\n        } finally {\n            if (s != null) {\n                try {\n                    s.close();\n                } catch (IOException e) {\n                    LOG.warn(\"Unexpected exception\", e);\n                }\n            }\n        }\n    }", "LocalizedBug": "req.putInt(ByteBuffer.wrap(\"gtmk\".getBytes()).getInt());\nSocket s = null;\n} catch (IOException ioe) {\nLOG.warn(\"Unexpected exception\", ioe);\n}\n}", "LocalizedPatchLength": 144, "CodeLength": 950}
{"BuggyCode": "public static String getCompileDate() {\n        String ret = \"\";\n        try {\n            Date d = new Date(Main.class.getResource(\"Main.class\").openConnection().getLastModified());\n            ret = Konstanten.PROGRAMMNAME + \" \" + Konstanten.VERSION + \"  [Buildnummer: \" + getBuildNr() + \"] - Compiled: \" + new SimpleDateFormat(\"dd.MM.yyyy, HH:mm\").format(d);\n        } catch (Exception ex) {\n            Log.fehlerMeldung(569614756, \"Log.getCompileDate: \", ex);\n        }\n        return ret;\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 50 is not released after line 50."}, "FixedCode": "public static String getCompileDate() {\n//        String ret = \"\";\n//        try {\n//            Date d = new Date(Main.class.getResource(\"Main.class\").openConnection().getLastModified());\n//            ret = Konstanten.PROGRAMMNAME + \" \" + Konstanten.VERSION + \"  [Buildnummer: \" + getBuildNr() + \"] - Compiled: \" + new SimpleDateFormat(\"dd.MM.yyyy, HH:mm\").format(d);\n//        } catch (Exception ex) {\n//            Log.fehlerMeldung(569614756, \"Log.getCompileDate: \", ex);\n//        }\n//        return ret;\n        final ResourceBundle rb;\n        String propToken = \"BUILDDATE\";\n        String msg = \"\";\n        try {\n            ResourceBundle.clearCache();\n            rb = ResourceBundle.getBundle(\"version\");\n            msg = rb.getString(propToken);\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n            System.err.println(\"Token \" + propToken + \" not in Propertyfile!\");\n        }\n        return Konstanten.PROGRAMMNAME + \" \" + Konstanten.VERSION + \"  [Buildnummer: \" + getBuildNr() + \"] - Compiled: \" + msg;\n    }", "LocalizedBug": "}\n}", "LocalizedPatchLength": 3, "CodeLength": 500}
{"BuggyCode": "@Test\n    public void testChecksumNONE() throws Exception {\n        EventDeserializer eventDeserializer = new EventDeserializer();\n        BinaryLogFileReader reader = new BinaryLogFileReader(new GZIPInputStream(\n                new FileInputStream(\"src/test/resources/mysql-bin.sakila.gz\")), eventDeserializer);\n        readAll(reader, 1462);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 51 is not released after line 51."}, "FixedCode": "@Test\n    public void testChecksumNONE() throws Exception {\n        EventDeserializer eventDeserializer = new EventDeserializer();\n        BinaryLogFileReader reader = new BinaryLogFileReader(\n                new FileInputStream(\"src/test/resources/mysql-bin.checksum-none\"), eventDeserializer);\n        readAll(reader, 191);\n    }", "LocalizedBug": "BinaryLogFileReader reader = new BinaryLogFileReader(new GZIPInputStream(\nnew FileInputStream(\"src/test/resources/mysql-bin.sakila.gz\")), eventDeserializer);\nreadAll(reader, 1462);", "LocalizedPatchLength": 180, "CodeLength": 349}
{"BuggyCode": "@Override\n    public int accept(int... httpStatus) throws AcmeException {\n        assertConnectionIsOpen();\n\n        try {\n            int rc = conn.getResponseCode();\n            OptionalInt match = Arrays.stream(httpStatus).filter(s -> s == rc).findFirst();\n            if (match.isPresent()) {\n                return match.getAsInt();\n            }\n\n            if (!\"application/problem+json\".equals(conn.getHeaderField(CONTENT_TYPE_HEADER))) {\n                throw new AcmeException(\"HTTP \" + rc + \": \" + conn.getResponseMessage());\n            }\n\n            JSON json = readJsonResponse();\n\n            if (rc == HttpURLConnection.HTTP_CONFLICT) {\n                throw new AcmeConflictException(json.get(\"detail\").asString(), getLocation());\n            }\n\n            throw createAcmeException(json);\n        } catch (IOException ex) {\n            throw new AcmeNetworkException(ex);\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `json` last assigned on line 241 could be null and is dereferenced at line 244."}, "FixedCode": "@Override\n    public int accept(int... httpStatus) throws AcmeException {\n        assertConnectionIsOpen();\n\n        try {\n            int rc = conn.getResponseCode();\n            OptionalInt match = Arrays.stream(httpStatus).filter(s -> s == rc).findFirst();\n            if (match.isPresent()) {\n                return match.getAsInt();\n            }\n\n            if (!\"application/problem+json\".equals(conn.getHeaderField(CONTENT_TYPE_HEADER))) {\n                throw new AcmeException(\"HTTP \" + rc + \": \" + conn.getResponseMessage());\n            }\n\n            throw createAcmeException(readJsonResponse());\n        } catch (IOException ex) {\n            throw new AcmeNetworkException(ex);\n        }\n    }", "LocalizedBug": "JSON json = readJsonResponse();\nif (rc == HttpURLConnection.HTTP_CONFLICT) {\nthrow new AcmeConflictException(json.get(\"detail\").asString(), getLocation());\n}\nthrow createAcmeException(json);", "LocalizedPatchLength": 190, "CodeLength": 909}
{"BuggyCode": "@Test\n    public void testEntriesNeg55To105InRrd() throws IOException, FontFormatException {\n        createGaugeRrd(165);\n        RrdDb rrd = new RrdDb(jrbFileName);\n\n        for(int i=0; i<160; i++) {\n            long timestamp = startTime + 1 + (i * 60);\n            Sample sample = rrd.createSample();\n            sample.setAndUpdate(timestamp + \":\" + (i -55));\n        }\n        rrd.close();\n        prepareGraph();\n        /**\n         * Prior to JRB-12 fix, this was the behaviour.  Note the lack of a decent negative label\n                expectMinorGridLines(3);\n                expectMajorGridLine(\"   0\");\n                expectMinorGridLines(4);\n                expectMajorGridLine(\" 100\");\n                expectMinorGridLines(1);\n         */\n        //New behaviour is better; no minor grid lines, which is interesting, but much better representation\n        expectMajorGridLine(\" -50\");\n        expectMajorGridLine(\"   0\");\n        expectMajorGridLine(\"  50\");\n        expectMajorGridLine(\" 100\");\n\n        run();\n\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.rrd4j.core.RrdDb` acquired to `rrd` by call to `RrdDb(...)` at line 207 is not released after line 232.\n**Note**: potential exception at line 212"}, "FixedCode": "@Test\n    public void testEntriesNeg55To105InRrd() throws IOException, FontFormatException {\n        createGaugeRrd(165);\n        RrdDb rrd = RrdDb.getBuilder().setPath(jrbFileName).build();\n\n        for(int i=0; i<160; i++) {\n            long timestamp = startTime + 1 + (i * 60);\n            Sample sample = rrd.createSample();\n            sample.setAndUpdate(timestamp + \":\" + (i -55));\n        }\n        rrd.close();\n        prepareGraph();\n        /**\n         * Prior to JRB-12 fix, this was the behaviour.  Note the lack of a decent negative label\n                expectMinorGridLines(3);\n                expectMajorGridLine(\"   0\");\n                expectMinorGridLines(4);\n                expectMajorGridLine(\" 100\");\n                expectMinorGridLines(1);\n         */\n        //New behaviour is better; no minor grid lines, which is interesting, but much better representation\n        expectMajorGridLine(\" -50\");\n        expectMajorGridLine(\"   0\");\n        expectMajorGridLine(\"  50\");\n        expectMajorGridLine(\" 100\");\n\n        run();\n\n    }", "LocalizedBug": "RrdDb rrd = new RrdDb(jrbFileName);", "LocalizedPatchLength": 35, "CodeLength": 1034}
{"BuggyCode": "public void testReadLookahead2() throws Exception {\n        char[] ref = new char[5];\n        char[] res = new char[5];\n\n        ExtendedBufferedReader br = getEBR(\"\");\n        assertEquals(0, br.read(res, 0, 0));\n        assertTrue(Arrays.equals(res, ref));\n\n        br = getEBR(\"abcdefg\");\n        ref[0] = 'a';\n        ref[1] = 'b';\n        ref[2] = 'c';\n        assertEquals(3, br.read(res, 0, 3));\n        assertTrue(Arrays.equals(res, ref));\n        assertEquals('c', br.readAgain());\n\n        assertEquals('d', br.lookAhead());\n        ref[4] = 'd';\n        assertEquals(1, br.read(res, 4, 1));\n        assertTrue(Arrays.equals(res, ref));\n        assertEquals('d', br.readAgain());\n\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.commons.csv.ExtendedBufferedReader` acquired to `br` by call to `getEBR(...)` at line 90 is not released after line 104.\n**Note**: potential exception at line 98"}, "FixedCode": "public void testReadLookahead2() throws Exception {\n        char[] ref = new char[5];\n        char[] res = new char[5];\n        \n        ExtendedBufferedReader br = getBufferedReader(\"abcdefg\");\n        ref[0] = 'a';\n        ref[1] = 'b';\n        ref[2] = 'c';\n        assertEquals(3, br.read(res, 0, 3));\n        assertTrue(Arrays.equals(res, ref));\n        assertEquals('c', br.readAgain());\n\n        assertEquals('d', br.lookAhead());\n        ref[4] = 'd';\n        assertEquals(1, br.read(res, 4, 1));\n        assertTrue(Arrays.equals(res, ref));\n        assertEquals('d', br.readAgain());\n    }", "LocalizedBug": "ExtendedBufferedReader br = getEBR(\"\");\nassertEquals(0, br.read(res, 0, 0));\nassertTrue(Arrays.equals(res, ref));\nbr = getEBR(\"abcdefg\");", "LocalizedPatchLength": 137, "CodeLength": 696}
{"BuggyCode": "@Test\n\tpublic void should_run_post_build() {\n\t\tConfigSection afterRunSection = new AfterRunSection(configListOrSingleValue(\"spec integration1\", \"spec integration2\"));\n\n\t\tCombination combination = new Combination(ImmutableMap.of(\"script\", \"post_build\"));\n\t\tassertTrue(afterRunSection.toScript(combination, BuildType.BareMetal).toShellScript().contains(\"spec integration1\"));\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `afterRunSection.toScript(combination,com.groupon.jenkins.dynamic.build.execution.BuildType.BareMetal)` could be null and is dereferenced at line 44."}, "FixedCode": "@Test\n\tpublic void should_run_post_build() {\n\t\tConfigSection afterRunSection = new AfterRunSection(configListOrSingleValue(\"spec integration1\", \"spec integration2\"));\n\n\t\tCombination combination = new Combination(ImmutableMap.of(\"script\", \"post_build\"));\n\t\tassertTrue(afterRunSection.toScript(combination).toShellScript().contains(\"spec integration1\"));\n\t}", "LocalizedBug": "assertTrue(afterRunSection.toScript(combination, BuildType.BareMetal).toShellScript().contains(\"spec integration1\"));", "LocalizedPatchLength": 117, "CodeLength": 376}
{"BuggyCode": "@Test\n    public void shouldGenerateTheSameValueForTheSameSeed() {\n        if (System.getProperty(\"java.specification.version\").startsWith(\"9\")) {\n            assertThat(aNewLocaleRandomizer(SEED).getRandomValue()).isEqualTo(new Locale(\"sw\", \"ke\"));\n        } else {\n            assertThat(aNewLocaleRandomizer(SEED).getRandomValue()).isEqualTo(new Locale(\"nl\", \"be\"));\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getProperty(\"java.specification.version\")` could be null and is dereferenced at line 44."}, "FixedCode": "@Test\n    public void shouldGenerateTheSameValueForTheSameSeed() {\n        String javaVersion = System.getProperty(\"java.specification.version\");\n        if (javaVersion.startsWith(\"9\") || javaVersion.startsWith(\"10\")) {\n            assertThat(aNewLocaleRandomizer(SEED).getRandomValue()).isEqualTo(new Locale(\"sw\", \"ke\"));\n        } else {\n            assertThat(aNewLocaleRandomizer(SEED).getRandomValue()).isEqualTo(new Locale(\"nl\", \"be\"));\n        }\n    }", "LocalizedBug": "if (System.getProperty(\"java.specification.version\").startsWith(\"9\")) {", "LocalizedPatchLength": 71, "CodeLength": 385}
{"BuggyCode": "@Test\n    public void testObjectEncode() throws Exception {\n        final Base64 b64 = new Base64();\n        assertEquals(\"SGVsbG8gV29ybGQ=\", new String(b64.encode(\"Hello World\".getBytes(Charsets.UTF_8))));\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `b64.encode(\"Hello World\".getBytes(org.apache.commons.codec.Charsets.UTF_8))` could be null and is dereferenced by call to `String(...)` at line 542."}, "FixedCode": "@Test\n    public void testObjectEncode() throws Exception {\n        final Base64 b64 = new Base64();\n        assertEquals(\"SGVsbG8gV29ybGQ=\", new String(b64.encode(\"Hello World\".getBytes(CHARSET_UTF8))));\n    }", "LocalizedBug": "assertEquals(\"SGVsbG8gV29ybGQ=\", new String(b64.encode(\"Hello World\".getBytes(Charsets.UTF_8))));", "LocalizedPatchLength": 97, "CodeLength": 212}
{"BuggyCode": "@Override\n  public String authority() {\n    return delegate.authority();\n  }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.google.cloud.bigtable.grpc.io.ReconnectingChannel.authority` reads without synchronization from `this.com.google.cloud.bigtable.grpc.io.ReconnectingChannel.delegate`. Potentially races with write in method `ReconnectingChannel.close()`.\n Reporting because a superclass `class io.grpc.Channel` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself)."}, "FixedCode": "@Override\n  public String authority() {\n    return authority;\n  }", "LocalizedBug": "return delegate.authority();", "LocalizedPatchLength": 28, "CodeLength": 76}
{"BuggyCode": "@Test\n    public void getVersionOnTopicWithRIDGets() throws IOException\n    {\n        //arrange\n        String validString = \"$iothub/twin/res/?$rid=5&$version=7\";\n        TopicParser testParser = new TopicParser(validString);\n\n        //act\n        String version = testParser.getVersion(3);\n\n        //assert\n        assertNotNull(version);\n        assertTrue(version.equals(String.valueOf(7)));\n\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `version` last assigned on line 303 could be null and is dereferenced at line 307."}, "FixedCode": "@Test\n    public void getVersionOnTopicWithRIDGets() throws IOException\n    {\n        //arrange\n        String validString = \"$iothub/twin/res/?$rid=5&$version=7\";\n        TopicParser testParser = new TopicParser(validString);\n\n        //act\n        String version = Deencapsulation.invoke(testParser, \"getVersion\", 3);\n\n        //assert\n        assertNotNull(version);\n        assertTrue(version.equals(String.valueOf(7)));\n\n    }", "LocalizedBug": "String version = testParser.getVersion(3);", "LocalizedPatchLength": 42, "CodeLength": 404}
{"BuggyCode": "@Before\n  public void setUp() throws Exception {\n    // check that this is Java 8+\n    int javaVersion = Integer.parseInt(System.getProperty(\"java.version\").split(\"\\\\.\")[1]);\n    Assume.assumeTrue(javaVersion >= 8);\n\n    session = cassandraUnit.getSession();\n\n    Properties p = new Properties();\n    p.setProperty(\"hosts\", HOST);\n    p.setProperty(\"port\", Integer.toString(PORT));\n    p.setProperty(\"table\", TABLE);\n\n    Measurements.setProperties(p);\n    final CoreWorkload workload = new CoreWorkload();\n    workload.init(p);\n    client = new CassandraCQLClient();\n    client.setProperties(p);\n    client.init();\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getProperty(\"java.version\")` could be null and is dereferenced at line 72."}, "FixedCode": "@Before\n  public void setUp() throws Exception {\n    session = cassandraUnit.getSession();\n\n    Properties p = new Properties();\n    p.setProperty(\"hosts\", HOST);\n    p.setProperty(\"port\", Integer.toString(PORT));\n    p.setProperty(\"table\", TABLE);\n\n    Measurements.setProperties(p);\n    final CoreWorkload workload = new CoreWorkload();\n    workload.init(p);\n    client = new CassandraCQLClient();\n    client.setProperties(p);\n    client.init();\n  }", "LocalizedBug": "// check that this is Java 8+\nint javaVersion = Integer.parseInt(System.getProperty(\"java.version\").split(\"\\\\.\")[1]);\nAssume.assumeTrue(javaVersion >= 8);", "LocalizedPatchLength": 154, "CodeLength": 619}
{"BuggyCode": "@Test\n    //https://groups.google.com/forum/?fromgroups#!topic/jongo-user/p9CEKnkKX9Q\n    public void canUpdateIntoAnArray() throws Exception {\n\n        collection.insert(\"{friends:[{name:'Robert'},{name:'Peter'}]}\");\n\n        collection.update(\"{ 'friends.name' : 'Peter' }\").with(\"{ $set : { 'friends.$' : #} }\", new Friend(\"John\"));\n\n        Friends friends = collection.findOne().as(Friends.class);\n\n        assertThat(friends.friends).onProperty(\"name\").containsExactly(\"Robert\", \"John\");\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `friends` last assigned on line 102 could be null and is dereferenced at line 104."}, "FixedCode": "@Test\n    //https://groups.google.com/forum/?fromgroups#!topic/jongo-user/p9CEKnkKX9Q\n    public void canUpdateIntoAnArray() throws Exception {\n\n        collection.insert(\"{friends:[{name:'Robert'},{name:'Peter'}]}\");\n\n        collection.update(\"{ 'friends.name' : 'Peter' }\").with(\"{ $set : { 'friends.$' : #} }\", new Friend(\"John\"));\n\n        Party party = collection.findOne().as(Party.class);\n\n        assertThat(party.friends).onProperty(\"name\").containsExactly(\"Robert\", \"John\");\n    }", "LocalizedBug": "Friends friends = collection.findOne().as(Friends.class);\nassertThat(friends.friends).onProperty(\"name\").containsExactly(\"Robert\", \"John\");", "LocalizedPatchLength": 139, "CodeLength": 499}
{"BuggyCode": "@Test\n  public void testStartupArgsWithoutUrl() {\n    try {\n      SqlLine sqlLine = new SqlLine();\n      ByteArrayOutputStream os = new ByteArrayOutputStream();\n      PrintStream sqllineOutputStream =\n          new PrintStream(os, false, StandardCharsets.UTF_8.name());\n      sqlLine.setOutputStream(sqllineOutputStream);\n      sqlLine.setErrorStream(sqllineOutputStream);\n      String[] args = {\n          \"-d\",\n          \"org.hsqldb.jdbcDriver\",\n          \"-n\",\n          \"SCOTT\",\n          \"-p\",\n          \"TIGER\"\n      };\n      DispatchCallback callback = new DispatchCallback();\n      sqlLine.initArgs(args, callback);\n      assertThat(os.toString(\"UTF8\"), containsString(sqlLine.loc(\"no-url\")));\n    } catch (Throwable e) {\n      // fail\n      throw new RuntimeException(e);\n    }\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.PrintStream` acquired by call to `SqlLine()` at line 2414 is not released after line 2419."}, "FixedCode": "@Test\n  public void testStartupArgsWithoutUrl() {\n    try {\n      ByteArrayOutputStream os = new ByteArrayOutputStream();\n      PrintStream sqllineOutputStream =\n          new PrintStream(os, false, StandardCharsets.UTF_8.name());\n      sqlLine.setOutputStream(sqllineOutputStream);\n      sqlLine.setErrorStream(sqllineOutputStream);\n      String[] args = {\n          \"-d\",\n          \"org.hsqldb.jdbcDriver\",\n          \"-n\",\n          \"SCOTT\",\n          \"-p\",\n          \"TIGER\"\n      };\n      DispatchCallback callback = new DispatchCallback();\n      sqlLine.initArgs(args, callback);\n      assertThat(os.toString(\"UTF8\"), containsString(sqlLine.loc(\"no-url\")));\n    } catch (Throwable e) {\n      // fail\n      throw new RuntimeException(e);\n    }\n  }", "LocalizedBug": "SqlLine sqlLine = new SqlLine();", "LocalizedPatchLength": 32, "CodeLength": 790}
{"BuggyCode": "private void assertFileContains(File file, Matcher matcher)\n      throws IOException {\n    final BufferedReader br = new BufferedReader(new FileReader(file));\n    final StringWriter stringWriter = new StringWriter();\n    for (;;) {\n      final String line = br.readLine();\n      if (line == null) {\n        break;\n      }\n      stringWriter.write(line);\n      stringWriter.write(\"\\n\");\n    }\n    br.close();\n    assertThat(toLinux(stringWriter.toString()), matcher);\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileReader` acquired by call to `new()` at line 635 is not released after line 647.\n**Note**: potential exception at line 638"}, "FixedCode": "private void assertFileContains(File file, Matcher matcher)\n      throws IOException {\n    final BufferedReader br = new BufferedReader(\n        new InputStreamReader(\n            new FileInputStream(file), StandardCharsets.UTF_8.name()));\n    final StringWriter stringWriter = new StringWriter();\n    for (;;) {\n      final String line = br.readLine();\n      if (line == null) {\n        break;\n      }\n      stringWriter.write(line);\n      stringWriter.write(\"\\n\");\n    }\n    br.close();\n    assertThat(toLinux(stringWriter.toString()), matcher);\n  }", "LocalizedBug": "final BufferedReader br = new BufferedReader(new FileReader(file));", "LocalizedPatchLength": 67, "CodeLength": 470}
{"BuggyCode": "public Quaternionfc toImmutable() {\n        if (Proxy.DISABLE_PROXIES)\n            return this;\n        if (proxy != null)\n            return proxy;\n        synchronized (this) {\n            if (proxy != null)\n                return proxy;\n            proxy = Proxy.createQuaternionfc(this);\n        }\n        return proxy;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.joml.Quaternionf.toImmutable` reads without synchronization from `this.org.joml.Quaternionf.proxy`. Potentially races with write in method `Quaternionf.toImmutable()`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public Quaternionfc toImmutable() {\n        if (Proxy.DISABLE_PROXIES)\n            return this;\n        return Proxy.createQuaternionfc(this);\n    }", "LocalizedBug": "if (proxy != null)\nreturn proxy;\nsynchronized (this) {\nif (proxy != null)\nreturn proxy;\nproxy = Proxy.createQuaternionfc(this);\nreturn proxy;\n}", "LocalizedPatchLength": 143, "CodeLength": 329}
{"BuggyCode": "public static void start(List<GraphvizEngine> engines) throws IOException {\n        final boolean windows = System.getProperty(\"os.name\").contains(\"windows\");\n        final String executable = windows ? \"java.exe\" : \"java\";\n        final List<String> cmd = new ArrayList<>(Arrays.asList(\n                System.getProperty(\"java.home\") + \"/bin/\" + executable,\n                \"-cp\", System.getProperty(\"java.class.path\"), GraphvizServer.class.getName()));\n        cmd.addAll(engines.stream().map(e -> e.getClass().getName()).collect(toList()));\n        new ProcessBuilder(cmd).inheritIO().start();\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getProperty(\"os.name\")` could be null and is dereferenced at line 37."}, "FixedCode": "public static void start(List<GraphvizEngine> engines) throws IOException {\n        final String executable = SystemUtils.executableName(\"java\");\n        final List<String> cmd = new ArrayList<>(Arrays.asList(\n                System.getProperty(\"java.home\") + \"/bin/\" + executable,\n                \"-cp\", System.getProperty(\"java.class.path\"), GraphvizServer.class.getName()));\n        cmd.addAll(engines.stream().map(e -> e.getClass().getName()).collect(toList()));\n        new ProcessBuilder(cmd).inheritIO().start();\n    }", "LocalizedBug": "final boolean windows = System.getProperty(\"os.name\").contains(\"windows\");\nfinal String executable = windows ? \"java.exe\" : \"java\";", "LocalizedPatchLength": 131, "CodeLength": 603}
{"BuggyCode": "private String slurp(String fileName) throws IOException {\n        URL fileUrl = this.getClass().getResource(fileName);\n        File file = new File(URLDecoder.decode(fileUrl.getFile(), \"UTF-8\"));\n        FileReader in = new FileReader(file);\n        StringBuffer sb = new StringBuffer();\n        int ch;\n        while ((ch = in.read()) != -1) {\n            sb.append((char) ch);\n        }\n        return sb.toString();\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileReader` acquired by call to `new()` at line 97 is not released after line 103."}, "FixedCode": "private String slurp(String fileName) throws IOException {\n        URL fileUrl = this.getClass().getResource(fileName);\n        File file = new File(URLDecoder.decode(fileUrl.getFile(), \"UTF-8\"));\n        BufferedReader in = new BufferedReader(new FileReader(file));\n        StringBuilder sb  = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            sb.append(line).append(\"\\n\");\n        }\n        in.close();\n        return sb.toString();\n    }", "LocalizedBug": "FileReader in = new FileReader(file);\nStringBuffer sb = new StringBuffer();\nint ch;\nwhile ((ch = in.read()) != -1) {\nsb.append((char) ch);", "LocalizedPatchLength": 138, "CodeLength": 425}
{"BuggyCode": "public void close() {\n\t\tif( thread != null ) {\n\t\t\tthread.interrupt();\n\t\t\tcloselock.lock();\n\t\t\ttry {\n\t\t\t\tif( selector != null )\n\t\t\t\t\tselector.wakeup();\n\t\t\t} finally {\n\t\t\t\tcloselock.unlock();\n\t\t\t}\n\t\t}\n\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.java_websocket.client.WebSocketClient.close` reads with synchronization from `this.org.java_websocket.client.WebSocketClient.selector`. Potentially races with unsynchronized write in method `WebSocketClient.run()`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public void close() {\n\t\tif( thread != null ) {\n\t\t\tconn.close( CloseFrame.NORMAL );\n\t\t\t/*closelock.lock();\n\t\t\ttry {\n\t\t\t\tif( selector != null )\n\t\t\t\t\tselector.wakeup();\n\t\t\t} finally {\n\t\t\t\tcloselock.unlock();\n\t\t\t}*/\n\t\t}\n\n\t}", "LocalizedBug": "thread.interrupt();", "LocalizedPatchLength": 19, "CodeLength": 202}
{"BuggyCode": "@Test\n    public void stemEndingTest1() throws IOException {\n        TurkishMorphology morphology = TurkishMorphology.builder().addDictionaryLines(\"bakmak\", \"gelmek\").build();\n        List<String> endings = Lists.newArrayList(\"acak\", \"ecek\");\n        StemEndingGraph graph = new StemEndingGraph(morphology, endings);\n        CharacterGraphDecoder spellChecker = new CharacterGraphDecoder(graph.stemGraph);\n        List<ScoredItem<String>> res = spellChecker.getSuggestionsWithScores(\"bakcaak\");\n        for (ScoredItem<String> re : res) {\n            System.out.println(re.item);\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `spellChecker.graph` last assigned on line 259 could be null and is dereferenced by call to `getSuggestionsWithScores(...)` at line 260."}, "FixedCode": "@Test\n    public void stemEndingTest1() throws IOException {\n        TurkishMorphology morphology = TurkishMorphology.builder().addDictionaryLines(\"bakmak\", \"gelmek\").build();\n        List<String> endings = Lists.newArrayList(\"acak\", \"ecek\");\n        StemEndingGraph graph = new StemEndingGraph(morphology, endings);\n        CharacterGraphDecoder spellChecker = new CharacterGraphDecoder(graph.stemGraph);\n        List<String> res = spellChecker.getSuggestions(\"bakcaak\");\n        Assert.assertEquals(1, res.size());\n        Assert.assertEquals(\"bakacak\", res.get(0));\n    }", "LocalizedBug": "List<ScoredItem<String>> res = spellChecker.getSuggestionsWithScores(\"bakcaak\");\nfor (ScoredItem<String> re : res) {\nSystem.out.println(re.item);\n}", "LocalizedPatchLength": 147, "CodeLength": 595}
{"BuggyCode": "@Test\n\tpublic void testGenerateNewCsvFile() throws SimpleRelationalInputGenerationException, IOException {\n\t\t// Setup\n\t\tSimpleRelationalInput csv = generator.generateNewCopy();\n\t\t\n\t\t// Check result\n\t\t// The csv should contain both lines and iterate through them with next.\n\t\tassertEquals(csvFileFixture.expectedFirstLine(), csv.next());\n\t\tassertEquals(csvFileFixture.expectedSecondLine(), csv.next());\n\t\t// A new CsvFile should iterate from the start.\n\t\tSimpleRelationalInput csv2 = generator.generateNewCopy();\n\t\tassertEquals(csvFileFixture.expectedFirstLine(), csv2.next());\n\t\tassertEquals(csvFileFixture.expectedSecondLine(), csv2.next());\t\t\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `au.com.bytecode.opencsv.CSVReader` acquired by call to `generateNewCopy()` at line 73 is not released after line 78."}, "FixedCode": "@Test\n\tpublic void testGenerateNewCsvFile() throws SimpleRelationalInputGenerationException, InputIterationException {\n\t\t// Setup\n\t\tSimpleRelationalInput csv = generator.generateNewCopy();\n\t\t\n\t\t// Check result\n\t\t// The csv should contain both lines and iterate through them with next.\n\t\tassertEquals(csvFileFixture.expectedFirstLine(), csv.next());\n\t\tassertEquals(csvFileFixture.expectedSecondLine(), csv.next());\n\t\t// A new CsvFile should iterate from the start.\n\t\tSimpleRelationalInput csv2 = generator.generateNewCopy();\n\t\tassertEquals(csvFileFixture.expectedFirstLine(), csv2.next());\n\t\tassertEquals(csvFileFixture.expectedSecondLine(), csv2.next());\t\t\n\t}", "LocalizedBug": "public void testGenerateNewCsvFile() throws SimpleRelationalInputGenerationException, IOException {", "LocalizedPatchLength": 99, "CodeLength": 647}
{"BuggyCode": "@Override\n  public void transitionInto(RunState state) {\n    switch (state.state()) {\n      case SUBMITTING:\n        try {\n          final String executionId = dockerRunnerStart(state);\n          // this is racy\n          final Event submitted = Event.submitted(state.workflowInstance(), executionId);\n          try {\n            stateManager.receive(submitted);\n          } catch (StateManager.IsClosed isClosed) {\n            LOG.warn(\"Could not send 'created' event\", isClosed);\n          }\n        } catch (Exception e) {\n          LOG.warn(\"Failed the docker starting procedure for \" + state.workflowInstance().toKey(), e);\n          stateManager.receiveIgnoreClosed(Event.halt(state.workflowInstance()));\n        }\n        break;\n\n      case TERMINATED:\n      case FAILED:\n      case ERROR:\n        if (state.executionId().isPresent()) {\n          final String executionId = state.executionId().get();\n          LOG.info(\"Cleaning up {} pod: {}\", state.workflowInstance().toKey(), executionId);\n\n          dockerRunner.cleanup(executionId);\n        }\n        break;\n\n      default:\n        // do nothing\n    }\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `state.workflowInstance()` could be null and is dereferenced at line 74."}, "FixedCode": "@Override\n  public void transitionInto(RunState state) {\n    switch (state.state()) {\n      case SUBMITTING:\n        try {\n          final String executionId = dockerRunnerStart(state);\n          // this is racy\n          final Event submitted = Event.submitted(state.workflowInstance(), executionId);\n          try {\n            stateManager.receive(submitted);\n          } catch (StateManager.IsClosed isClosed) {\n            LOG.warn(\"Could not send 'created' event\", isClosed);\n          }\n        } catch (ResourceNotFoundException e) {\n          LOG.error(\"Unable to start docker procedure.\", e);\n          stateManager.receiveIgnoreClosed(Event.halt(state.workflowInstance()));\n        } catch (IOException e) {\n          try {\n            LOG.error(\"Failed the docker starting procedure for \" + state.workflowInstance().toKey(), e);\n            stateManager.receive(Event.runError(state.workflowInstance(), e.getMessage()));\n          } catch (StateManager.IsClosed isClosed) {\n            LOG.warn(\"Failed to send 'runError' event\", isClosed);\n          }\n        }\n        break;\n\n      case TERMINATED:\n      case FAILED:\n      case ERROR:\n        if (state.executionId().isPresent()) {\n          final String executionId = state.executionId().get();\n          LOG.info(\"Cleaning up {} pod: {}\", state.workflowInstance().toKey(), executionId);\n\n          dockerRunner.cleanup(executionId);\n        }\n        break;\n\n      default:\n        // do nothing\n    }\n  }", "LocalizedBug": "} catch (Exception e) {\nLOG.warn(\"Failed the docker starting procedure for \" + state.workflowInstance().toKey(), e);\nstateManager.receiveIgnoreClosed(Event.halt(state.workflowInstance()));", "LocalizedPatchLength": 188, "CodeLength": 1119}
{"BuggyCode": "private MongoDatabase database() {\n\n          return createMongoClient().getDatabase(databaseName);\n     }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.mongodb.MongoClient` acquired by call to `createMongoClient()` at line 325 is not released after line 325."}, "FixedCode": "private MongoDatabase database() {\n\n          return this.mongoClient.getDatabase(databaseName);\n     }", "LocalizedBug": "return createMongoClient().getDatabase(databaseName);", "LocalizedPatchLength": 53, "CodeLength": 106}
{"BuggyCode": "public boolean isLocalHasSeed(List<Account> accountList) {\n        for (Account account : accountList) {\n            for (PocMeetingMember seed : this.getDefaultSeedList()) {\n                if (seed.getAgentAddress().equals(account.getAddress().getBase58())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `io.nuls.consensus.manager.PackingRoundManager.isLocalHasSeed` indirectly writes to field `this.io.nuls.consensus.manager.PackingRoundManager.seedList` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public boolean isLocalHasSeed(List<Account> accountList) {\n        for (Account account : accountList) {\n            for (String seedAddress : csManager.getSeedNodeList()) {\n                if (seedAddress.equals(account.getAddress().getBase58())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "LocalizedBug": "for (PocMeetingMember seed : this.getDefaultSeedList()) {\nif (seed.getAgentAddress().equals(account.getAddress().getBase58())) {", "LocalizedPatchLength": 128, "CodeLength": 364}
{"BuggyCode": "public long getActiveTimeMillis() {\n        if (lastReturnTime > lastBorrowTime) {\n            return lastReturnTime - lastBorrowTime;\n        } else {\n            return System.currentTimeMillis() - lastBorrowTime;\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.apache.commons.pool2.impl.PooledObject.getActiveTimeMillis` reads without synchronization from `this.org.apache.commons.pool2.impl.PooledObject.lastBorrowTime`. Potentially races with write in method `PooledObject.allocate()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public long getActiveTimeMillis() {\n        // Take copies to avoid threading issues\n        long rTime = lastReturnTime;\n        long bTime = lastBorrowTime;\n        \n        if (rTime > bTime) {\n            return rTime - bTime;\n        } else {\n            return System.currentTimeMillis() - bTime;\n        }\n    }", "LocalizedBug": "if (lastReturnTime > lastBorrowTime) {\nreturn lastReturnTime - lastBorrowTime;\nreturn System.currentTimeMillis() - lastBorrowTime;", "LocalizedPatchLength": 130, "CodeLength": 231}
{"BuggyCode": "public static void main(String[] args) {\n\t\tZookeeperConfigProfile profile = new ZookeeperConfigProfile(\"zk.host\", \"/projectx/modulex\", true);\n\t\tprofile.setLocalCacheFolder(\"/your/local/config/folder\");\n\t\t\n\t\tConfigGroup dbConfigs = new ZookeeperConfigGroup(null, profile, \"db\");\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.dangdang.config.service.zookeeper.ZookeeperConfigGroup` acquired by call to `ZookeeperConfigGroup(...)` at line 20 is not released after line 20."}, "FixedCode": "public static void main(String[] args) {\n\t\tString rootNode = \"/projectx/modulex\";\n\t\tZookeeperConfigProfile profile = new ZookeeperConfigProfile(\"zk.host\", rootNode, true);\n\n\t\tZookeeperConfigGroup dbConfigs = new ZookeeperConfigGroup(null, profile, \"db\");\n\t\tdbConfigs.setConfigLocalCache(new ConfigLocalCache(\"/your/local/config/folder\", rootNode));\n\t}", "LocalizedBug": "ZookeeperConfigProfile profile = new ZookeeperConfigProfile(\"zk.host\", \"/projectx/modulex\", true);\nprofile.setLocalCacheFolder(\"/your/local/config/folder\");\nConfigGroup dbConfigs = new ZookeeperConfigGroup(null, profile, \"db\");", "LocalizedPatchLength": 227, "CodeLength": 280}
{"BuggyCode": "@Test\n    public void shouldNotAllowMoreTransactionsInSessionWhileConnectionClosed() throws Throwable\n    {\n        // Given\n        Connection mock = mock( Connection.class );\n        when( mock.isOpen() ).thenReturn( false );\n        InternalSession sess = new InternalSession( mock );\n\n        // Expect\n        exception.expect( ClientException.class );\n\n        // When\n        sess.beginTransaction();\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.neo4j.driver.internal.InternalSession` acquired to `sess` by call to `new()` at line 139 is not released after line 145."}, "FixedCode": "@Test\n    public void shouldNotAllowMoreTransactionsInSessionWhileConnectionClosed() throws Throwable\n    {\n        // Given\n        when( mock.isOpen() ).thenReturn( false );\n\n        // Expect\n        exception.expect( ClientException.class );\n\n        // When\n        sess.beginTransaction();\n    }", "LocalizedBug": "Connection mock = mock( Connection.class );\nwhen( mock.isOpen() ).thenReturn( false );\nInternalSession sess = new InternalSession( mock );", "LocalizedPatchLength": 138, "CodeLength": 413}
{"BuggyCode": "@Test\n    public void testEmptyLineBehaviourExcel() throws Exception {\n        String[] codes = {\n                \"hello,\\r\\n\\r\\n\\r\\n\",\n                \"hello,\\n\\n\\n\",\n                \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n                \"hello,\\\"\\\"\\n\\n\\n\"\n        };\n        String[][] res = {\n                {\"hello\", \"\"},\n                {\"\"},  // Excel format does not ignore empty lines\n                {\"\"}\n        };\n        for (String code : codes) {\n            CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n            String[][] tmp = parser.getRecords();\n            assertEquals(res.length, tmp.length);\n            assertTrue(tmp.length > 0);\n            for (int i = 0; i < res.length; i++) {\n                assertTrue(Arrays.equals(res[i], tmp[i]));\n            }\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `tmp` last assigned on line 189 could be null and is dereferenced at line 190."}, "FixedCode": "@Test\n    public void testEmptyLineBehaviourExcel() throws Exception {\n        String[] codes = {\n                \"hello,\\r\\n\\r\\n\\r\\n\",\n                \"hello,\\n\\n\\n\",\n                \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n                \"hello,\\\"\\\"\\n\\n\\n\"\n        };\n        String[][] res = {\n                {\"hello\", \"\"},\n                {\"\"},  // Excel format does not ignore empty lines\n                {\"\"}\n        };\n        for (String code : codes) {\n            CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n            List<CSVRecord> records = parser.getRecords();\n            assertEquals(res.length, records.size());\n            assertTrue(records.size() > 0);\n            for (int i = 0; i < res.length; i++) {\n                assertTrue(Arrays.equals(res[i], records.get(i).values()));\n            }\n        }\n    }", "LocalizedBug": "String[][] tmp = parser.getRecords();\nassertEquals(res.length, tmp.length);\nassertTrue(tmp.length > 0);\nassertTrue(Arrays.equals(res[i], tmp[i]));\n}\n}\n}", "LocalizedPatchLength": 152, "CodeLength": 797}
{"BuggyCode": "void syncReloadCheck() {\n        if (hotReloadLogic != null && hotReloadLogic.isSync())\n            hotReloadLogic.checkAndReload(lastLoadTime);\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.aeonbits.owner.PropertiesManager.syncReloadCheck` reads without synchronization from `this.org.aeonbits.owner.PropertiesManager.lastLoadTime`. Potentially races with write in method `PropertiesManager.reload()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "PropertiesManager(Class<? extends Config> clazz, Properties properties, ScheduledExecutorService scheduler,\n                      Map<?, ?>... imports) {\n        this.clazz = clazz;\n        this.properties = properties;\n        this.imports = imports;\n\n        handler = new ConfigURLStreamHandler(clazz.getClassLoader(), expander);\n\n        sources = clazz.getAnnotation(Sources.class);\n        LoadPolicy loadPolicy = clazz.getAnnotation(LoadPolicy.class);\n        loadType = (loadPolicy != null) ? loadPolicy.value() : FIRST;\n\n        setupHotReload(clazz, scheduler);\n    }", "LocalizedBug": "void syncReloadCheck() {\nif (hotReloadLogic != null && hotReloadLogic.isSync())\nhotReloadLogic.checkAndReload(lastLoadTime);", "LocalizedPatchLength": 124, "CodeLength": 150}
{"BuggyCode": "public void testAtomicBoolean() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        AtomicBoolean b = mapper.readValue(\"true\", AtomicBoolean.class);\n        assertTrue(b.get());\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `__cast(__new(com.fasterxml.jackson.databind.ObjectMapper).readValue(\"true\",java.util.concurrent.atomic.AtomicBoolean),java.util.concurrent.atomic.AtomicBoolean)` could be null and is dereferenced at line 14."}, "FixedCode": "public void testAtomicBoolean() throws Exception\n    {\n        AtomicBoolean b = MAPPER.readValue(\"true\", AtomicBoolean.class);\n        assertTrue(b.get());\n    }", "LocalizedBug": "ObjectMapper mapper = new ObjectMapper();\nAtomicBoolean b = mapper.readValue(\"true\", AtomicBoolean.class);", "LocalizedPatchLength": 106, "CodeLength": 212}
{"BuggyCode": "@OnOpen\n\tpublic void open(Session session, @PathParam(\"channel\") String channel) {\n\t\tBeanManager.INSTANCE.getReference(PushContextImpl.class).add(session, channel); // @Inject in @ServerEndpoint doesn't work in Tomcat+Weld.\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `org.omnifaces.config.BeanManager.INSTANCE.getReference(org.omnifaces.cdi.push.PushContextImpl)` could be null and is dereferenced at line 43."}, "FixedCode": "@OnOpen\n\tpublic void open(Session session, @PathParam(\"channel\") String channel) {\n\t\tBeanManager.INSTANCE.getReference(SocketPushContext.class).add(session, channel); // @Inject in @ServerEndpoint doesn't work in Tomcat+Weld.\n\t}", "LocalizedBug": "BeanManager.INSTANCE.getReference(PushContextImpl.class).add(session, channel); // @Inject in @ServerEndpoint doesn't work in Tomcat+Weld.", "LocalizedPatchLength": 138, "CodeLength": 226}
{"BuggyCode": "public void dump()\n\t{\n\t\tdump(new PrintWriter(new OutputStreamWriter(System.out)));\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.PrintWriter` acquired by call to `new()` at line 47 is not released after line 47.\n**Note**: potential exception at line 47"}, "FixedCode": "public void dump()\n\t{\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tdump(pw);\n\t\tpw.flush();\n\t}", "LocalizedBug": "dump(new PrintWriter(new OutputStreamWriter(System.out)));", "LocalizedPatchLength": 58, "CodeLength": 85}
{"BuggyCode": "@Test\n    public void imageTest01() throws IOException, InterruptedException {\n\n        String outFileName = destinationFolder + \"imageTest01.pdf\";\n        String cmpFileName = sourceFolder + \"cmp_imageTest01.pdf\";\n\n        FileOutputStream file = new FileOutputStream(outFileName);\n\n        PdfWriter writer = new PdfWriter(file);\n\n        PdfDocument pdfDoc = new PdfDocument(writer);\n\n        Document doc = new Document(pdfDoc);\n\n        PdfImageXObject xObject = new PdfImageXObject(ImageFactory.getJpegImage(new File(sourceFolder+\"Desert.jpg\").toURI().toURL()));\n        Image image = new Image(xObject, 100);\n\n        doc.add(new Paragraph(new Text(\"First Line\")));\n        Paragraph p = new Paragraph();\n        p.add(image);\n        doc.add(p);\n        doc.add(new Paragraph(new Text(\"Second Line\")));\n\n        doc.close();\n\n        Assert.assertNull(new CompareTool().compareByContent(outFileName, cmpFileName, destinationFolder, \"diff\"));\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.itextpdf.core.pdf.PdfWriter` acquired by call to `new()` at line 35 is not released after line 53.\n**Note**: potential exception at line 41"}, "FixedCode": "@Test\n    public void imageTest01() throws IOException, InterruptedException {\n\n        String outFileName = destinationFolder + \"imageTest01.pdf\";\n        String cmpFileName = sourceFolder + \"cmp_imageTest01.pdf\";\n\n        FileOutputStream file = new FileOutputStream(outFileName);\n\n        PdfWriter writer = new PdfWriter(file);\n\n        PdfDocument pdfDoc = new PdfDocument(writer);\n\n        Document doc = new Document(pdfDoc);\n\n        PdfImageXObject xObject = new PdfImageXObject(ImageFactory.getImage(sourceFolder + \"Desert.jpg\"));\n        Image image = new Image(xObject, 100);\n\n        doc.add(new Paragraph(new Text(\"First Line\")));\n        Paragraph p = new Paragraph();\n        p.add(image);\n        doc.add(p);\n        doc.add(new Paragraph(new Text(\"Second Line\")));\n\n        doc.close();\n\n        Assert.assertNull(new CompareTool().compareByContent(outFileName, cmpFileName, destinationFolder, \"diff\"));\n    }", "LocalizedBug": "PdfImageXObject xObject = new PdfImageXObject(ImageFactory.getJpegImage(new File(sourceFolder+\"Desert.jpg\").toURI().toURL()));", "LocalizedPatchLength": 126, "CodeLength": 955}
{"BuggyCode": "@Override\n  public Response index(LindenIndexRequest request) throws IOException {\n    if (request.getType().equals(IndexRequestType.SWAP_INDEX)) {\n      Response response;\n      try {\n        response = swapIndex(request.getIndexName());\n      } catch (Exception e) {\n        LOGGER.error(\"Swapping index \" + request.getIndexName() + \" failed, \" + e);\n        throw new IOException(\"Swapping index \" + request.getIndexName() + \" failed!\", e);\n      }\n      return response;\n    }\n    String indexName = request.getIndexName();\n    LindenCore core = currentLindenCore;\n    if (indexName != null && !indexName.equals(currentIndexName)) {\n      if (indexName.startsWith(NEXT_INDEX_NAME_PREFIX)) {\n        // Accept bootstrap index request after swap is done in case something unexpected happened\n        // that swap command is executed before bootstrap is done\n        if (!indexName.substring(NEXT_INDEX_NAME_PREFIX.length()).equals(currentIndexTimeStamp)) {\n          core = getLindenCore(indexName);\n        }\n      } else {\n        throw new IOException(\"Bad index name \" + indexName + \" in HotSwapLindenCoreImpl.\");\n      }\n    }\n    return core.index(request);\n  }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.xiaomi.linden.core.search.HotSwapLindenCoreImpl.index` reads without synchronization from `this.com.xiaomi.linden.core.search.HotSwapLindenCoreImpl.currentIndexTimeStamp`. Potentially races with write in method `HotSwapLindenCoreImpl.swapIndex(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n  public Response index(LindenIndexRequest request) throws IOException {\n    if (request.getType().equals(IndexRequestType.SWAP_INDEX)) {\n      Response response;\n      try {\n        response = swapIndex(request.getIndexName());\n      } catch (Exception e) {\n        LOGGER.error(\"Swapping index \" + request.getIndexName() + \" failed, \" + e);\n        throw new IOException(\"Swapping index \" + request.getIndexName() + \" failed!\", e);\n      }\n      return response;\n    }\n    String indexName = request.getIndexName();\n    LindenCore core = currentLindenCore;\n    if (indexName != null && !indexName.equals(currentIndexName)) {\n      if (indexName.startsWith(NEXT_INDEX_NAME_PREFIX)) {\n        // Accept bootstrap index request after swap is done in case something unexpected happened\n        // that swap command is executed before bootstrap is done\n        if (!indexName.substring(NEXT_INDEX_NAME_PREFIX.length()).equals(currentIndexVersion)) {\n          core = getLindenCore(indexName);\n        }\n      } else {\n        throw new IOException(\"Bad index name \" + indexName + \" in HotSwapLindenCoreImpl.\");\n      }\n    }\n    return core.index(request);\n  }", "LocalizedBug": "if (!indexName.substring(NEXT_INDEX_NAME_PREFIX.length()).equals(currentIndexTimeStamp)) {", "LocalizedPatchLength": 90, "CodeLength": 1169}
{"BuggyCode": "@Test\n    public void testShutdown4() throws SQLException\n    {\n        StubConnection.slowCreate = true;\n        \n        HikariConfig config = new HikariConfig();\n        config.setMinimumIdle(10);\n        config.setMaximumPoolSize(10);\n        config.setInitializationFailFast(false);\n        config.setConnectionTestQuery(\"VALUES 1\");\n        config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n        HikariDataSource ds = new HikariDataSource(config);\n\n        PoolUtilities.quietlySleep(300);\n\n        ds.shutdown();\n\n        long start = System.currentTimeMillis();\n        while (PoolUtilities.elapsedTimeMs(start) < TimeUnit.SECONDS.toMillis(5) && threadCount() > 0)\n        {\n            PoolUtilities.quietlySleep(250);\n        }\n\n        Assert.assertSame(\"Thread was leaked\", 0, threadCount());\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zaxxer.hikari.HikariDataSource` acquired to `ds` by call to `new()` at line 165 is not released after line 169."}, "FixedCode": "@Test\n    public void testShutdown4() throws SQLException\n    {\n        StubConnection.slowCreate = true;\n        \n        HikariConfig config = new HikariConfig();\n        config.setMinimumIdle(10);\n        config.setMaximumPoolSize(10);\n        config.setInitializationFailFast(false);\n        config.setConnectionTestQuery(\"VALUES 1\");\n        config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n        HikariDataSource ds = new HikariDataSource(config);\n\n        PoolUtilities.quietlySleep(300);\n\n        ds.close();\n\n        long start = System.currentTimeMillis();\n        while (PoolUtilities.elapsedTimeMs(start) < TimeUnit.SECONDS.toMillis(5) && threadCount() > 0)\n        {\n            PoolUtilities.quietlySleep(250);\n        }\n\n        Assert.assertSame(\"Thread was leaked\", 0, threadCount());\n    }", "LocalizedBug": "ds.shutdown();", "LocalizedPatchLength": 14, "CodeLength": 837}
{"BuggyCode": "@Override\n    public void subscribe(String cluster, Watch.Listener listener) throws Exception {\n        listenerMap.putIfAbsent(cluster, new HashSet<>());\n        listenerMap.get(cluster).add(listener);\n        EtcdWatcher watcher = watcherMap.computeIfAbsent(cluster, w -> new EtcdWatcher(listener));\n        EXECUTOR_SERVICE.submit(watcher);\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `io.seata.discovery.registry.etcd3.EtcdRegistryServiceImpl.subscribe` reads without synchronization from `etcd3.EtcdRegistryServiceImpl.io.seata.discovery.registry.etcd3.EtcdRegistryServiceImpl.watcherMap`. Potentially races with write in method `EtcdRegistryServiceImpl.getInstance()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n    public void subscribe(String cluster, Watch.Listener listener) throws Exception {\n        listenerMap.putIfAbsent(cluster, new HashSet<>());\n        listenerMap.get(cluster).add(listener);\n        EtcdWatcher watcher = watcherMap.computeIfAbsent(cluster, w -> new EtcdWatcher(listener));\n        executorService.submit(watcher);\n    }", "LocalizedBug": "EXECUTOR_SERVICE.submit(watcher);", "LocalizedPatchLength": 33, "CodeLength": 349}
{"BuggyCode": "protected final void writeFile( File outFile, StringBuffer input )\n        throws IOException\n    {\n        OutputStream out = new BufferedOutputStream( new FileOutputStream( outFile ) );\n        out.write( input.toString().getBytes( PomHelper.POM_ENCODING ) );\n        out.close();\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 386 is not released after line 389.\n**Note**: potential exception at line 387"}, "FixedCode": "protected final void writeFile( File outFile, StringBuffer input )\n        throws IOException\n    {\n        Writer writer = WriterFactory.newXmlWriter( outFile );\n        try\n        {\n            IOUtil.copy( input.toString(), writer );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n    }", "LocalizedBug": "OutputStream out = new BufferedOutputStream( new FileOutputStream( outFile ) );\nout.write( input.toString().getBytes( PomHelper.POM_ENCODING ) );\nout.close();", "LocalizedPatchLength": 158, "CodeLength": 288}
{"BuggyCode": "@Test\n    public void testWriteValueCopiesFieldName()\n        throws Exception\n    {\n        IonStruct data = struct(\"{a:{b:10}}\");\n        IonReader ir = system().newReader(data);\n        ir.next();\n        ir.stepIn();\n        expectNextField(ir, \"a\");\n\n        iw = makeWriter();\n        iw.stepIn(IonType.STRUCT);\n        iw.writeValue(ir);\n        iw.stepOut();\n        assertEquals(data, reloadSingleValue());\n\n        IonValue a = data.get(\"a\");\n        ir = system().newReader(a);\n        ir.next();\n\n        iw = makeWriter();\n        iw.stepIn(IonType.STRUCT);\n        iw.writeValue(ir);\n        iw.stepOut();\n        assertEquals(data, reloadSingleValue());\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `data` last assigned on line 488 could be null and is dereferenced at line 500."}, "FixedCode": "@Test\n    public void testWriteValueCopiesFieldName()\n        throws Exception\n    {\n        IonStruct data = struct(\"{a:{b:10}}\");\n        IonReader ir = system().newReader(data);\n        ir.next();\n        ir.stepIn();\n        expectNextField(ir, \"a\");\n\n        iw = makeWriter();\n        iw.stepIn(IonType.STRUCT);\n        iw.writeValue(ir);\n        iw.stepOut();\n        assertEquals(data, reloadSingleValue());\n    }", "LocalizedBug": "IonValue a = data.get(\"a\");\nir = system().newReader(a);\nir.next();\niw = makeWriter();\niw.stepIn(IonType.STRUCT);\niw.writeValue(ir);\niw.stepOut();\nassertEquals(data, reloadSingleValue());", "LocalizedPatchLength": 186, "CodeLength": 674}
{"BuggyCode": "protected long getBodyLength(Charset charset) {\n        ObjectMataData objectMataData = FdfsParamMapper.getObjectMap(this.getClass());\n        return objectMataData.getFieldsSendTotalByteSize(this, charset) + getFileSize();\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `objectMataData` last assigned on line 60 could be null and is dereferenced at line 61."}, "FixedCode": "protected long getBodyLength(Charset charset) {\n        ObjectMetaData objectMetaData = FdfsParamMapper.getObjectMap(this.getClass());\n        return objectMetaData.getFieldsSendTotalByteSize(this, charset) + getFileSize();\n    }", "LocalizedBug": "ObjectMataData objectMataData = FdfsParamMapper.getObjectMap(this.getClass());\nreturn objectMataData.getFieldsSendTotalByteSize(this, charset) + getFileSize();", "LocalizedPatchLength": 159, "CodeLength": 229}
{"BuggyCode": "public static void main(String[] args) throws UnsupportedAudioFileException, IOException {\n    Audio.playSound(Audio.getAudioStream(\"./etc/Bass-Drum-1.wav\"), -10.0f);\n    Audio.playSound(Audio.getAudioStream(\"./etc/Closed-Hi-Hat-1.wav\"), -8.0f);\n    \n    System.out.println(\"Press Enter key to stop the program...\");\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    br.read();\n    Audio.stopService();\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 55 is not released after line 56."}, "FixedCode": "public static void main(String[] args) throws UnsupportedAudioFileException, IOException, InterruptedException {\n    Audio audio = Audio.getInstance();\n    audio.playSound(audio.getAudioStream(\"./etc/Bass-Drum-1.wav\"), -10.0f);\n    audio.playSound(audio.getAudioStream(\"./etc/Closed-Hi-Hat-1.wav\"), -8.0f);\n    \n    System.out.println(\"Press Enter key to stop the program...\");\n    try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n      br.read();\n    }\n    audio.stopService();\n  }", "LocalizedBug": "Audio.playSound(Audio.getAudioStream(\"./etc/Bass-Drum-1.wav\"), -10.0f);\nAudio.playSound(Audio.getAudioStream(\"./etc/Closed-Hi-Hat-1.wav\"), -8.0f);\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\nAudio.stopService();", "LocalizedPatchLength": 241, "CodeLength": 438}
{"BuggyCode": "private List<String> readContractList() {\n        return ResourceLoader\n            .getBufferedReader(getClass(), SLA_CONTRACTS_LIST)\n            .lines()\n            .map(String::trim)\n            .filter(line -> !line.isEmpty())\n            .filter(line -> !line.startsWith(\"#\"))\n            .collect(toList());\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.InputStreamReader` acquired by call to `getBufferedReader(...)` at line 106 is not released after line 107."}, "FixedCode": "private List<String> readContractList() {\n        return ResourceLoader\n            .newBufferedReader(SLA_CONTRACTS_LIST, getClass())\n            .lines()\n            .map(String::trim)\n            .filter(line -> !line.isEmpty())\n            .filter(line -> !line.startsWith(\"#\"))\n            .collect(toList());\n    }", "LocalizedBug": ".getBufferedReader(getClass(), SLA_CONTRACTS_LIST)", "LocalizedPatchLength": 50, "CodeLength": 320}
{"BuggyCode": "@Test\n    public void testGetRecords() throws IOException {\n        final CSVParser parser = CSVParser.parseString(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n        final List<CSVRecord> records = parser.getRecords();\n        assertEquals(RESULT.length, records.size());\n        assertTrue(records.size() > 0);\n        for (int i = 0; i < RESULT.length; i++) {\n            assertArrayEquals(RESULT[i], records.get(i).values());\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.commons.csv.ExtendedBufferedReader` acquired by call to `parseString(...)` at line 83 is not released after line 84."}, "FixedCode": "@Test\n    public void testGetRecords() throws IOException {\n        final CSVParser parser = CSVParser.parse(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n        final List<CSVRecord> records = parser.getRecords();\n        assertEquals(RESULT.length, records.size());\n        assertTrue(records.size() > 0);\n        for (int i = 0; i < RESULT.length; i++) {\n            assertArrayEquals(RESULT[i], records.get(i).values());\n        }\n    }", "LocalizedBug": "final CSVParser parser = CSVParser.parseString(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));", "LocalizedPatchLength": 110, "CodeLength": 465}
{"BuggyCode": "private byte[] responseToBytes() {\n\t\ttry {\n\t\t\treturn response.renderToBytes();\n\n\t\t} catch (Throwable e) {\n\t\t\tHttpIO.error(this, e, Customization.of(this).errorHandler());\n\n\t\t\ttry {\n\t\t\t\treturn response.renderToBytes();\n\n\t\t\t} catch (Exception e1) {\n\t\t\t\tLog.error(\"Internal rendering error!\", e1);\n\t\t\t\treturn HttpUtils.getErrorMessageAndSetCode(response, e1).getBytes();\n\t\t\t}\n\t\t}\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `of(this).errorHandler()` could be null and is dereferenced by call to `error(...)` at line 518."}, "FixedCode": "private byte[] responseToBytes() {\n\t\ttry {\n\t\t\treturn response.renderToBytes();\n\n\t\t} catch (Throwable e) {\n\t\t\tHttpIO.error(this, e);\n\n\t\t\ttry {\n\t\t\t\treturn response.renderToBytes();\n\n\t\t\t} catch (Exception e1) {\n\t\t\t\tLog.error(\"Internal rendering error!\", e1);\n\t\t\t\treturn HttpUtils.getErrorMessageAndSetCode(response, e1).getBytes();\n\t\t\t}\n\t\t}\n\t}", "LocalizedBug": "HttpIO.error(this, e, Customization.of(this).errorHandler());", "LocalizedPatchLength": 61, "CodeLength": 379}
{"BuggyCode": "@Override\n  public List<Task> assignTasks(TaskTracker taskTracker)\n      throws IOException {\n    HttpHost tracker = new HttpHost(taskTracker.getStatus().getHost(),\n        taskTracker.getStatus().getHttpPort());\n\n    if (!mesosTrackers.containsKey(tracker)) {\n      LOG.info(\"Unknown/exited TaskTracker: \" + tracker + \". \");\n      return null;\n    }\n    // Let the underlying task scheduler do the actual task scheduling.\n    List<Task> tasks = taskScheduler.assignTasks(taskTracker);\n\n    // The Hadoop Fair Scheduler is known to return null.\n    if (tasks == null) {\n      return null;\n    }\n\n    // Keep track of which TaskTracker contains which tasks.\n    for (Task task : tasks) {\n      mesosTrackers.get(tracker).jobs.add(task.getJobID());\n    }\n\n    return tasks;\n  }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.apache.hadoop.mapred.MesosScheduler.assignTasks` reads without synchronization from `this.org.apache.hadoop.mapred.MesosScheduler.taskScheduler`. Potentially races with write in method `MesosScheduler.start()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n  public List<Task> assignTasks(TaskTracker taskTracker)\n      throws IOException {\n    HttpHost tracker = new HttpHost(taskTracker.getStatus().getHost(),\n        taskTracker.getStatus().getHttpPort());\n\n    if (!mesosTrackers.containsKey(tracker)) {\n      LOG.info(\"Unknown/exited TaskTracker: \" + tracker + \". \");\n      return null;\n    }\n\n    MesosTracker mesosTracker = mesosTrackers.get(tracker);\n\n    // Make sure we're not asked to assign tasks to any task trackers that have\n    // been stopped. This could happen while the task tracker has not been\n    // removed from the cluster e.g still in the heartbeat timeout period.\n    synchronized (this) {\n      if (mesosTracker.stopped) {\n        LOG.info(\"Asked to assign tasks to stopped tracker \" + tracker + \".\");\n        return null;\n      }\n    }\n\n    // Let the underlying task scheduler do the actual task scheduling.\n    List<Task> tasks = taskScheduler.assignTasks(taskTracker);\n\n    // The Hadoop Fair Scheduler is known to return null.\n    if (tasks == null) {\n      return null;\n    }\n\n    // Keep track of which TaskTracker contains which tasks.\n    for (Task task : tasks) {\n      mesosTracker.jobs.add(task.getJobID());\n    }\n\n    return tasks;\n  }", "LocalizedBug": "mesosTrackers.get(tracker).jobs.add(task.getJobID());", "LocalizedPatchLength": 53, "CodeLength": 775}
{"BuggyCode": "public void testSimpleHttpGets() throws Exception {\n        HttpRequestExecutionHandler requestExecutionHandler = new TestRequestExecutionHandler() {\n\n            @Override\n            protected HttpRequest generateRequest(TestJob testjob) {\n                String s = testjob.getPattern() + \"x\" + testjob.getCount();\n                return new BasicHttpRequest(\"GET\", s);\n            }\n\n        };\n        executeStandardTest(new TestRequestHandler(), requestExecutionHandler);\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.apache.http.nio.protocol.TestThrottlingNHttpHandlers.testSimpleHttpGets` indirectly writes to field `this.org.apache.http.HttpCoreNIOTestBase.server.org.apache.http.mockup.TestHttpServerNio.endpoint` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public void testSimpleHttpGets() throws Exception {\n        HttpRequestExecutionHandler requestExecutionHandler = new RequestExecutionHandler() {\n\n            @Override\n            protected HttpRequest generateRequest(Job testjob) {\n                String s = testjob.getPattern() + \"x\" + testjob.getCount();\n                return new BasicHttpRequest(\"GET\", s);\n            }\n\n        };\n        executeStandardTest(new RequestHandler(), requestExecutionHandler);\n    }", "LocalizedBug": "HttpRequestExecutionHandler requestExecutionHandler = new TestRequestExecutionHandler() {\nprotected HttpRequest generateRequest(TestJob testjob) {\nexecuteStandardTest(new TestRequestHandler(), requestExecutionHandler);", "LocalizedPatchLength": 218, "CodeLength": 484}
{"BuggyCode": "@Test\n    public void testLoadVertexProperties() {\n        Vertex marko = this.sqlgGraph.addVertex(T.label, \"Person\", \"name\", \"marko\");\n        this.sqlgGraph.tx().commit();\n        marko = this.sqlgGraph.v(marko.id());\n        Assert.assertEquals(\"marko\", marko.property(\"name\").value());\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `marko` last assigned on line 19 could be null and is dereferenced at line 20."}, "FixedCode": "@Test\n    public void testLoadVertexProperties() {\n        Vertex marko = this.sqlgGraph.addVertex(T.label, \"Person\", \"name\", \"marko\");\n        this.sqlgGraph.tx().commit();\n        marko = this.sqlgGraph.traversal().V(marko.id()).next();\n        Assert.assertEquals(\"marko\", marko.property(\"name\").value());\n    }", "LocalizedBug": "marko = this.sqlgGraph.v(marko.id());", "LocalizedPatchLength": 37, "CodeLength": 295}
{"BuggyCode": "@Test\n    public void testWriteAndRead() throws Exception {\n        try (DirectStore allocate = DirectStore.allocate(150)) {\n\n            final BytesQueue bytesRingBuffer = new BytesQueue(allocate.bytes());\n            bytesRingBuffer.offer(output.clear());\n            Bytes poll = bytesRingBuffer.poll(input.clear());\n            assertEquals(EXPECTED, poll.readUTF());\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `poll` last assigned on line 68 could be null and is dereferenced at line 69."}, "FixedCode": "@Test\n    public void testWriteAndRead() throws Exception {\n        try (DirectStore allocate = DirectStore.allocate(150)) {\n\n            final BytesRingBuffer bytesRingBuffer = new BytesRingBuffer(allocate.bytes());\n            bytesRingBuffer.offer(output.clear());\n            Bytes actual = bytesRingBuffer.take(maxSize -> input.clear());\n            assertEquals(EXPECTED, actual.readUTF());\n        }\n    }", "LocalizedBug": "final BytesQueue bytesRingBuffer = new BytesQueue(allocate.bytes());\nBytes poll = bytesRingBuffer.poll(input.clear());\nassertEquals(EXPECTED, poll.readUTF());", "LocalizedPatchLength": 158, "CodeLength": 387}
{"BuggyCode": "public void checkVersionSupport(byte[] keepassFile) throws IOException {\n\t\tBufferedInputStream bufferedInputStream = new BufferedInputStream(new ByteArrayInputStream(keepassFile));\n\n\t\tbyte[] signature = new byte[VERSION_SIGNATURE_LENGTH];\n\t\tbufferedInputStream.read(signature);\n\n\t\tByteBuffer signatureBuffer = ByteBuffer.wrap(signature);\n\t\tsignatureBuffer.order(ByteOrder.LITTLE_ENDIAN);\n\n\t\tint signaturePart1 = ByteUtils.toUnsignedInt(signatureBuffer.getInt());\n\t\tint signaturePart2 = ByteUtils.toUnsignedInt(signatureBuffer.getInt());\n\n\t\tif (signaturePart1 == DATABASE_V2_FILE_SIGNATURE_1_INT && signaturePart2 == DATABASE_V2_FILE_SIGNATURE_2_INT) {\n\t\t\treturn;\n\t\t} else if (signaturePart1 == OLD_DATABASE_V1_FILE_SIGNATURE_1_INT\n\t\t\t\t&& signaturePart2 == OLD_DATABASE_V1_FILE_SIGNATURE_2_INT) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"The provided KeePass database file seems to be from KeePass 1.x which is not supported!\");\n\t\t} else {\n\t\t\tthrow new UnsupportedOperationException(\"The provided file seems to be no KeePass database file!\");\n\t\t}\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.BufferedInputStream` acquired to `bufferedInputStream` by call to `new()` at line 92 is not released after line 95."}, "FixedCode": "public void checkVersionSupport(byte[] keepassFile) throws IOException {\n\t\tBufferedInputStream inputStream = new BufferedInputStream(new ByteArrayInputStream(keepassFile));\n\n\t\tbyte[] signature = new byte[VERSION_SIGNATURE_LENGTH];\n\t\tint readBytes = inputStream.read(signature);\n\t\tif(readBytes == -1) {\n\t\t\tthrow new UnsupportedOperationException(\"Could not read KeePass header. The provided file seems to be no KeePass database file!\");\n\t\t}\n\n\t\tByteBuffer signatureBuffer = ByteBuffer.wrap(signature);\n\t\tsignatureBuffer.order(ByteOrder.LITTLE_ENDIAN);\n\n\t\tint signaturePart1 = ByteUtils.toUnsignedInt(signatureBuffer.getInt());\n\t\tint signaturePart2 = ByteUtils.toUnsignedInt(signatureBuffer.getInt());\n\n\t\tif (signaturePart1 == DATABASE_V2_FILE_SIGNATURE_1_INT && signaturePart2 == DATABASE_V2_FILE_SIGNATURE_2_INT) {\n\t\t\treturn;\n\t\t} else if (signaturePart1 == OLD_DATABASE_V1_FILE_SIGNATURE_1_INT\n\t\t\t\t&& signaturePart2 == OLD_DATABASE_V1_FILE_SIGNATURE_2_INT) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\"The provided KeePass database file seems to be from KeePass 1.x which is not supported!\");\n\t\t} else {\n\t\t\tthrow new UnsupportedOperationException(\"The provided file seems to be no KeePass database file!\");\n\t\t}\n\t}", "LocalizedBug": "BufferedInputStream bufferedInputStream = new BufferedInputStream(new ByteArrayInputStream(keepassFile));\nbufferedInputStream.read(signature);", "LocalizedPatchLength": 142, "CodeLength": 1057}
{"BuggyCode": "@Test\n    public void testEndOfFileBehaviorCSV() throws Exception {\n        final String[] codes = {\n                \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n                \"hello,\\r\\n\\r\\nworld,\",\n                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n                \"hello,\\r\\n\\r\\nworld,\\n\",\n                \"hello,\\r\\n\\r\\nworld,\",\n                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n        };\n        final String[][] res = {\n                {\"hello\", \"\"},  // CSV format ignores empty lines\n                {\"world\", \"\"}\n        };\n        for (final String code : codes) {\n            final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n            final List<CSVRecord> records = parser.getRecords();\n            assertEquals(res.length, records.size());\n            assertTrue(records.size() > 0);\n            for (int i = 0; i < res.length; i++) {\n                assertArrayEquals(res[i], records.get(i).values());\n            }\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.commons.csv.ExtendedBufferedReader` acquired by call to `parseString(...)` at line 178 is not released after line 179."}, "FixedCode": "@Test\n    public void testEndOfFileBehaviorCSV() throws Exception {\n        final String[] codes = {\n                \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n                \"hello,\\r\\n\\r\\nworld,\",\n                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n                \"hello,\\r\\n\\r\\nworld,\\n\",\n                \"hello,\\r\\n\\r\\nworld,\",\n                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n        };\n        final String[][] res = {\n                {\"hello\", \"\"},  // CSV format ignores empty lines\n                {\"world\", \"\"}\n        };\n        for (final String code : codes) {\n            final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n            final List<CSVRecord> records = parser.getRecords();\n            assertEquals(res.length, records.size());\n            assertTrue(records.size() > 0);\n            for (int i = 0; i < res.length; i++) {\n                assertArrayEquals(res[i], records.get(i).values());\n            }\n        }\n    }", "LocalizedBug": "final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);", "LocalizedPatchLength": 72, "CodeLength": 1037}
{"BuggyCode": "@Test\n  public void testDataStreamDisabled() throws Exception {\n    try {\n      setup(1);\n      final DataStreamClientImpl client = newDataStreamClientImpl();\n      exception.expect(UnsupportedOperationException.class);\n      exception.expectMessage(DisabledDataStreamClientFactory.class.getName()\n          + \"$1 does not support streamAsync\");\n      // stream() will create a header request, thus it will hit UnsupportedOperationException due to\n      // DisabledDataStreamFactory.\n      client.stream();\n    } finally {\n      shutdown();\n    }\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.ratis.client.impl.DataStreamClientImpl` acquired to `client` by call to `newDataStreamClientImpl()` at line 43 is not released after line 49."}, "FixedCode": "@Test\n  public void testDataStreamDisabled() throws Exception {\n    try {\n      setup(1);\n      final RaftClient client = newRaftClientForDataStream();\n      exception.expect(UnsupportedOperationException.class);\n      exception.expectMessage(DisabledDataStreamClientFactory.class.getName()\n          + \"$1 does not support streamAsync\");\n      // stream() will create a header request, thus it will hit UnsupportedOperationException due to\n      // DisabledDataStreamFactory.\n      client.getDataStreamApi().stream();\n    } finally {\n      shutdown();\n    }\n  }", "LocalizedBug": "final DataStreamClientImpl client = newDataStreamClientImpl();", "LocalizedPatchLength": 62, "CodeLength": 550}
{"BuggyCode": "private void checkCache() {\n        if (null == blockService) {\n            blockService = NulsContext.getServiceBean(BlockService.class);\n        }\n        Block block = blockService.getBlock(blockService.getLocalSavedHeight());\n        boolean b = (TimeService.currentTimeMillis() - startTime) > 300000;\n        b = b && (TimeService.currentTimeMillis() - block.getHeader().getTime()) > 300000;\n        if (b) {\n            ConsensusManager consensusManager = ConsensusManager.getInstance();\n            consensusManager.destroy();\n            NulsContext.getInstance().setBestBlock(blockService.getBlock(blockService.getLocalSavedHeight()));\n            this.startTime = TimeService.currentTimeMillis();\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `BlockCacheCheckThread.blockService` last assigned on line 64 could be null and is dereferenced at line 66."}, "FixedCode": "private void checkCache() {\n//        if (null == blockService) {\n//            blockService = NulsContext.getServiceBean(BlockService.class);\n//        }\n//        Block block = blockService.getBlock(blockService.getLocalSavedHeight());\n//        boolean b = (TimeService.currentTimeMillis() - startTime) > 300000;\n//        b = b && (TimeService.currentTimeMillis() - block.getHeader().getTime()) > 300000;\n//        if (b) {\n//            ConsensusManager consensusManager = ConsensusManager.getInstance();\n//            consensusManager.destroy();\n//            this.startTime = TimeService.currentTimeMillis();\n//        }\n    }", "LocalizedBug": "NulsContext.getInstance().setBestBlock(blockService.getBlock(blockService.getLocalSavedHeight()));", "LocalizedPatchLength": 98, "CodeLength": 722}
{"BuggyCode": "public static List<VariableModification<BigInteger>> modificationsFromFile() {\n        try {\n            if (modificationsFromFile == null) {\n                modificationsFromFile = new LinkedList<>();\n                ClassLoader classLoader = IntegerModificationFactory.class.getClassLoader();\n                File file = new File(classLoader.getResource(IntegerModificationFactory.FILE_NAME).getFile());\n                BufferedReader br = new BufferedReader(new FileReader(file));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    String value = line.trim().split(\" \")[0];\n                    modificationsFromFile.add(explicitValue(value));\n                }\n            }\n            return modificationsFromFile;\n        } catch (IOException ex) {\n            throw new FileConfigurationException(\"Modifiable variable file name could not have been found.\", ex);\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileReader` acquired by call to `new()` at line 100 is not released after line 108.\n**Note**: potential exception at line 102"}, "FixedCode": "public static List<VariableModification<BigInteger>> modificationsFromFile() {\n        try {\n            if (modificationsFromFile == null) {\n                modificationsFromFile = new LinkedList<>();\n                ClassLoader classLoader = IntegerModificationFactory.class.getClassLoader();\n                File file = new File(classLoader.getResource(IntegerModificationFactory.FILE_NAME).getFile());\n                try(BufferedReader br = new BufferedReader(new FileReader(file))) {\n                    String line;\n                    while ((line = br.readLine()) != null) {\n                        String value = line.trim().split(\" \")[0];\n                        modificationsFromFile.add(explicitValue(value));\n                    }\n                }\n            }\n            return modificationsFromFile;\n        } catch (IOException ex) {\n            throw new FileConfigurationException(\"Modifiable variable file name could not have been found.\", ex);\n        }\n    }", "LocalizedBug": "BufferedReader br = new BufferedReader(new FileReader(file));", "LocalizedPatchLength": 61, "CodeLength": 939}
{"BuggyCode": "@Override\n    public HWDiskStore[] getDisks() {\n        List<HWDiskStore> result;\n        result = new ArrayList<>();\n\n        Map<String, List<String>> vals = WmiUtil.selectStringsFrom(null, \"Win32_DiskDrive\",\n                \"Name,Manufacturer,Model,SerialNumber,Size\", null);\n        for (int i = 0; i < vals.get(\"Name\").size(); i++) {\n            HWDiskStore ds = new HWDiskStore();\n            ds.setName(vals.get(\"Name\").get(i));\n            ds.setModel(String.format(\"%s %s\", vals.get(\"Model\").get(i), vals.get(\"Manufacturer\").get(i)).trim());\n            // Most vendors store serial # as a hex string; convert\n            ds.setSerial(ParseUtil.hexStringToString(vals.get(\"SerialNumber\").get(i)));\n            // If successful this line is the desired value\n            try {\n                ds.setSize(Long.parseLong(vals.get(\"Size\").get(i)));\n            } catch (NumberFormatException e) {\n                // If we failed to parse, give up\n                // This is expected for an empty string on some drives\n                ds.setSize(0L);\n            }\n            result.add(ds);\n        }\n        return result.toArray(new HWDiskStore[result.size()]);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `vals.get(\"Model\")` could be null and is dereferenced at line 49."}, "FixedCode": "@Override\n    public HWDiskStore[] getDisks() {\n        List<HWDiskStore> result;\n        result = new ArrayList<>();\n        readMap.clear();\n        writeMap.clear();\n        populateReadWriteMaps();\n\n        Map<String, List<Object>> vals = WmiUtil.selectObjectsFrom(null, \"Win32_DiskDrive\",\n                \"Name,Manufacturer,Model,SerialNumber,Size,Index\", null, DRIVE_TYPES);\n        for (int i = 0; i < vals.get(\"Name\").size(); i++) {\n            HWDiskStore ds = new HWDiskStore();\n            ds.setName((String) vals.get(\"Name\").get(i));\n            ds.setModel(String.format(\"%s %s\", vals.get(\"Model\").get(i), vals.get(\"Manufacturer\").get(i)).trim());\n            // Most vendors store serial # as a hex string; convert\n            ds.setSerial(ParseUtil.hexStringToString((String) vals.get(\"SerialNumber\").get(i)));\n            String index = vals.get(\"Index\").get(i).toString();\n            if (readMap.containsKey(index)) {\n                ds.setReads(readMap.get(index));\n            }\n            if (writeMap.containsKey(index)) {\n                ds.setWrites(writeMap.get(index));\n            }\n            // If successful this line is the desired value\n            try {\n                ds.setSize(Long.parseLong((String) vals.get(\"Size\").get(i)));\n            } catch (NumberFormatException e) {\n                // If we failed to parse, give up\n                // This is expected for an empty string on some drives\n                ds.setSize(0L);\n            }\n            result.add(ds);\n        }\n        return result.toArray(new HWDiskStore[result.size()]);\n    }", "LocalizedBug": "Map<String, List<String>> vals = WmiUtil.selectStringsFrom(null, \"Win32_DiskDrive\",", "LocalizedPatchLength": 83, "CodeLength": 1175}
{"BuggyCode": "@Test\n    public void skillViolationAtAct1_shouldWork(){\n        SolutionAnalyser analyser = new SolutionAnalyser(vrp,solution, new SolutionAnalyser.DistanceCalculator() {\n            @Override\n            public double getDistance(String fromLocationId, String toLocationId) {\n                return vrp.getTransportCosts().getTransportCost(fromLocationId,toLocationId,0.,null,null);\n            }\n        });\n        VehicleRoute route = solution.getRoutes().iterator().next();\n        Boolean violated = analyser.skillConstraintIsViolatedAtActivity(route.getActivities().get(0),route);\n        assertFalse(violated);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `violated` last assigned on line 1791 could be null and is dereferenced at line 1792."}, "FixedCode": "@Test\n    public void skillViolationAtAct1_shouldWork(){\n        SolutionAnalyser analyser = new SolutionAnalyser(vrp,solution, new SolutionAnalyser.DistanceCalculator() {\n            @Override\n            public double getDistance(String fromLocationId, String toLocationId) {\n                return vrp.getTransportCosts().getTransportCost(fromLocationId,toLocationId,0.,null,null);\n            }\n        });\n        VehicleRoute route = solution.getRoutes().iterator().next();\n        Boolean violated = analyser.hasSkillConstraintViolationAtActivity(route.getActivities().get(0), route);\n        assertFalse(violated);\n    }", "LocalizedBug": "Boolean violated = analyser.skillConstraintIsViolatedAtActivity(route.getActivities().get(0),route);", "LocalizedPatchLength": 100, "CodeLength": 625}
{"BuggyCode": "@Override\n\tpublic void copySnapshot() {\n\t\tint length = dirtyIndex.get();\n\t\tif (length <= dirtyArray.length) {\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tint index = dirtyArray[i];\n\t\t\t\tthis.snapshot[index] = live[index];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < live.length; i++) {\n\t\t\t\tthis.snapshot[i] = live[i];\n\t\t\t}\n\t\t}\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.getspout.server.util.thread.snapshotable.SnapshotableShortArray.copySnapshot` reads without synchronization from `this.org.getspout.server.util.thread.snapshotable.SnapshotableShortArray.dirtyArray.[_]`. Potentially races with write in method `SnapshotableShortArray.set(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n\tpublic void copySnapshot() {\n\t\tint length = dirtyIndex.get();\n\t\tif (length <= dirtySize) {\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tint index = dirtyArray.get(i);\n\t\t\t\tthis.snapshot[index] = getLive(i);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < snapshot.length; i++) {\n\t\t\t\tthis.snapshot[i] = getLive(i);\n\t\t\t}\n\t\t}\n\t}", "LocalizedBug": "if (length <= dirtyArray.length) {\nint index = dirtyArray[i];\nthis.snapshot[index] = live[index];\nfor (int i = 0; i < live.length; i++) {\nthis.snapshot[i] = live[i];", "LocalizedPatchLength": 165, "CodeLength": 321}
{"BuggyCode": "@Override\n\tpublic List<?> getClasses(){\n\t\tList<Object> result = new ArrayList<>();\n\n\t\tList<?> values = (List<?>)get(\"classes_\");\n\t\tfor(Object value : values){\n\n\t\t\tif(value instanceof HasArray){\n\t\t\t\tHasArray hasArray = (HasArray)value;\n\n\t\t\t\tresult.addAll(hasArray.getArrayContent());\n\t\t\t} else\n\n\t\t\t{\n\t\t\t\tresult.add(value);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `values` last assigned on line 55 could be null and is dereferenced at line 56."}, "FixedCode": "@Override\n\tpublic List<?> getClasses(){\n\t\tLabelEncoder labelEncoder = getLabelEncoder();\n\n\t\treturn labelEncoder.getClasses();\n\t}", "LocalizedBug": "List<Object> result = new ArrayList<>();\nList<?> values = (List<?>)get(\"classes_\");\nfor(Object value : values){\nif(value instanceof HasArray){\nHasArray hasArray = (HasArray)value;\nresult.addAll(hasArray.getArrayContent());\n} else\n{\nresult.add(value);\n}\n}\nreturn result;\n}", "LocalizedPatchLength": 271, "CodeLength": 351}
{"BuggyCode": "@Override\n    public Response act(final RqRegex req) throws IOException {\n        final String pid = req.matcher().group(1);\n        final Project pmo = new Pmo(this.farm);\n        final Catalog catalog = new Catalog(pmo).bootstrap();\n        if (!catalog.exists(pid)) {\n            throw new RsForward(\n                new RsParFlash(\n                    new Par(\"Project %s not found\").say(pid),\n                    Level.WARNING\n                )\n            );\n        }\n        return new RsWithHeaders(\n            new RsWithType(\n                new RsWithBody(\n                    this.getClass().getResource(\"badge.svg\")\n                ),\n                \"image/svg+xml\"\n            ),\n            \"Cache-Control: no-cache\",\n            String.format(\"X-Zerocracy-Project-ID: %s\", pid)\n        );\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.farm.fake.FkFarm` acquired by call to `Par(...)` at line 64 is not released after line 66."}, "FixedCode": "@Override\n    public Response act(final RqRegex req) throws IOException {\n        final Project project = new RqProject(this.farm, req);\n        return new RsWithHeaders(\n            new RsWithType(\n                new RsWithBody(\n                    this.getClass().getResource(\"badge.svg\")\n                ),\n                \"image/svg+xml\"\n            ),\n            \"Cache-Control: no-cache\",\n            String.format(\"X-Zerocracy-Project-ID: %s\", project.pid())\n        );\n    }", "LocalizedBug": "final String pid = req.matcher().group(1);\nfinal Project pmo = new Pmo(this.farm);\nfinal Catalog catalog = new Catalog(pmo).bootstrap();\nif (!catalog.exists(pid)) {\nthrow new RsForward(\nnew RsParFlash(\nnew Par(\"Project %s not found\").say(pid),\nLevel.WARNING\n)\n);\n}", "LocalizedPatchLength": 264, "CodeLength": 812}
{"BuggyCode": "@Override\n    protected void releaseSub() {\n        if (transceiver != null) {\n            try {\n                transceiver.close();\n            } catch (final IOException ioe) {\n                LOGGER.error(\"Attempt to clean up Avro transceiver failed\", ioe);\n            }\n        }\n        client = null;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.apache.logging.log4j.flume.appender.FlumeAvroManager.releaseSub` reads without synchronization from `this.org.apache.logging.log4j.flume.appender.FlumeAvroManager.transceiver`. Potentially races with write in method `FlumeAvroManager.send(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n    protected void releaseSub() {\n        if (rpcClient != null) {\n            try {\n                rpcClient.close();\n            } catch (final Exception ex) {\n                LOGGER.error(\"Attempt to close RPC client failed\", ex);\n            }\n        }\n        rpcClient = null;\n    }", "LocalizedBug": "if (transceiver != null) {\ntransceiver.close();\n} catch (final IOException ioe) {\nLOGGER.error(\"Attempt to clean up Avro transceiver failed\", ioe);\nclient = null;", "LocalizedPatchLength": 162, "CodeLength": 314}
{"BuggyCode": "@Test\n    public void testAppender() throws Exception {\n        final Logger logger = ctx.getLogger();\n        logger.debug(\"This is test message number 1\");\n        Thread.sleep(1500);\n        // Trigger the rollover\n        for (int i = 0; i < 16; ++i) {\n            logger.debug(\"This is test message number \" + i + 1);\n        }\n        final File dir = new File(DIR);\n        assertTrue(\"Directory not created\", dir.exists() && dir.listFiles().length > 0);\n\n        final int MAX_TRIES = 20;\n        for (int i = 0; i < MAX_TRIES; i++) {\n            final File[] files = dir.listFiles();\n            assertTrue(\"No files created\", files.length > 0);\n            for (final File file : files) {\n                if (file.getName().endsWith(\".gz\")) {\n                    return; // test succeeded\n                }\n            }\n            logger.debug(\"Adding additional event \" + i);\n            Thread.sleep(100); // Allow time for rollover to complete\n        }\n        fail(\"No compressed files found\");\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `dir.listFiles()` could be null and is dereferenced at line 58."}, "FixedCode": "@Test\n    public void testAppender() throws Exception {\n        final Logger logger = ctx.getLogger();\n        logger.debug(\"This is test message number 1\");\n        Thread.sleep(1500);\n        // Trigger the rollover\n        for (int i = 0; i < 16; ++i) {\n            logger.debug(\"This is test message number \" + i + 1);\n        }\n        final File dir = new File(DIR);\n        assertThat(dir, both(exists()).and(hasFiles()));\n\n        final int MAX_TRIES = 20;\n        final Matcher<File[]> hasGzippedFile = hasItemInArray(that(hasName(that(endsWith(\".gz\")))));\n        for (int i = 0; i < MAX_TRIES; i++) {\n            final File[] files = dir.listFiles();\n            if (hasGzippedFile.matches(files)) {\n                return; // test succeeded\n            }\n            logger.debug(\"Adding additional event \" + i);\n            Thread.sleep(100); // Allow time for rollover to complete\n        }\n        fail(\"No compressed files found\");\n    }", "LocalizedBug": "assertTrue(\"Directory not created\", dir.exists() && dir.listFiles().length > 0);\nassertTrue(\"No files created\", files.length > 0);\nfor (final File file : files) {\nif (file.getName().endsWith(\".gz\")) {\n}", "LocalizedPatchLength": 202, "CodeLength": 1017}
{"BuggyCode": "public TransferTransaction createTransferTx(CoinTransferData transferData, String password, String remark) throws Exception {\n        TransferTransaction tx = new TransferTransaction(transferData, password);\n        tx.setRemark(remark.getBytes(NulsContext.DEFAULT_ENCODING));\n        tx.setHash(NulsDigestData.calcDigestData(tx.serialize()));\n        tx.setSign(getAccountService().signData(tx.getHash(), password));\n        return tx;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getAccountService(this)` could be null and is dereferenced at line 72."}, "FixedCode": "public TransferTransaction createTransferTx(CoinTransferData transferData, String password, String remark) throws Exception {\n        TransferTransaction tx = new TransferTransaction(transferData, password);\n        tx.setRemark(remark.getBytes(NulsContext.DEFAULT_ENCODING));\n        tx.setHash(NulsDigestData.calcDigestData(tx.serialize()));\n        AccountService accountService = getAccountService();\n        if (transferData.getFrom().isEmpty()) {\n            throw new NulsRuntimeException(ErrorCode.DATA_ERROR);\n        }\n        Account account = accountService.getAccount(transferData.getFrom().get(0));\n        tx.setSign(accountService.signData(tx.getHash(), account, password));\n        return tx;\n    }", "LocalizedBug": "tx.setSign(getAccountService().signData(tx.getHash(), password));", "LocalizedPatchLength": 65, "CodeLength": 442}
{"BuggyCode": "public static GoogleTaskUsageTraceReader getInstance(\n        final List<DatacenterBroker> brokers,\n        final String filePath)\n    {\n        final InputStream reader = ResourceLoader.getInputStream(filePath, GoogleTaskUsageTraceReader.class);\n        return new GoogleTaskUsageTraceReader(brokers, filePath, reader);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileInputStream` acquired by call to `getInputStream(...)` at line 276 is not released after line 277.\n**Note**: potential exception at line 277"}, "FixedCode": "public static GoogleTaskUsageTraceReader getInstance(\n        final List<DatacenterBroker> brokers,\n        final String filePath)\n    {\n        final InputStream reader = ResourceLoader.newInputStream(filePath, GoogleTaskUsageTraceReader.class);\n        return new GoogleTaskUsageTraceReader(brokers, filePath, reader);\n    }", "LocalizedBug": "final InputStream reader = ResourceLoader.getInputStream(filePath, GoogleTaskUsageTraceReader.class);", "LocalizedPatchLength": 101, "CodeLength": 326}
{"BuggyCode": "@Test\n    public void testBoldWithStrong()\n        throws Exception\n    {\n        IContext context = null;\n        BufferedElement parent = null;\n\n        ITextStylingTransformer formatter = HTMLTextStylingTransformer.INSTANCE;\n        IDocumentHandler handler = new DocxDocumentHandler( parent, context, \"word/document.xml\" );\n        formatter.transform( \"<strong>text</strong>\", handler );\n        Assert.assertEquals( \"<w:r><w:rPr><w:b /></w:rPr><w:t xml:space=\\\"preserve\\\" >text</w:t></w:r>\",\n                             handler.getTextBody() );\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `context` last assigned on line 62 could be null and is dereferenced by call to `DocxDocumentHandler(...)` at line 66."}, "FixedCode": "@Test\n    public void testBoldWithStrong()\n        throws Exception\n    {\n        IContext context = new MockContext();\n        BufferedElement parent = null;\n\n        ITextStylingTransformer formatter = HTMLTextStylingTransformer.INSTANCE;\n        IDocumentHandler handler = new DocxDocumentHandler( parent, context, \"word/document.xml\" );\n        formatter.transform( \"<strong>text</strong>\", handler );\n        Assert.assertEquals( \"<w:r><w:rPr><w:b /></w:rPr><w:t xml:space=\\\"preserve\\\" >text</w:t></w:r>\",\n                             handler.getTextBody() );\n    }", "LocalizedBug": "IContext context = null;", "LocalizedPatchLength": 24, "CodeLength": 557}
{"BuggyCode": "@Test\n    public void shouldBeReadOnly() throws Exception {\n        final File tempFile = File.createTempFile(\"mapped\", \"bytes\");\n        final RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\");\n        raf.setLength(4096);\n        assertTrue(tempFile.setWritable(false));\n        final MappedBytes mappedBytes = MappedBytes.readOnly(tempFile);\n\n        assertTrue(mappedBytes.\n                isBackingFileReadOnly());\n        mappedBytes.release();\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.RandomAccessFile` acquired to `raf` by call to `RandomAccessFile(...)` at line 27 is not released after line 28."}, "FixedCode": "@Test\n    public void shouldBeReadOnly() throws Exception {\n        final File tempFile = File.createTempFile(\"mapped\", \"bytes\");\n        tempFile.deleteOnExit();\n        try (RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\")) {\n            raf.setLength(4096);\n            assertTrue(tempFile.setWritable(false));\n            try (MappedBytes mappedBytes = MappedBytes.readOnly(tempFile)) {\n                assertTrue(mappedBytes.isBackingFileReadOnly());\n            }\n        }\n\n    }", "LocalizedBug": "final RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\");\nfinal MappedBytes mappedBytes = MappedBytes.readOnly(tempFile);\nmappedBytes.release();", "LocalizedPatchLength": 153, "CodeLength": 466}
{"BuggyCode": "private void printCounter(CounterMetric counter) {\n\t\toutput.printf(\"        last count = %d%n\", counter.lastCount);\n\t\toutput.printf(\"       total count = %d%n\", counter.totalCount);\n\t\toutput.printf(\"         last rate = %2.2f/s%n\", counter.lastRate);\n\t\toutput.printf(\"         mean rate = %2.2f/s%n\", counter.meanRate);\n\t}", "BugInfo": {"bug_type": "CHECKERS_PRINTF_ARGS", "qualifier": "printf(...) at line 86: parameter 2 is expected to be of type java.lang.Double but java.lang.Long was given."}, "FixedCode": "private void printCounter(CounterMetric counter) {\n\t\toutput.printf(\"        last count = %d%n\", counter.lastCount);\n\t\toutput.printf(\"       total count = %d%n\", counter.totalCount);\n\t\toutput.printf(\"         last rate = %d%n\", counter.lastRate);\n\t\toutput.printf(\"         mean rate = %d%n\", counter.meanRate);\n\t}", "LocalizedBug": "output.printf(\"         last rate = %2.2f/s%n\", counter.lastRate);\noutput.printf(\"         mean rate = %2.2f/s%n\", counter.meanRate);", "LocalizedPatchLength": 133, "CodeLength": 322}
{"BuggyCode": "private void rollbackAppraval(Block block) {\n        if (null == block) {\n            Log.warn(\"the block is null!\");\n            return;\n        }\n        this.rollbackTxList(block.getTxs(), 0, block.getTxs().size());\n        PackingRoundManager.getValidateInstance().calc(this.getBlock(block.getHeader().getPreHash().getDigestHex()));\n        List<String> hashList = this.bifurcateProcessor.getHashList(block.getHeader().getHeight() - 1);\n        if (hashList.size() > 1) {\n            Block preBlock = confirmingBlockCacheManager.getBlock(block.getHeader().getPreHash().getDigestHex());\n            context.setBestBlock(preBlock);\n            this.rollbackAppraval(preBlock);\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getBlock(block.getHeader().getPreHash().getDigestHex())` could be null and is dereferenced by call to `calc(...)` at line 209."}, "FixedCode": "private void rollbackAppraval(Block block) {\n        if (null == block) {\n            Log.warn(\"the block is null!\");\n            return;\n        }\n        this.rollbackTxList(block.getTxs(), 0, block.getTxs().size());\n        Block preBlock =this.getBlock(block.getHeader().getPreHash().getDigestHex());\n        context.setBestBlock(preBlock);\n        PackingRoundManager.getValidateInstance().calc(preBlock);\n        List<String> hashList = this.bifurcateProcessor.getHashList(block.getHeader().getHeight() - 1);\n        if (hashList.size() > 1) {\n            this.rollbackAppraval(preBlock);\n        }\n    }", "LocalizedBug": "PackingRoundManager.getValidateInstance().calc(this.getBlock(block.getHeader().getPreHash().getDigestHex()));\nBlock preBlock = confirmingBlockCacheManager.getBlock(block.getHeader().getPreHash().getDigestHex());\ncontext.setBestBlock(preBlock);", "LocalizedPatchLength": 243, "CodeLength": 694}
{"BuggyCode": "@Override\n    public void remove(String key) {\n        Jboot.getJbootCache().remove(cache_name, key);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getJbootCache()` could be null and is dereferenced at line 38."}, "FixedCode": "@Override\n    public void remove(String key) {\n        Jboot.getCache().remove(cache_name, key);\n    }", "LocalizedBug": "Jboot.getJbootCache().remove(cache_name, key);", "LocalizedPatchLength": 46, "CodeLength": 107}
{"BuggyCode": "public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n            Authentication authentication) throws IOException, ServletException {\n\n        // instead of this, the statement below is introduced: handle(request, response, authentication);\n    \tresponse.setStatus(HttpServletResponse.SC_OK);\n    \tresponse.getOutputStream().print(objectMapper.writeValueAsString(SaUtil.getLoggedInUser().getUserDto()));\n        clearAuthenticationAttributes(request);\n        log.info(\"AuthenticationSuccess: \" + SaUtil.getLoggedInUser().getUserDto());\n        \n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getLoggedInUser()` could be null and is dereferenced at line 34."}, "FixedCode": "public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n            Authentication authentication) throws IOException, ServletException {\n\n        // instead of this, the statement below is introduced: handle(request, response, authentication);\n    \tresponse.setStatus(HttpServletResponse.SC_OK);\n    \tresponse.getOutputStream().print(objectMapper.writeValueAsString(SaUtil.getBean(SaService.class).userForClient()));\n        clearAuthenticationAttributes(request);\n        //log.info(\"AuthenticationSuccess: \" + SaUtil.getLoggedInUser());\n        \n    }", "LocalizedBug": "response.getOutputStream().print(objectMapper.writeValueAsString(SaUtil.getLoggedInUser().getUserDto()));\nlog.info(\"AuthenticationSuccess: \" + SaUtil.getLoggedInUser().getUserDto());", "LocalizedPatchLength": 182, "CodeLength": 593}
{"BuggyCode": "public void run() {\n\t\tif( thread == null )\n\t\t\tthread = Thread.currentThread();\n\t\tinterruptableRun();\n\n\t\ttry {\n\t\t\tif( selector != null ) // if the initialization in <code>tryToConnect</code> fails, it could be null\n\t\t\t\tselector.close();\n\t\t} catch ( IOException e ) {\n\t\t\tonError( e );\n\t\t}\n\t\tcloselock.lock();\n\t\tselector = null;\n\t\tcloselock.unlock();\n\t\ttry {\n\t\t\tchannel.close();\n\t\t} catch ( IOException e ) {\n\t\t\tonError( e );\n\t\t}\n\t\tchannel = null;\n\t\tthread = null;\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.java_websocket.client.WebSocketClient.run` reads without synchronization from `this.org.java_websocket.client.WebSocketClient.thread`. Potentially races with write in method `WebSocketClient.run()`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public void run() {\n\t\tif( thread == null )\n\t\t\tthread = Thread.currentThread();\n\t\tinterruptableRun();\n\t\t\n\t\tassert ( !channel.isOpen() );\n\n\t\ttry {\n\t\t\tif( selector != null ) // if the initialization in <code>tryToConnect</code> fails, it could be null\n\t\t\t\tselector.close();\n\t\t} catch ( IOException e ) {\n\t\t\tonError( e );\n\t\t}\n\n\t}", "LocalizedBug": "closelock.lock();\nselector = null;\ncloselock.unlock();\ntry {\nchannel.close();\n} catch ( IOException e ) {\nonError( e );\n}\nchannel = null;\nthread = null;\n}", "LocalizedPatchLength": 154, "CodeLength": 464}
{"BuggyCode": "Optional<Map<ChunkReference, Chunk>>\n            fetch(HttpClient httpClient, KeyEncryptionKeys keks, Map<Integer, StorageHostChunkList> containers,\n                    Asset asset) {\n        Map<ChunkReference, Chunk> map = new HashMap<>();\n        for (Map.Entry<Integer, StorageHostChunkList> entry : containers.entrySet()) {\n            Optional<Map<ChunkReference, Chunk>> chunks = keks.apply(entry.getValue())\n                    .flatMap(kek -> fetch(httpClient, kek, entry.getValue(), entry.getKey()));\n            if (!chunks.isPresent()) {\n                return Optional.empty();\n            }\n            map.putAll(chunks.get());\n        }\n        return Optional.of(map);\n    }", "BugInfo": {"bug_type": "INTERFACE_NOT_THREAD_SAFE", "qualifier": "Unprotected call to method of un-annotated interface com.github.horrorho.inflatabledonkey.cloud.KeyEncryptionKeys. Consider annotating the class with `@ThreadSafe`, adding a lock, or using an interface that is known to be thread-safe.\n Reporting because the current class is annotated `@ThreadSafe`."}, "FixedCode": "Optional<Map<ChunkReference, Chunk>>\n            fetch(HttpClient httpClient, ChunkKeyEncryptionKeys keks, Map<Integer, StorageHostChunkList> containers,\n                    Asset asset) {\n        Map<ChunkReference, Chunk> map = new HashMap<>();\n        for (Map.Entry<Integer, StorageHostChunkList> entry : containers.entrySet()) {\n            Optional<Map<ChunkReference, Chunk>> chunks = keks.apply(entry.getValue())\n                    .flatMap(kek -> fetch(httpClient, kek, entry.getValue(), entry.getKey()));\n            if (!chunks.isPresent()) {\n                return Optional.empty();\n            }\n            map.putAll(chunks.get());\n        }\n        return Optional.of(map);\n    }", "LocalizedBug": "fetch(HttpClient httpClient, KeyEncryptionKeys keks, Map<Integer, StorageHostChunkList> containers,", "LocalizedPatchLength": 99, "CodeLength": 691}
{"BuggyCode": "@Test\n    public void testCarriageReturnLineFeedEndings() throws IOException {\n        String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n        CSVParser parser = new CSVParser(new StringReader(code));\n        String[][] data = parser.getRecords();\n        assertEquals(4, data.length);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `data` last assigned on line 394 could be null and is dereferenced at line 395."}, "FixedCode": "@Test\n    public void testCarriageReturnLineFeedEndings() throws IOException {\n        String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n        CSVParser parser = new CSVParser(new StringReader(code));\n        List<CSVRecord> records = parser.getRecords();\n        assertEquals(4, records.size());\n    }", "LocalizedBug": "String[][] data = parser.getRecords();\nassertEquals(4, data.length);", "LocalizedPatchLength": 68, "CodeLength": 297}
{"BuggyCode": "void notifyCallEnded(String callResource)\n    {\n        GatewaySession session;\n\n        synchronized (sessions)\n        {\n            session = sessions.remove(callResource);\n\n            if (session == null)\n            {\n                // FIXME: print some gateway ID or provider here\n                logger.error(\n                    \"Call resource not exists for session \" + callResource);\n                return;\n            }\n        }\n\n        logger.info(\"Removed session for call \" + callResource);\n\n        if (callsControl != null)\n        {\n            callsControl.callEnded(this, session.getCallResource());\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.jitsi.jigasi.SipGateway.notifyCallEnded` reads without synchronization from `this.org.jitsi.jigasi.SipGateway.callsControl`. Potentially races with write in method `SipGateway.setCallsControl(...)`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "void notifyCallEnded(String callResource)\n    {\n        GatewaySession session;\n\n        synchronized (sessions)\n        {\n            session = sessions.remove(callResource);\n\n            if (session == null)\n            {\n                // FIXME: print some gateway ID or provider here\n                logger.error(\n                    \"Call resource not exists for session \" + callResource);\n                return;\n            }\n        }\n\n        logger.info(\"Removed session for call \" + callResource);\n    }", "LocalizedBug": "if (callsControl != null)\n{\ncallsControl.callEnded(this, session.getCallResource());\n}", "LocalizedPatchLength": 86, "CodeLength": 639}
{"BuggyCode": "InputStream createUnSortedInputStream() {\n        try {\n            return new ObjectInputStream(new BufferedInputStream(new FileInputStream(unsortedFile)));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.BufferedInputStream` acquired by call to `new()` at line 65 is not released after line 65."}, "FixedCode": "OutputStream createUnsortedOutputStream() {\n        try {\n            return new BufferedOutputStream(new FileOutputStream(unsortedFile));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }", "LocalizedBug": "InputStream createUnSortedInputStream() {\nreturn new ObjectInputStream(new BufferedInputStream(new FileInputStream(unsortedFile)));", "LocalizedPatchLength": 131, "CodeLength": 250}
{"BuggyCode": "@Override\n\tpublic void open() {\n\n\t\tif (!open.compareAndSet(false, true)) {\n\t\t\treturn;\n\t\t}\n\n\t\tLOG.debug(\"Opening GStreamer device\");\n\n\t\tinit();\n\n\t\tstarting.set(true);\n\n\t\tDimension size = getResolution();\n\n\t\timage = new BufferedImage(size.width, size.height, BufferedImage.TYPE_INT_RGB);\n\t\timage.setAccelerationPriority(0);\n\t\timage.flush();\n\n\t\tif (caps != null) {\n\t\t\tcaps.dispose();\n\t\t}\n\n\t\tcaps = Caps.fromString(String.format(\"%s,width=%d,height=%d\", format, size.width, size.height));\n\n\t\tfilter.setCaps(caps);\n\n\t\tLOG.debug(\"Link elements\");\n\n\t\tpipe.addMany(source, filter, sink);\n\t\tElement.linkMany(source, filter, sink);\n\t\tpipe.setState(State.PLAYING);\n\n\t\t// wait max 20s for image to appear\n\t\tsynchronized (this) {\n\t\t\tLOG.debug(\"Wait for device to be ready\");\n\t\t\ttry {\n\t\t\t\tthis.wait(20000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `com.github.sarxos.webcam.ds.gstreamer.GStreamerDevice.open` reads without synchronization from `this.com.github.sarxos.webcam.ds.gstreamer.GStreamerDevice.pipe`. Potentially races with write in method `GStreamerDevice.open()`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "@Override\n\tpublic void open() {\n\n\t\tif (!open.compareAndSet(false, true)) {\n\t\t\treturn;\n\t\t}\n\n\t\tLOG.debug(\"Opening GStreamer device\");\n\n\t\tinit();\n\n\t\tstarting.set(true);\n\n\t\tDimension size = getResolution();\n\n\t\timage = new BufferedImage(size.width, size.height, BufferedImage.TYPE_INT_RGB);\n\t\timage.setAccelerationPriority(0);\n\t\timage.flush();\n\n\t\tif (caps != null) {\n\t\t\tcaps.dispose();\n\t\t}\n\n\t\tcaps = Caps.fromString(String.format(\"%s,framerate=30/1,width=%d,height=%d\", format, size.width, size.height));\n\t\tfilter.setCaps(caps);\n\n\t\tLOG.debug(\"Using filter caps: {}\", caps);\n\n\t\tpipelinePlay();\n\n\t\tLOG.debug(\"Wait for device to be ready\");\n\n\t\t// wait max 20s for image to appear\n\t\tsynchronized (this) {\n\t\t\ttry {\n\t\t\t\tthis.wait(20000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}", "LocalizedBug": "LOG.debug(\"Link elements\");\npipe.addMany(source, filter, sink);\nElement.linkMany(source, filter, sink);\npipe.setState(State.PLAYING);\nLOG.debug(\"Wait for device to be ready\");", "LocalizedPatchLength": 175, "CodeLength": 854}
{"BuggyCode": "@Test public void tooDeeplyNestedObjects() throws IOException {\n    Object root = Boolean.TRUE;\n    for (int i = 0; i < 32; i++) {\n      root = singletonMap(\"a\", root);\n    }\n    JsonReader reader = new JsonValueReader(root);\n    for (int i = 0; i < 31; i++) {\n      reader.beginObject();\n      assertThat(reader.nextName()).isEqualTo(\"a\");\n    }\n    try {\n      reader.beginObject();\n      fail();\n    } catch (JsonDataException expected) {\n      assertThat(expected).hasMessage(\n          \"Nesting too deep at $.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.\");\n    }\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.squareup.moshi.JsonValueReader` acquired by call to `JsonValueReader(...)` at line 463 is not released after line 475.\n**Note**: potential exception at line 465"}, "FixedCode": "@Test public void tooDeeplyNestedObjects() throws IOException {\n    Object root = Boolean.TRUE;\n    for (int i = 0; i < MAX_DEPTH + 1; i++) {\n      root = singletonMap(\"a\", root);\n    }\n    JsonReader reader = new JsonValueReader(root);\n    for (int i = 0; i < MAX_DEPTH; i++) {\n      reader.beginObject();\n      assertThat(reader.nextName()).isEqualTo(\"a\");\n    }\n    try {\n      reader.beginObject();\n      fail();\n    } catch (JsonDataException expected) {\n      assertThat(expected).hasMessage(\"Nesting too deep at $\" + repeat(\".a\", MAX_DEPTH) + \".\");\n    }\n  }", "LocalizedBug": "for (int i = 0; i < 32; i++) {\nfor (int i = 0; i < 31; i++) {\n\"Nesting too deep at $.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.\");", "LocalizedPatchLength": 150, "CodeLength": 589}
{"BuggyCode": "protected void calculate(ValuesProvider valuesProvider, List<ConnectionCandidate> connections, NeuralNetwork nn) {\n\tif (connections.size() > 0) {\n\t    List<Connections> chunk = new ArrayList<>();\n\n\t    for (int i = 0; i < connections.size(); i++) {\n\t\tConnectionCandidate c = connections.get(i);\n\t\tchunk.add(c.connection);\n\n\t\tif (i == connections.size() - 1 || connections.get(i + 1).target != c.target) {\n\t\t    ConnectionCalculator cc = getConnectionCalculator(c.target);\n\t\t    if (cc != null) {\n\t\t\tTensor t = TensorFactory.tensor(c.target, chunk, valuesProvider);\n\t\t\tt.forEach(j -> t.getElements()[j] = 0);\n\t\t\tcc.calculate(chunk, valuesProvider, c.target);\n\t\t    }\n\n\t\t    chunk.clear();\n\n\t\t    triggerEvent(new PropagationEvent(c.target, chunk, nn, valuesProvider));\n\t\t}\n\t    }\n\t}\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `t` last assigned on line 40 could be null and is dereferenced at line 41."}, "FixedCode": "protected void calculate(ValuesProvider valuesProvider, List<ConnectionCandidate> connections, NeuralNetwork nn) {\n\tif (connections.size() > 0) {\n\t    List<Connections> chunk = new ArrayList<>();\n\n\t    for (int i = 0; i < connections.size(); i++) {\n\t\tConnectionCandidate c = connections.get(i);\n\t\tchunk.add(c.connection);\n\n\t\tif (i == connections.size() - 1 || connections.get(i + 1).target != c.target) {\n\t\t    ConnectionCalculator cc = getConnectionCalculator(c.target);\n\t\t    if (cc != null) {\n\t\t\tTensor t = TensorFactory.tensor(c.target, chunk, valuesProvider);\n\t\t\tfloat[] elements = t.getElements();\n\t\t\tIntStream.range(t.getStartIndex(), t.getStartIndex() + t.getSize()).forEach(j -> elements[j] = 0);\n\t\t\tcc.calculate(chunk, valuesProvider, c.target);\n\t\t    }\n\n\t\t    chunk.clear();\n\n\t\t    triggerEvent(new PropagationEvent(c.target, chunk, nn, valuesProvider));\n\t\t}\n\t    }\n\t}\n    }", "LocalizedBug": "t.forEach(j -> t.getElements()[j] = 0);", "LocalizedPatchLength": 39, "CodeLength": 787}
{"BuggyCode": "private ClassLoader getDriverClassLoader() {\n    File localDriverPath = getCustomDriverPath();\n    if (driverClassLoader != null) {\n      return driverClassLoader;\n    } else if (localDriverPath.exists()) {\n      try {\n        List<URL> urlList = new ArrayList<URL>();\n        for (File file : localDriverPath.listFiles()) {\n          String filename = file.getCanonicalPath();\n          if (!filename.startsWith(\"/\")) {\n            filename = \"/\" + filename;\n          }\n          urlList.add(new URL(\"jar:file:\" + filename + \"!/\"));\n          urlList.add(new URL(\"file:\" + filename));\n        }\n        URL[] urls = urlList.toArray(new URL[urlList.size()]);\n        return new URLClassLoader(urls);\n      } catch (Exception e) {\n        throw new MigrationException(\"Error creating a driver ClassLoader. Cause: \" + e, e);\n      }\n    }\n    return null;\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `localDriverPath.listFiles()` could be null and is dereferenced at line 244."}, "FixedCode": "private ClassLoader getDriverClassLoader() {\n    File localDriverPath = getCustomDriverPath();\n    if (driverClassLoader != null) {\n      return driverClassLoader;\n    } else if (localDriverPath.exists()) {\n      try {\n        List<URL> urlList = new ArrayList<>();\n        File[] files = localDriverPath.listFiles();\n        if (files != null) {\n          for (File file : files) {\n            String filename = file.getCanonicalPath();\n            if (!filename.startsWith(\"/\")) {\n              filename = \"/\" + filename;\n            }\n            urlList.add(new URL(\"jar:file:\" + filename + \"!/\"));\n            urlList.add(new URL(\"file:\" + filename));\n          }\n        }\n        URL[] urls = urlList.toArray(new URL[0]);\n        return new URLClassLoader(urls);\n      } catch (Exception e) {\n        throw new MigrationException(\"Error creating a driver ClassLoader. Cause: \" + e, e);\n      }\n    }\n    return null;\n  }", "LocalizedBug": "List<URL> urlList = new ArrayList<URL>();\nfor (File file : localDriverPath.listFiles()) {\nURL[] urls = urlList.toArray(new URL[urlList.size()]);", "LocalizedPatchLength": 144, "CodeLength": 858}
{"BuggyCode": "protected ZipInputStream createZipInputStream(FileHeader fileHeader) throws IOException {\n    SplitInputStream splitInputStream = new SplitInputStream(getZipModel().getZipFile(),\n        getZipModel().isSplitArchive(), getZipModel().getEndOfCentralDirectoryRecord().getNumberOfThisDisk());\n    splitInputStream.prepareExtractionForFileHeader(fileHeader);\n    return new ZipInputStream(splitInputStream, password);\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.RandomAccessFile` acquired by call to `SplitInputStream(...)` at line 38 is not released after line 40."}, "FixedCode": "protected ZipInputStream createZipInputStream(FileHeader fileHeader) throws IOException {\n    splitInputStream = new SplitInputStream(getZipModel().getZipFile(),\n        getZipModel().isSplitArchive(), getZipModel().getEndOfCentralDirectoryRecord().getNumberOfThisDisk());\n    splitInputStream.prepareExtractionForFileHeader(fileHeader);\n    return new ZipInputStream(splitInputStream, password);\n  }", "LocalizedBug": "SplitInputStream splitInputStream = new SplitInputStream(getZipModel().getZipFile(),", "LocalizedPatchLength": 84, "CodeLength": 417}
{"BuggyCode": "@Test\n    public void registerImpediment() throws Exception {\n        final Project project = new FkProject();\n        final Impediments imp = new Impediments(new PropsFarm(), project)\n            .bootstrap();\n        final String job = \"gh:test/test#1\";\n        new Wbs(project).bootstrap().add(job);\n        new Orders(new PropsFarm(), project).bootstrap()\n            .assign(job, \"yegor256\", \"0\");\n        imp.register(job, \"test\");\n        MatcherAssert.assertThat(\n            imp.jobs(),\n            Matchers.contains(job)\n        );\n        MatcherAssert.assertThat(\n            imp.exists(job),\n            Matchers.is(true)\n        );\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.farm.fake.FkFarm` acquired by call to `PropsFarm()` at line 39 is not released after line 51."}, "FixedCode": "@Test\n    public void registerImpediment() throws Exception {\n        final Project project = new FkProject();\n        final Impediments imp = new Impediments(new PropsFarm(), project)\n            .bootstrap();\n        final String job = \"gh:test/test#1\";\n        new Wbs(project).bootstrap().add(job);\n        new Orders(new PropsFarm(), project).bootstrap()\n            .assign(job, \"yegor256\", UUID.randomUUID().toString());\n        imp.register(job, \"test\");\n        MatcherAssert.assertThat(\n            imp.jobs(),\n            Matchers.contains(job)\n        );\n        MatcherAssert.assertThat(\n            imp.exists(job),\n            Matchers.is(true)\n        );\n    }", "LocalizedBug": ".assign(job, \"yegor256\", \"0\");", "LocalizedPatchLength": 30, "CodeLength": 651}
{"BuggyCode": "public File getPlatform()\n    {\n        assertPathIsDirectory( sdkPath );\n\n        final File platformsDirectory = new File( sdkPath, PLATFORMS_FOLDER_NAME );\n        assertPathIsDirectory( platformsDirectory );\n\n        final File platformDirectory;\n        if ( platform == null )\n        {\n            final File[] platformDirectories = platformsDirectory.listFiles();\n            Arrays.sort( platformDirectories );\n            platformDirectory = platformDirectories[ platformDirectories.length - 1 ];\n        }\n        else\n        {\n            platformDirectory = new File( platform.path );\n        }\n        assertPathIsDirectory( platformDirectory );\n        return platformDirectory;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `platformDirectories` last assigned on line 335 could be null and is dereferenced at line 337."}, "FixedCode": "public File getPlatform()\n    {\n        assertPathIsDirectory( sdkPath );\n\n        final File platformsDirectory = new File( sdkPath, PLATFORMS_FOLDER_NAME );\n        assertPathIsDirectory( platformsDirectory );\n\n        final File platformDirectory;\n        if ( androidTarget == null )\n        {\n            IAndroidTarget latestTarget = null;\n            for ( IAndroidTarget target:  sdkManager.getTargets() )\n            {\n                if ( target.isPlatform() )\n                {\n                    if ( latestTarget == null\n                            || target.getVersion().getApiLevel() > latestTarget.getVersion().getApiLevel() )\n                    {\n                        latestTarget = target;\n                    }\n                }\n            }\n            platformDirectory = new File ( latestTarget.getLocation() );\n        }\n        else\n        {\n            platformDirectory = new File( androidTarget.getLocation() );\n        }\n        assertPathIsDirectory( platformDirectory );\n        return platformDirectory;\n    }", "LocalizedBug": "if ( platform == null )\nfinal File[] platformDirectories = platformsDirectory.listFiles();\nArrays.sort( platformDirectories );\nplatformDirectory = platformDirectories[ platformDirectories.length - 1 ];\nplatformDirectory = new File( platform.path );", "LocalizedPatchLength": 248, "CodeLength": 700}
{"BuggyCode": "void onData(final Cell cell) {\n        final DyeCell dyeCell = Fn.pool(this.stylePool, \"DATA\",\n                () -> DyeCell.create(this.workbook)\n                        .border(BorderStyle.THIN)\n                        .align(null, VerticalAlignment.TOP)\n                        .font(13, false));\n        cell.setCellStyle(dyeCell.build());\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `dyeCell` last assigned on line 81 could be null and is dereferenced at line 86."}, "FixedCode": "void onTable(final Cell cell) {\n        final DyeCell dyeCell = Fn.pool(this.stylePool, \"TABLE\",\n                () -> DyeCell.create(this.workbook)\n                        .color(\"FFFFFF\", \"3EB7FF\")\n                        .align(HorizontalAlignment.CENTER)\n                        .border(BorderStyle.THIN)\n                        .font(13, false));\n        cell.setCellStyle(dyeCell.build());\n    }", "LocalizedBug": "void onData(final Cell cell) {\nfinal DyeCell dyeCell = Fn.pool(this.stylePool, \"DATA\",\n.border(BorderStyle.THIN)\n.align(null, VerticalAlignment.TOP)", "LocalizedPatchLength": 148, "CodeLength": 349}
{"BuggyCode": "private Set<RaftPeerId> getHigherPriorityPeers(RaftConfiguration conf) {\n    Set<RaftPeerId> higherPriorityPeers = new HashSet<>();\n\n    int currPriority = conf.getPeer(server.getId()).getPriority();\n    Collection<RaftPeer> peers = conf.getPeers();\n\n    for (RaftPeer peer : peers) {\n      if (peer.getPriority() > currPriority) {\n        higherPriorityPeers.add(peer.getId());\n      }\n    }\n\n    return higherPriorityPeers;\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `conf.getPeer(LeaderElection.server.getId())` could be null and is dereferenced at line 276."}, "FixedCode": "private Set<RaftPeerId> getHigherPriorityPeers(RaftConfiguration conf) {\n    Set<RaftPeerId> higherPriorityPeers = new HashSet<>();\n\n    int currPriority = conf.getPeer(server.getId()).getPriority();\n    final Collection<RaftPeer> peers = conf.getAllPeers();\n\n    for (RaftPeer peer : peers) {\n      if (peer.getPriority() > currPriority) {\n        higherPriorityPeers.add(peer.getId());\n      }\n    }\n\n    return higherPriorityPeers;\n  }", "LocalizedBug": "Collection<RaftPeer> peers = conf.getPeers();", "LocalizedPatchLength": 45, "CodeLength": 429}
{"BuggyCode": "void resetStatistics()\n    {\n        rehashes = 0L;\n        evictedEntries = 0L;\n        hitCount = 0L;\n        missCount = 0L;\n        putAddCount = 0L;\n        putReplaceCount = 0L;\n        removeCount = 0L;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.caffinitas.ohc.linked.OffHeapMap.resetStatistics` writes to field `this.org.caffinitas.ohc.linked.OffHeapMap.hitCount` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, long freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        this.throwOOME = builder.isThrowOOME();\n\n        this.lock = builder.isUnlocked() ? null : new ReentrantLock();\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        table = Table.create((int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE), throwOOME);\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "void resetStatistics()\n{\nrehashes = 0L;\nevictedEntries = 0L;\nhitCount = 0L;\nmissCount = 0L;\nputAddCount = 0L;\nputReplaceCount = 0L;\nremoveCount = 0L;", "LocalizedPatchLength": 149, "CodeLength": 215}
{"BuggyCode": "public static EntityManager createEntityManager() {\n        init(false);\n        return PersistUtilHelper.getEntityManager();\n        // return entityManagerFactory.createEntityManager();\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Unprotected write. Non-private method `org.cryptocoinpartners.util.PersistUtil.createEntityManager` indirectly writes to field `util.PersistUtilHelper.org.cryptocoinpartners.util.PersistUtilHelper.emf` outside of synchronization.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public static EntityManager createEntityManager() {\n        init(false);\n        return PersistUtilHelper.getEntityManager();\n    }", "LocalizedBug": "// return entityManagerFactory.createEntityManager();", "LocalizedPatchLength": 53, "CodeLength": 193}
{"BuggyCode": "@Override\n  public NodeSet eval(final XPContext ctx) {\n    ctx.local = new NodeSet(ctx.local.data.ids(index)[0], ctx);\n    return ctx.local;\n  }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `ctx.local.data.ids(IndexAccess.index)` could be null and is dereferenced at line 31."}, "FixedCode": "@Override\n  public NodeSet eval(final XPContext ctx) {\n    final IndexIterator it = ctx.local.data.ids(index);\n    final IntList il = new IntList();\n    while(it.more()) {\n      ctx.checkStop();\n      il.add(it.next());\n    }\n    ctx.local = new NodeSet(il.finish(), ctx);\n    return ctx.local;\n  }", "LocalizedBug": "ctx.local = new NodeSet(ctx.local.data.ids(index)[0], ctx);", "LocalizedPatchLength": 59, "CodeLength": 144}
{"BuggyCode": "public static void explore(File m) {\n\n        String mac = \"open \";\n\n\n        String cmd = null;\n        switch(Platform.getPlatform())\n        {\n\n            case mac:\n                cmd = \"open \";\n                if (!m.isDirectory()) cmd += \"-R \";\n                break;\n            case win:\n                cmd = \"Explorer /select, \";\n                break;\n            case linux:\n                cmd = \"gnome-open PATH \";\n                break;\n        }\n\n        if (cmd != null) {\n            cmd += \"\\\"\" + m.getAbsolutePath() + \"\\\"\";\n            System.err.println(cmd);\n            try {\n                Runtime.getRuntime().exec(cmd);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.lang.Process` acquired by call to `exec(...)` at line 188 is not released after line 188."}, "FixedCode": "public static void explore(File m) {\n\n        ArrayList<String>cmdLine = new ArrayList<>();\n        \n        switch(Platform.getPlatform())\n        {\n            case mac:\n            \tcmdLine.add(\"open\");\n\n                if (!m.isDirectory())\n                {\n                \tcmdLine.add(\"-R\");\n                }\n                break;\n            case win:\n                cmdLine.add(\"Explorer \");\n                cmdLine.add(\"/select,\");\n               \n                break;\n            case linux:\n                cmdLine.add(\"gnome-open\");\n                cmdLine.add(\"PATH\");\n                break;\n        }\n        if (cmdLine.isEmpty()) return;\n        \n        try {\n        \tcmdLine.add(m.getAbsolutePath());\n        \t\n        \tSimpleProcess p = new SimpleProcess(cmdLine);\n        \tp.run();\n        \t\n        \tResults r = p.getResults();\n        \t\n\n\n            } catch (Throwable e) {\n                e.printStackTrace();\n            }\n        \n\n    }", "LocalizedBug": "String mac = \"open \";\nString cmd = null;\ncmd = \"open \";\nif (!m.isDirectory()) cmd += \"-R \";\ncmd = \"Explorer /select, \";\ncmd = \"gnome-open PATH \";\nif (cmd != null) {\ncmd += \"\\\"\" + m.getAbsolutePath() + \"\\\"\";\nSystem.err.println(cmd);\ntry {\nRuntime.getRuntime().exec(cmd);\n} catch (IOException e) {\n}", "LocalizedPatchLength": 297, "CodeLength": 753}
{"BuggyCode": "private List<Challenge> fetchChallenges(JSON json) {\n        JSON.Array jsonChallenges = json.get(\"challenges\").asArray();\n        List<Challenge> cr = new ArrayList<>();\n        for (JSON.Value c : jsonChallenges) {\n            Challenge ch = getSession().createChallenge(c.asObject());\n            if (ch != null) {\n                cr.add(ch);\n            }\n        }\n        return cr;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `c.asObject()` could be null and is dereferenced by call to `createChallenge(...)` at line 259."}, "FixedCode": "private List<Challenge> fetchChallenges(JSON json) {\n        Session session = getSession();\n\n        return Collections.unmodifiableList(json.get(\"challenges\").asArray().stream()\n                .map(JSON.Value::asObject)\n                .map(session::createChallenge)\n                .collect(toList()));\n    }", "LocalizedBug": "JSON.Array jsonChallenges = json.get(\"challenges\").asArray();\nList<Challenge> cr = new ArrayList<>();\nfor (JSON.Value c : jsonChallenges) {\nChallenge ch = getSession().createChallenge(c.asObject());\nif (ch != null) {\ncr.add(ch);\n}\nreturn cr;\n}", "LocalizedPatchLength": 243, "CodeLength": 394}
{"BuggyCode": "@Test\n    public void testCarriageReturnEndings() throws IOException {\n        String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n        CSVParser parser = new CSVParser(new StringReader(code));\n        String[][] data = parser.getRecords();\n        assertEquals(4, data.length);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `data` last assigned on line 402 could be null and is dereferenced at line 403."}, "FixedCode": "@Test\n    public void testCarriageReturnEndings() throws IOException {\n        String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n        CSVParser parser = new CSVParser(new StringReader(code));\n        List<CSVRecord> records = parser.getRecords();\n        assertEquals(4, records.size());\n    }", "LocalizedBug": "String[][] data = parser.getRecords();\nassertEquals(4, data.length);", "LocalizedPatchLength": 68, "CodeLength": 283}
{"BuggyCode": "@Override\n    public ValidateResult validate(AliasTransaction tx) {\n        Alias alias = tx.getTxData();\n        if (StringUtils.isBlank(alias.getAddress()) || new Address(alias.getAddress()).getHash160().length > 25) {\n            return ValidateResult.getFailedResult(\"The address format error\");\n        }\n        if (!StringUtils.validAlias(alias.getAlias())) {\n            return ValidateResult.getFailedResult(\"The alias is between 3 to 20 characters\");\n        }\n\n        AliasPo aliasPo = aliasDataService.get(alias.getAlias());\n        if (aliasPo != null) {\n            return ValidateResult.getFailedResult(\"The alias has been occupied\");\n        }\n        return ValidateResult.getSuccessResult();\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `__new(io.nuls.account.entity.Address).getHash160()` could be null and is dereferenced at line 56."}, "FixedCode": "@Override\n    public ValidateResult validate(AliasTransaction tx) {\n        Alias alias = tx.getTxData();\n        if (StringUtils.isBlank(alias.getAddress()) || new Address(alias.getAddress()).getHash().length !=23 ) {\n            return ValidateResult.getFailedResult(\"The address format error\");\n        }\n        if (!StringUtils.validAlias(alias.getAlias())) {\n            return ValidateResult.getFailedResult(\"The alias is between 3 to 20 characters\");\n        }\n\n        AliasPo aliasPo = aliasDataService.get(alias.getAlias());\n        if (aliasPo != null) {\n            return ValidateResult.getFailedResult(\"The alias has been occupied\");\n        }\n        return ValidateResult.getSuccessResult();\n    }", "LocalizedBug": "if (StringUtils.isBlank(alias.getAddress()) || new Address(alias.getAddress()).getHash160().length > 25) {", "LocalizedPatchLength": 106, "CodeLength": 716}
{"BuggyCode": "@Test\n\tpublic void parseXml() {\n\t\tICalParameters params = new ICalParameters();\n\n\t\tElement element = xcalPropertyElement(marshaller, \"<date-time>2013-06-11T13:43:02Z</date-time>\");\n\t\tResult<DateTimePropertyImpl> result = marshaller.parseXml(element, params);\n\n\t\tDateTimePropertyImpl prop = result.getValue();\n\t\tassertEquals(datetime, prop.getValue());\n\t\tassertWarnings(0, result.getWarnings());\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `element` last assigned on line 132 could be null and is dereferenced by call to `parseXml(...)` at line 133."}, "FixedCode": "@Test\n\tpublic void parseXml() {\n\t\tResult<DateTimePropertyImpl> result = parseXCalProperty(\"<date-time>2013-06-11T13:43:02Z</date-time>\", marshaller);\n\n\t\tDateTimePropertyImpl prop = result.getValue();\n\t\tassertEquals(datetime, prop.getValue());\n\t\tassertWarnings(0, result.getWarnings());\n\t}", "LocalizedBug": "ICalParameters params = new ICalParameters();\nElement element = xcalPropertyElement(marshaller, \"<date-time>2013-06-11T13:43:02Z</date-time>\");\nResult<DateTimePropertyImpl> result = marshaller.parseXml(element, params);", "LocalizedPatchLength": 219, "CodeLength": 397}
{"BuggyCode": "@Override\n    public Object getValue(String name) {\n        return Jboot.getJbootCache().get(SESSION_CACHE_NAME, buildKey(name));\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getJbootCache()` could be null and is dereferenced at line 78."}, "FixedCode": "@Override\n    public Object getValue(String name) {\n        return Jboot.getCache().get(SESSION_CACHE_NAME, buildKey(name));\n    }", "LocalizedBug": "return Jboot.getJbootCache().get(SESSION_CACHE_NAME, buildKey(name));", "LocalizedPatchLength": 69, "CodeLength": 135}
{"BuggyCode": "public static void refresh(final DataSourceProxy dataSourceProxy){\n        ConcurrentMap<String, TableMeta> tableMetaMap = TABLE_META_CACHE.asMap();\n        for (Entry<String, TableMeta> entry : tableMetaMap.entrySet()) {\n            try {\n                TableMeta tableMeta = fetchSchema(dataSourceProxy, entry.getValue().getTableName());\n                if (tableMeta == null){\n                    LOGGER.error(\"get table meta error\");\n                }\n                if (!tableMeta.equals(entry.getValue())){\n                    TABLE_META_CACHE.put(entry.getKey(), tableMeta);\n                    LOGGER.info(\"table meta change was found, update table meta cache automatically.\");\n                }\n            } catch (SQLException e) {\n                LOGGER.error(\"get table meta error:{}\", e.getMessage(), e);\n            }\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `tableMeta` last assigned on line 104 could be null and is dereferenced at line 108."}, "FixedCode": "public static void refresh(final DataSourceProxy dataSourceProxy){\n        ConcurrentMap<String, TableMeta> tableMetaMap = TABLE_META_CACHE.asMap();\n        for (Entry<String, TableMeta> entry : tableMetaMap.entrySet()) {\n            String key = getCacheKey(dataSourceProxy, entry.getValue().getTableName());\n            if(entry.getKey().equals(key)){\n                try {\n                    TableMeta tableMeta = fetchSchema(dataSourceProxy, entry.getValue().getTableName());\n                    if (!tableMeta.equals(entry.getValue())){\n                        TABLE_META_CACHE.put(entry.getKey(), tableMeta);\n                        LOGGER.info(\"table meta change was found, update table meta cache automatically.\");\n                    }\n                } catch (SQLException e) {\n                    LOGGER.error(\"get table meta error:{}\", e.getMessage(), e);\n                }\n            }\n        }\n    }", "LocalizedBug": "if (tableMeta == null){\nLOGGER.error(\"get table meta error\");\n}", "LocalizedPatchLength": 63, "CodeLength": 850}
{"BuggyCode": "@Test\n    public void testWrite_dataExceedingBufferSize() throws IOException {\n        final File file = File.createTempFile(\"log4j2\", \"test\");\n        file.deleteOnExit();\n        final RandomAccessFile raf = new RandomAccessFile(file, \"rw\");\n        final OutputStream os = NullOutputStream.NULL_OUTPUT_STREAM;\n        final RandomAccessFileManager manager = new RandomAccessFileManager(raf, file.getName(), os,\n                false, RandomAccessFileManager.DEFAULT_BUFFER_SIZE, null, null);\n\n        final int size = RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3 + 1;\n        final byte[] data = new byte[size];\n        manager.write(data); // no exception\n        assertEquals(RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3, raf.length());\n\n        manager.flush();\n        assertEquals(size, raf.length()); // all data written to file now\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.RandomAccessFile` acquired to `raf` by call to `RandomAccessFile(...)` at line 66 is not released after line 78.\n**Note**: potential exception at line 74"}, "FixedCode": "@Test\n    public void testWrite_dataExceedingBufferSize() throws IOException {\n        final File file = File.createTempFile(\"log4j2\", \"test\");\n        file.deleteOnExit();\n        try (final RandomAccessFile raf = new RandomAccessFile(file, \"rw\")) {\n            final OutputStream os = NullOutputStream.NULL_OUTPUT_STREAM;\n            final RandomAccessFileManager manager = new RandomAccessFileManager(raf, file.getName(), os, false,\n                    RandomAccessFileManager.DEFAULT_BUFFER_SIZE, null, null);\n\n            final int size = RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3 + 1;\n            final byte[] data = new byte[size];\n            manager.write(data); // no exception\n            assertEquals(RandomAccessFileManager.DEFAULT_BUFFER_SIZE * 3, raf.length());\n\n            manager.flush();\n            assertEquals(size, raf.length()); // all data written to file now\n        }}", "LocalizedBug": "final RandomAccessFile raf = new RandomAccessFile(file, \"rw\");", "LocalizedPatchLength": 62, "CodeLength": 853}
{"BuggyCode": "@Test\n    public void testSyncHandleFailResponse() throws Exception {\n        RpcFuture rpcFuture = new RpcFuture<String>(timeout, methodInfo, null, channelInfo, rpcClient);\n        RpcResponse response = new RpcResponse();\n        RuntimeException ex = new RuntimeException(\"dummy\");\n        response.setException(ex);\n        rpcFuture.handleResponse(response);\n        Response resp = rpcFuture.get(1, TimeUnit.SECONDS);\n        assertThat((RuntimeException) resp.getException(), is(ex));\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `resp` last assigned on line 135 could be null and is dereferenced at line 136."}, "FixedCode": "@Test\n    public void testSyncHandleFailResponse() throws Exception {\n        RpcFuture<String> rpcFuture = new RpcFuture<String>(timeout, methodInfo, null, channelInfo, rpcClient);\n        RpcResponse response = new RpcResponse();\n        RuntimeException ex = new RuntimeException(\"dummy\");\n        response.setException(ex);\n        rpcFuture.handleResponse(response);\n        try {\n            rpcFuture.get(1, TimeUnit.SECONDS);\n        } catch (RpcException ex2) {\n            Assert.assertTrue(ex2.getCause() == ex);\n        }\n    }", "LocalizedBug": "Response resp = rpcFuture.get(1, TimeUnit.SECONDS);\nassertThat((RuntimeException) resp.getException(), is(ex));", "LocalizedPatchLength": 111, "CodeLength": 497}
{"BuggyCode": "@Test\n    public void testDecodingNewline() throws IOException {\n        Packet packet = decoder.decodePacket(\"3:::\\n\", null);\n        Assert.assertEquals(PacketType.MESSAGE, packet.getType());\n        Assert.assertEquals(\"\\n\", packet.getData());\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `packet` last assigned on line 82 could be null and is dereferenced at line 83."}, "FixedCode": "@Test\n    public void testDecodingNewline() throws IOException {\n        Packet packet = decoder.decodePackets(Unpooled.copiedBuffer(\"3:::\\n\", CharsetUtil.UTF_8), null);\n        Assert.assertEquals(PacketType.MESSAGE, packet.getType());\n        Assert.assertEquals(\"\\n\", packet.getData());\n    }", "LocalizedBug": "Packet packet = decoder.decodePacket(\"3:::\\n\", null);", "LocalizedPatchLength": 53, "CodeLength": 252}
{"BuggyCode": "@Test\n    public void testFoldedFooters() throws Exception {\n        String s = \"10;key=\\\"value\\\"\\r\\n1234567890123456\\r\\n\" +\n                \"5\\r\\n12345\\r\\n5\\r\\n12345\\r\\n0\\r\\nFooter1: abcde\\r\\n   \\r\\n  fghij\\r\\n\\r\\n\";\n        ReadableByteChannel channel = new ReadableByteChannelMockup(\n                new String[] {s}, \"US-ASCII\");\n        HttpParams params = new BasicHttpParams();\n\n        SessionInputBuffer inbuf = new SessionInputBufferImpl(1024, 256, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        ChunkDecoder decoder = new ChunkDecoder(channel, inbuf, metrics);\n\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n\n        int bytesRead = decoder.read(dst);\n        Assert.assertEquals(26, bytesRead);\n        Assert.assertEquals(\"12345678901234561234512345\", convert(dst));\n\n        Header[] footers = decoder.getFooters();\n        Assert.assertEquals(1, footers.length);\n        Assert.assertEquals(\"Footer1\", footers[0].getName());\n        Assert.assertEquals(\"abcde  fghij\", footers[0].getValue());\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.http.ReadableByteChannelMockup` acquired by call to `new()` at line 273 is not released after line 287."}, "FixedCode": "@Test\n    public void testFoldedFooters() throws Exception {\n        String s = \"10;key=\\\"value\\\"\\r\\n1234567890123456\\r\\n\" +\n                \"5\\r\\n12345\\r\\n5\\r\\n12345\\r\\n0\\r\\nFooter1: abcde\\r\\n   \\r\\n  fghij\\r\\n\\r\\n\";\n        ReadableByteChannel channel = new ReadableByteChannelMock(\n                new String[] {s}, \"US-ASCII\");\n        HttpParams params = new BasicHttpParams();\n\n        SessionInputBuffer inbuf = new SessionInputBufferImpl(1024, 256, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        ChunkDecoder decoder = new ChunkDecoder(channel, inbuf, metrics);\n\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n\n        int bytesRead = decoder.read(dst);\n        Assert.assertEquals(26, bytesRead);\n        Assert.assertEquals(\"12345678901234561234512345\", convert(dst));\n\n        Header[] footers = decoder.getFooters();\n        Assert.assertEquals(1, footers.length);\n        Assert.assertEquals(\"Footer1\", footers[0].getName());\n        Assert.assertEquals(\"abcde  fghij\", footers[0].getValue());\n    }", "LocalizedBug": "ReadableByteChannel channel = new ReadableByteChannelMockup(", "LocalizedPatchLength": 60, "CodeLength": 1064}
{"BuggyCode": "public boolean put(byte[] key, V value)\n    {\n        KeyBuffer keyBuffer = keySource(key);\n        byte[] data = value(value);\n\n        if (maxEntrySize > 0L && CheckSegment.sizeOf(keyBuffer, data) > maxEntrySize)\n        {\n            remove(key);\n            putFailCount++;\n            return false;\n        }\n\n        CheckSegment segment = segment(keyBuffer.hash());\n        return segment.put(keyBuffer, data, false, null);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `data` last assigned on line 53 could be null and is dereferenced by call to `sizeOf(...)` at line 55."}, "FixedCode": "public boolean put(byte[] key, V value)\n    {\n        KeyBuffer keyBuffer = keySource(key);\n        byte[] data = value(value);\n\n        CheckSegment segment = segment(keyBuffer.hash());\n        return segment.put(keyBuffer, data, false, null);\n    }", "LocalizedBug": "if (maxEntrySize > 0L && CheckSegment.sizeOf(keyBuffer, data) > maxEntrySize)\n{\nremove(key);\nputFailCount++;\nreturn false;\n}", "LocalizedPatchLength": 124, "CodeLength": 436}
{"BuggyCode": "@Test\n    @Ignore\n    public void testIOS() throws Exception {\n        GCMWrapper gcmWrapper = new GCMWrapper(null, null);\n        gcmWrapper.send(new IOSGCMMessage(\"to\", Priority.normal, \"yo!!!\", 1), null, null);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `null` could be null and is dereferenced by call to `GCMWrapper(...)` at line 22."}, "FixedCode": "@Test\n    @Ignore\n    public void testIOS() throws Exception {\n        GCMWrapper gcmWrapper = new GCMWrapper(props, client);\n        gcmWrapper.send(new IOSGCMMessage(\"to\", Priority.normal, \"yo!!!\", 1), null, null);\n    }", "LocalizedBug": "GCMWrapper gcmWrapper = new GCMWrapper(null, null);", "LocalizedPatchLength": 51, "CodeLength": 219}
{"BuggyCode": "public Index read() throws IOException {\n        PackedDataInputStream stream = new PackedDataInputStream(new BufferedInputStream(input));\n        if (stream.readInt() != MAGIC) {\n            stream.close();\n            throw new IllegalArgumentException(\"Not a jandex index\");\n        }\n        byte version = stream.readByte();\n\n        IndexReaderImpl reader = getReader(stream, version);\n        if (reader == null) {\n            stream.close();\n            throw new UnsupportedVersion(\"Version: \" + version);\n        }\n\n        return reader.read(version);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.BufferedInputStream` acquired by call to `new()` at line 71 is not released after line 71."}, "FixedCode": "public Index read() throws IOException {\n        if(version == -1) {\n            readVersion();\n        }\n        IndexReaderImpl reader = getReader(input, version);\n        if (reader == null) {\n            input.close();\n            throw new UnsupportedVersion(\"Version: \" + version);\n        }\n        return reader.read(version);\n    }", "LocalizedBug": "PackedDataInputStream stream = new PackedDataInputStream(new BufferedInputStream(input));\nif (stream.readInt() != MAGIC) {\nstream.close();\nthrow new IllegalArgumentException(\"Not a jandex index\");\nbyte version = stream.readByte();\nIndexReaderImpl reader = getReader(stream, version);\nstream.close();", "LocalizedPatchLength": 299, "CodeLength": 568}
{"BuggyCode": "public void await() throws InterruptedException {\n\t\twhile (!isDone()) {\n\t\t\tsynchronized (signal) {\n\t\t\t\tsignal.wait();\n\t\t\t}\n\t\t}\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `net.rithms.riot.api.request.AsyncRequest.await` indirectly reads without synchronization from `this.net.rithms.riot.api.request.Request.state`. Potentially races with write in method `AsyncRequest.setState(...)`.\n Reporting because this access may occur on a background thread."}, "FixedCode": "public void await() throws InterruptedException {\n\t\tif (!isDone()) {\n\t\t\tsynchronized (signal) {\n\t\t\t\twhile (!isDone()) {\n\t\t\t\t\tsignal.wait();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "LocalizedBug": "while (!isDone()) {", "LocalizedPatchLength": 19, "CodeLength": 129}
{"BuggyCode": "@Override\n  public JimfsFileSystem newFileSystem(URI uri, Map<String, ?> env) {\n    checkArgument(uri.getScheme().equalsIgnoreCase(SCHEME),\n        \"uri (%s) scheme must be '%s'\", uri, SCHEME);\n    checkArgument(env.get(CONFIG_KEY) instanceof JimfsConfiguration,\n        \"env map (%s) must contain key '%s' mapped to an instance of JimfsConfiguration\",\n        env, CONFIG_KEY);\n    JimfsConfiguration config = (JimfsConfiguration) env.get(CONFIG_KEY);\n    JimfsFileSystem fileSystem = new JimfsFileSystem(this, uri, config);\n    if (fileSystems.putIfAbsent(uri, fileSystem) != null) {\n      throw new FileSystemAlreadyExistsException(uri.toString());\n    }\n    return fileSystem;\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.google.jimfs.internal.JimfsFileSystem` acquired by call to `JimfsFileSystem(...)` at line 89 is not released after line 89.\n**Note**: potential exception at line 89"}, "FixedCode": "@Override\n  public JimfsFileSystem newFileSystem(URI uri, Map<String, ?> env) throws IOException {\n    checkArgument(uri.getScheme().equalsIgnoreCase(SCHEME),\n        \"uri (%s) scheme must be '%s'\", uri, SCHEME);\n    checkArgument(env.get(CONFIG_KEY) instanceof JimfsConfiguration,\n        \"env map (%s) must contain key '%s' mapped to an instance of JimfsConfiguration\",\n        env, CONFIG_KEY);\n    JimfsConfiguration config = (JimfsConfiguration) env.get(CONFIG_KEY);\n    JimfsFileSystem fileSystem = FileSystemInitializer.createFileSystem(this, uri, config);\n    if (fileSystems.putIfAbsent(uri, fileSystem) != null) {\n      throw new FileSystemAlreadyExistsException(uri.toString());\n    }\n    return fileSystem;\n  }", "LocalizedBug": "JimfsFileSystem fileSystem = new JimfsFileSystem(this, uri, config);", "LocalizedPatchLength": 68, "CodeLength": 684}
{"BuggyCode": "void propagate(SimpleHashSet<FloatVar> fdvs) {\n\n        while (!fdvs.isEmpty()) {\n\n            FloatVar v = fdvs.removeFirst();\n            VariableNode n = varMap.get(v);\n\n            n.propagate();\n\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `n` last assigned on line 345 could be null and is dereferenced at line 347."}, "FixedCode": "RootBNode buildBinaryTree(BinaryNode[] nodes) {\n\n        BinaryNode[] nextLevelNodes = new BinaryNode[nodes.length / 2 + nodes.length % 2];\n        // System.out.println (\"next level length = \" + nextLevelNodes.length);\n\n        if (nodes.length > 1) {\n            for (int i = 0; i < nodes.length - 1; i += 2) {\n                BinaryNode parent;\n\n                if (nodes.length == 2)\n                    parent = new RootBNode(store, FloatDomain.MinFloat, FloatDomain.MaxFloat);\n                else\n                    parent = new BNode(store, FloatDomain.MinFloat, FloatDomain.MaxFloat);\n\n                parent.left = nodes[i];\n                parent.right = nodes[i + 1];\n\n                // currently sibling not used\n                // nodes[i].sibling = nodes[i + 1];\n                // nodes[i + 1].sibling = nodes[i];\n\n                nodes[i].parent = parent;\n                nodes[i + 1].parent = parent;\n\n                nextLevelNodes[i / 2] = parent;\n\n            }\n            if (nodes.length % 2 == 1) {\n                nextLevelNodes[nextLevelNodes.length - 1] = nextLevelNodes[0];\n                nextLevelNodes[0] = nodes[nodes.length - 1];\n            }\n\n            return buildBinaryTree(nextLevelNodes);\n        } else {\n            // root node\n            ((RootBNode) nodes[0]).val = this.sum;\n            ((RootBNode) nodes[0]).rel = relationType;\n\n            return (RootBNode) nodes[0];\n        }\n    }", "LocalizedBug": "void propagate(SimpleHashSet<FloatVar> fdvs) {\nwhile (!fdvs.isEmpty()) {\nFloatVar v = fdvs.removeFirst();\nVariableNode n = varMap.get(v);\nn.propagate();\n}\n}", "LocalizedPatchLength": 156, "CodeLength": 216}
{"BuggyCode": "public Template parse(String name, String encoding) throws IOException, ParseException {\n        if (name == null || name.length() == 0) {\n            throw new IllegalArgumentException(\"include template name == null\");\n        }\n        String macro = null;\n\t\tint i = name.indexOf('#');\n        if (i > 0) {\n        \tmacro = name.substring(i + 1);\n        \tname = name.substring(0, i);\n        }\n        Template template = Context.getContext().getTemplate();\n        if (template != null) {\n            if (encoding == null || encoding.length() == 0) {\n                encoding = template.getEncoding();\n            }\n            name = UrlUtils.relativeUrl(name, template.getName());\n        }\n        name = UrlUtils.cleanUrl(name.trim());\n        template = engine.getTemplate(name, encoding);\n        if (macro != null && macro.length() > 0) {\n\t\t\treturn template.getMacros().get(macro);\n\t\t}\n        return template;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `name` last assigned on line 165 could be null and is dereferenced at line 167."}, "FixedCode": "public Template parse(String name, String encoding) throws IOException, ParseException {\n        if (name == null || name.length() == 0) {\n            throw new IllegalArgumentException(\"include template name == null\");\n        }\n        String macro = null;\n\t\tint i = name.indexOf('#');\n        if (i > 0) {\n        \tmacro = name.substring(i + 1);\n        \tname = name.substring(0, i);\n        }\n        Template template = Context.getContext().getTemplate();\n        if (template != null) {\n            if (encoding == null || encoding.length() == 0) {\n                encoding = template.getEncoding();\n            }\n            name = UrlUtils.relativeUrl(name, template.getName());\n        }\n        template = engine.getTemplate(name, encoding);\n        if (macro != null && macro.length() > 0) {\n\t\t\treturn template.getMacros().get(macro);\n\t\t}\n        return template;\n    }", "LocalizedBug": "name = UrlUtils.cleanUrl(name.trim());", "LocalizedPatchLength": 38, "CodeLength": 927}
{"BuggyCode": "@Test\n    public void payZold() throws Exception {\n        MatcherAssert.assertThat(\n            new Zold(new PropsFarm()).pay(\n                \"yegor256\",\n                new Cash.S(\"$0.01\"),\n                \"ZoldITCase#payZold\",\n                \"none\"\n            ),\n            Matchers.not(Matchers.isEmptyString())\n        );\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.pmo.banks.Zold` acquired by call to `Zold(...)` at line 45 is not released after line 46."}, "FixedCode": "@Test\n    public void payZold() throws Exception {\n        final Farm farm = new PropsFarm();\n        final String target = \"yegor256\";\n        new Roles(new Pmo(farm)).bootstrap().assign(target, \"PO\");\n        MatcherAssert.assertThat(\n            new Zold(farm).pay(\n                target,\n                new Cash.S(\"$0.01\"),\n                \"ZoldITCase#payZold\",\n                \"none\"\n            ),\n            Matchers.not(Matchers.isEmptyString())\n        );\n    }", "LocalizedBug": "new Zold(new PropsFarm()).pay(\n\"yegor256\",", "LocalizedPatchLength": 42, "CodeLength": 336}
{"BuggyCode": "@Override\n    public void enrich(KubernetesListBuilder builder) {\n        final ServiceConfiguration defaultServiceConfig = extractDefaultServiceConfig();\n        final Service defaultService = serviceHandler.getService(defaultServiceConfig,null);\n\n        if (hasServices(builder)) {\n            builder.accept(new Visitor<ServiceBuilder>() {\n                @Override\n                public void visit(ServiceBuilder service) {\n                    mergeServices(service, defaultService);\n                }\n            });\n        } else {\n            log.info(\"Adding a default Service with ports [%s]\", formatPortsAsList(defaultService.getSpec().getPorts()));\n            builder.addToServiceItems(defaultService);\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `defaultService` last assigned on line 76 could be null and is dereferenced at line 86."}, "FixedCode": "@Override\n    public void enrich(KubernetesListBuilder builder) {\n        final ServiceConfiguration defaultServiceConfig = extractDefaultServiceConfig();\n        final Service defaultService = serviceHandler.getService(defaultServiceConfig,null);\n\n        if (hasServices(builder)) {\n            builder.accept(new Visitor<ServiceBuilder>() {\n                @Override\n                public void visit(ServiceBuilder service) {\n                    mergeServices(service, defaultService);\n                }\n            });\n        } else {\n            if (defaultService != null) {\n                ServiceSpec spec = defaultService.getSpec();\n                if (spec != null) {\n                    List<ServicePort> ports = spec.getPorts();\n                    if (ports != null) {\n                        log.info(\"Adding a default Service with ports [%s]\", formatPortsAsList(ports));\n                        builder.addToServiceItems(defaultService);\n                    }\n                }\n            }\n        }\n    }", "LocalizedBug": "log.info(\"Adding a default Service with ports [%s]\", formatPortsAsList(defaultService.getSpec().getPorts()));", "LocalizedPatchLength": 109, "CodeLength": 733}
{"BuggyCode": "public static void main(String[] args) {\n\t\t@SuppressWarnings(\"resource\")\n\t\tApplicationContext context = new ClassPathXmlApplicationContext(\"exampleContext.xml\");\n\t\tSpringCacheExample example = context.getBean(SpringCacheExample.class);\n\t\texample.getBook(0);\n\t\texample.getBook(0);\n\t}", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.springframework.context.support.ClassPathXmlApplicationContext` acquired by call to `new()` at line 45 is not released after line 46."}, "FixedCode": "public static void main(String[] args) {\n\t\texample();\n\t}", "LocalizedBug": "@SuppressWarnings(\"resource\")\nApplicationContext context = new ClassPathXmlApplicationContext(\"exampleContext.xml\");\nSpringCacheExample example = context.getBean(SpringCacheExample.class);\nexample.getBook(0);\nexample.getBook(0);", "LocalizedPatchLength": 228, "CodeLength": 282}
{"BuggyCode": "@Test\n    public void acceptIfNeverApplied() throws Exception {\n        final Farm farm = new PropsFarm(new FkFarm());\n        final People people = new People(farm).bootstrap();\n        final String uid = \"yegor256\";\n        people.touch(uid);\n        final Request req = new RqWithUser(\n            farm,\n            new RqFake(\"POST\", \"/join-post\"),\n            uid\n        );\n        people.breakup(uid);\n        MatcherAssert.assertThat(\n            new TkApp(farm).act(\n                new RqWithBody(\n                    req,\n                    // @checkstyle LineLength (1 line)\n                    \"personality=INTJ-A&stackoverflow=187241&telegram=123&about=txt\"\n                )\n            ),\n            Matchers.allOf(\n                new HmRsStatus(HttpURLConnection.HTTP_SEE_OTHER),\n                new HmRsHeader(\"Location\", \"/\")\n            )\n        );\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.farm.props.PropsFarm` acquired by call to `PropsFarm(...)` at line 93 is not released after line 116.\n**Note**: potential exception at line 97"}, "FixedCode": "@Test\n    public void acceptIfNeverApplied() throws Exception {\n        final Farm farm = FkFarm.props();\n        final People people = new People(farm).bootstrap();\n        final String uid = \"yegor256\";\n        people.touch(uid);\n        final Request req = new RqWithUser(\n            farm,\n            new RqFake(\"POST\", \"/join-post\"),\n            uid\n        );\n        people.breakup(uid);\n        MatcherAssert.assertThat(\n            new TkApp(farm).act(\n                new RqWithBody(\n                    req,\n                    // @checkstyle LineLength (1 line)\n                    \"personality=INTJ-A&stackoverflow=187241&telegram=123&about=txt\"\n                )\n            ),\n            Matchers.allOf(\n                new HmRsStatus(HttpURLConnection.HTTP_SEE_OTHER),\n                new HmRsHeader(\"Location\", \"/\")\n            )\n        );\n    }", "LocalizedBug": "final Farm farm = new PropsFarm(new FkFarm());", "LocalizedPatchLength": 46, "CodeLength": 878}
{"BuggyCode": "private Expression parseTildeExpression() {\n        tokens.consume(TILDE);\n        int major = intOf(tokens.consume(NUMERIC).lexeme);\n        if (!tokens.positiveLookahead(DOT)) {\n            return new GreaterOrEqual(versionOf(major, 0, 0));\n        }\n        tokens.consume(DOT);\n        int minor = intOf(tokens.consume(NUMERIC).lexeme);\n        if (!tokens.positiveLookahead(DOT)) {\n            return new And(\n                new GreaterOrEqual(versionOf(major, minor, 0)),\n                new Less(versionOf(major + 1, 0, 0))\n            );\n        }\n        tokens.consume(DOT);\n        int patch = intOf(tokens.consume(NUMERIC).lexeme);\n        return new And(\n            new GreaterOrEqual(versionOf(major, minor, patch)),\n            new Less(versionOf(major, minor + 1, 0))\n        );\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `ExpressionParser.tokens.consume(__new_array(com.github.zafarkhaja.semver.expr.Lexer$Token$Type*[_*_]))` could be null and is dereferenced at line 228."}, "FixedCode": "private Expression parseTildeExpression() {\n        consumeNextToken(TILDE);\n        int major = intOf(consumeNextToken(NUMERIC).lexeme);\n        if (!tokens.positiveLookahead(DOT)) {\n            return new GreaterOrEqual(versionOf(major, 0, 0));\n        }\n        consumeNextToken(DOT);\n        int minor = intOf(consumeNextToken(NUMERIC).lexeme);\n        if (!tokens.positiveLookahead(DOT)) {\n            return new And(\n                new GreaterOrEqual(versionOf(major, minor, 0)),\n                new Less(versionOf(major + 1, 0, 0))\n            );\n        }\n        consumeNextToken(DOT);\n        int patch = intOf(consumeNextToken(NUMERIC).lexeme);\n        return new And(\n            new GreaterOrEqual(versionOf(major, minor, patch)),\n            new Less(versionOf(major, minor + 1, 0))\n        );\n    }", "LocalizedBug": "tokens.consume(TILDE);\nint major = intOf(tokens.consume(NUMERIC).lexeme);\ntokens.consume(DOT);\nint minor = intOf(tokens.consume(NUMERIC).lexeme);\ntokens.consume(DOT);\nint patch = intOf(tokens.consume(NUMERIC).lexeme);", "LocalizedPatchLength": 217, "CodeLength": 802}
{"BuggyCode": "private void populateReadWriteMaps() {\n        // Although the field names say \"PerSec\" this is the Raw Data from which\n        // the associated fields are populated in the Formatted Data class, so\n        // in fact this is the data we want\n        Map<String, List<String>> vals = WmiUtil.selectStringsFrom(null, \"Win32_PerfRawData_PerfDisk_PhysicalDisk\",\n                \"Name,DiskReadBytesPerSec,DiskWriteBytesPerSec\", null);\n        for (int i = 0; i < vals.get(\"Name\").size(); i++) {\n            String index = vals.get(\"Name\").get(i).split(\"\\\\s+\")[0];\n            readMap.put(index, ParseUtil.parseLongOrDefault(vals.get(\"DiskReadBytesPerSec\").get(i), 0L));\n            writeMap.put(index, ParseUtil.parseLongOrDefault(vals.get(\"DiskWriteBytesPerSec\").get(i), 0L));\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `vals.get(\"DiskReadBytesPerSec\")` could be null and is dereferenced at line 84."}, "FixedCode": "private void populateReadWriteMaps() {\n        // Although the field names say \"PerSec\" this is the Raw Data from which\n        // the associated fields are populated in the Formatted Data class, so\n        // in fact this is the data we want\n        Map<String, List<Object>> vals = WmiUtil.selectObjectsFrom(null, \"Win32_PerfRawData_PerfDisk_PhysicalDisk\",\n                \"Name,DiskReadsPerSec,DiskReadBytesPerSec,DiskWritesPerSec,DiskWriteBytesPerSec,PercentDiskTime\", null,\n                READ_WRITE_TYPES);\n        for (int i = 0; i < vals.get(\"Name\").size(); i++) {\n            String index = ((String) vals.get(\"Name\").get(i)).split(\"\\\\s+\")[0];\n            readMap.put(index, (long) vals.get(\"DiskReadsPerSec\").get(i));\n            readByteMap.put(index, ParseUtil.parseLongOrDefault((String) vals.get(\"DiskReadBytesPerSec\").get(i), 0L));\n            writeMap.put(index, (long) vals.get(\"DiskWritesPerSec\").get(i));\n            writeByteMap.put(index, ParseUtil.parseLongOrDefault((String) vals.get(\"DiskWriteBytesPerSec\").get(i), 0L));\n            // Units are 100-ns, divide to get ms\n            xferTimeMap.put(index,\n                    ParseUtil.parseLongOrDefault((String) vals.get(\"PercentDiskTime\").get(i), 0L) / 10000L);\n        }\n    }", "LocalizedBug": "Map<String, List<String>> vals = WmiUtil.selectStringsFrom(null, \"Win32_PerfRawData_PerfDisk_PhysicalDisk\",", "LocalizedPatchLength": 107, "CodeLength": 789}
{"BuggyCode": "@Override\n\tpublic void contextInitialized(ServletContextEvent event) {\n\t\tcheckCDIAvailable();\n\n\t\ttry {\n\t\t\tEagerBeansRepository.getInstance().instantiateApplicationScoped();\n\t\t\tFacesViews.addMappings(event.getServletContext());\n\t\t\tCacheInitializer.loadProviderAndRegisterFilter(event.getServletContext());\n\t\t}\n\t\tcatch (Throwable e) {\n\t\t\tlogger.log(Level.SEVERE, \"OmniFaces failed to initialize! Report an issue to OmniFaces.\", e);\n\t\t\tthrow e;\n\t\t}\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `getInstance()` could be null and is dereferenced at line 59."}, "FixedCode": "@Override\n\tpublic void contextInitialized(ServletContextEvent event) {\n\t\tcheckCDIAvailable();\n\n\t\ttry {\n\t\t\tServletContext servletContext = event.getServletContext();\n\t\t\tEagerBeansRepository.instantiateApplicationScopedAndRegisterListener(servletContext);\n\t\t\tFacesViews.addMappings(servletContext);\n\t\t\tCacheInitializer.loadProviderAndRegisterFilter(servletContext);\n\t\t}\n\t\tcatch (Throwable e) {\n\t\t\tlogger.log(Level.SEVERE, \"OmniFaces failed to initialize! Report an issue to OmniFaces.\", e);\n\t\t\tthrow e;\n\t\t}\n\t}", "LocalizedBug": "EagerBeansRepository.getInstance().instantiateApplicationScoped();\nFacesViews.addMappings(event.getServletContext());\nCacheInitializer.loadProviderAndRegisterFilter(event.getServletContext());", "LocalizedPatchLength": 192, "CodeLength": 448}
{"BuggyCode": "@Override\n    public JsonParser createParser(File f) throws IOException {\n        return _createParser(new FileInputStream(f), _createContext(f, true));\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 157 is not released after line 157.\n**Note**: potential exception at line 157"}, "FixedCode": "@Override\n    public JsonParser createParser(File f) throws IOException {\n        IOContext ctxt = _createContext(f, true);\n        return _createParser(_decorate(new FileInputStream(f), ctxt), ctxt);\n    }", "LocalizedBug": "return _createParser(new FileInputStream(f), _createContext(f, true));", "LocalizedPatchLength": 70, "CodeLength": 158}
{"BuggyCode": "public static void save(File target, Properties p) throws IOException {\n        File parent = target.getParentFile();\n        parent.mkdirs();\n        if (isWindows()) {\n            store(new FileOutputStream(target), p);\n        } else {\n            File tempFile = createTempFile(target.getName(), \".temp\", parent);\n            store(new FileOutputStream(tempFile), p);\n            rename(tempFile, target);\n        }\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 77 is not released after line 77.\n**Note**: potential exception at line 77"}, "FixedCode": "public static void save(File target, Properties p) throws IOException {\n        File parent = target.getParentFile();\n        parent.mkdirs();\n        if (isWindows()) {\n            store(target, p);\n        } else {\n            File tempFile = createTempFile(target.getName(), \".temp\", parent);\n            store(tempFile, p);\n            rename(tempFile, target);\n        }\n    }", "LocalizedBug": "store(new FileOutputStream(target), p);\nstore(new FileOutputStream(tempFile), p);", "LocalizedPatchLength": 81, "CodeLength": 425}
{"BuggyCode": "public static Builder builder(final String profile) {\n    return new Builder(profile);\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.spotify.helios.client.HeliosClient` acquired by call to `TemporaryJobs$Builder(...)` at line 437 is not released after line 437.\n**Note**: potential exception at line 437"}, "FixedCode": "public static Builder builder(final String profile) {\n    return builder(profile, System.getenv());\n  }", "LocalizedBug": "return new Builder(profile);", "LocalizedPatchLength": 28, "CodeLength": 90}
{"BuggyCode": "long removeCount()\n    {\n        return removeCount;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.caffinitas.ohc.linked.OffHeapMap.removeCount` reads without synchronization from `this.org.caffinitas.ohc.linked.OffHeapMap.removeCount`. Potentially races with write in method `OffHeapMap.removeEntry(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "OffHeapMap(OHCacheBuilder builder, long freeCapacity)\n    {\n        this.freeCapacity = freeCapacity;\n\n        this.throwOOME = builder.isThrowOOME();\n\n        this.lock = builder.isUnlocked() ? null : new ReentrantLock();\n\n        int hts = builder.getHashTableSize();\n        if (hts <= 0)\n            hts = 8192;\n        if (hts < 256)\n            hts = 256;\n        table = Table.create((int) Util.roundUpToPowerOf2(hts, MAX_TABLE_SIZE), throwOOME);\n        if (table == null)\n            throw new RuntimeException(\"unable to allocate off-heap memory for segment\");\n\n        float lf = builder.getLoadFactor();\n        if (lf <= .0d)\n            lf = .75f;\n        this.loadFactor = lf;\n        threshold = (long) ((double) table.size() * loadFactor);\n    }", "LocalizedBug": "long removeCount()\n{\nreturn removeCount;", "LocalizedPatchLength": 40, "CodeLength": 58}
{"BuggyCode": "public static RainbowFish readV1(String filename) throws IOException, ClassNotFoundException {\n    FileInputStream fileIn = new FileInputStream(filename);\n    ObjectInputStream objIn = new ObjectInputStream(fileIn);\n    Map<String, String> map = (Map<String, String>) objIn.readObject();\n    objIn.close();\n    fileIn.close();\n    return new RainbowFish(map.get(\"name\"), Integer.parseInt(map.get(\"age\")), Integer.parseInt(map\n        .get(\"lengthMeters\")), Integer.parseInt(map.get(\"weightTons\")));\n  }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.FileInputStream` acquired to `fileIn` by call to `FileInputStream(...)` at line 85 is not released after line 91.\n**Note**: potential exception at line 86"}, "FixedCode": "public static RainbowFish readV1(String filename) throws IOException, ClassNotFoundException {\n    Map<String, String> map = null;\n\n    try (FileInputStream fileIn = new FileInputStream(filename);\n        ObjectInputStream objIn = new ObjectInputStream(fileIn)) {\n      map = (Map<String, String>) objIn.readObject();\n    }\n\n    return new RainbowFish(map.get(\"name\"), Integer.parseInt(map.get(\"age\")), Integer.parseInt(map.get(\"lengthMeters\")),\n        Integer.parseInt(map.get(\"weightTons\")));\n  }", "LocalizedBug": "ObjectInputStream objIn = new ObjectInputStream(fileIn);\nMap<String, String> map = (Map<String, String>) objIn.readObject();\nobjIn.close();\nfileIn.close();", "LocalizedPatchLength": 155, "CodeLength": 502}
{"BuggyCode": "@Test\n    public void mergeNull() {\n        PDDocument destination = new PDDocument();\n        AcroFormsMerger victim = new AcroFormsMerger(AcroFormPolicy.MERGE, destination);\n        assertNotNull(document.getDocumentCatalog().getAcroForm());\n        victim.mergeForm(null, annotationsLookup);\n        assertFalse(victim.hasForm());\n        assertNull(destination.getDocumentCatalog().getAcroForm());\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.sejda.sambox.pdmodel.PDDocument` acquired to `destination` by call to `new()` at line 72 is not released after line 77."}, "FixedCode": "@Test\n    public void mergeNull() {\n        PDDocument destination = new PDDocument();\n        AcroFormsMerger victim = new AcroFormsMerger(AcroFormPolicy.MERGE, destination);\n        assertNotNull(document.getDocumentCatalog().getAcroForm());\n        victim.mergeForm(null, annotationsLookup);\n        assertTrue(victim.getForm().getFields().isEmpty());\n        assertNull(destination.getDocumentCatalog().getAcroForm());\n    }", "LocalizedBug": "assertFalse(victim.hasForm());", "LocalizedPatchLength": 30, "CodeLength": 407}
{"BuggyCode": "protected static String rootPath() {\n        String path = System.getProperty(\"java.io.tmpdir\");\n        String sep = System.getProperty(\"file.separator\");\n\n        if (!path.endsWith(sep)) {\n            path += sep;\n        }\n\n        return path + \"chronicle-jul\";\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `path` last assigned on line 35 could be null and is dereferenced at line 38."}, "FixedCode": "protected static String rootPath() {\n        String path = OS.getTarget();\n        String sep = System.getProperty(\"file.separator\");\n\n        if (!path.endsWith(sep)) {\n            path += sep;\n        }\n\n        return path + \"chronicle-jul\" + Time.uniqueId();\n    }", "LocalizedBug": "String path = System.getProperty(\"java.io.tmpdir\");", "LocalizedPatchLength": 51, "CodeLength": 272}
{"BuggyCode": "@Test\n\tpublic void testAddWorkdaysFromSaturday() {\n\n\t\tCalendar startDate = Calendar.getInstance();\n\t\t// adjust to SATURDAY\n\t\tstartDate.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);\n\t\tSystem.out.println(\"Startdate=\" + startDate.getTime());\n\n\t\t// adjust -1 Workdays -> TUESDAY\n\t\tAssert.assertEquals(Calendar.TUESDAY,\n\t\t\t\tWorkflowSchedulerService.addWorkDays(startDate, 1).get(Calendar.DAY_OF_WEEK));\n\n\t\tAssert.assertEquals(Calendar.FRIDAY,\n\t\t\t\tWorkflowSchedulerService.addWorkDays(startDate, 4).get(Calendar.DAY_OF_WEEK));\n\n\t\t\n\t\tAssert.assertEquals(Calendar.MONDAY,\n\t\t\t\tWorkflowSchedulerService.addWorkDays(startDate, 5).get(Calendar.DAY_OF_WEEK));\n\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `addWorkDays(startDate,4)` could be null and is dereferenced at line 223."}, "FixedCode": "@Test\n\tpublic void testAddWorkdaysFromSaturday() {\n\n\t\tCalendar startDate = Calendar.getInstance();\n\t\t// adjust to SATURDAY\n\t\tstartDate.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);\n\t\tSystem.out.println(\"Startdate=\" + startDate.getTime());\n\n\t\t// adjust -1 Workdays -> TUESDAY\n\t\tAssert.assertEquals(Calendar.TUESDAY,\n\t\t\t\tworkflowSchedulerService.addWorkDays(startDate, 1).get(Calendar.DAY_OF_WEEK));\n\n\t\tAssert.assertEquals(Calendar.FRIDAY,\n\t\t\t\tworkflowSchedulerService.addWorkDays(startDate, 4).get(Calendar.DAY_OF_WEEK));\n\n\t\t\n\t\tAssert.assertEquals(Calendar.MONDAY,\n\t\t\t\tworkflowSchedulerService.addWorkDays(startDate, 5).get(Calendar.DAY_OF_WEEK));\n\n\t}", "LocalizedBug": "WorkflowSchedulerService.addWorkDays(startDate, 1).get(Calendar.DAY_OF_WEEK));\nWorkflowSchedulerService.addWorkDays(startDate, 4).get(Calendar.DAY_OF_WEEK));\nWorkflowSchedulerService.addWorkDays(startDate, 5).get(Calendar.DAY_OF_WEEK));", "LocalizedPatchLength": 236, "CodeLength": 650}
{"BuggyCode": "@Test\n    public void testLineFeedEndings() throws IOException {\n        String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n        CSVParser parser = new CSVParser(new StringReader(code));\n        String[][] data = parser.getRecords();\n        assertEquals(4, data.length);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `data` last assigned on line 410 could be null and is dereferenced at line 411."}, "FixedCode": "@Test\n    public void testLineFeedEndings() throws IOException {\n        String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n        CSVParser parser = new CSVParser(new StringReader(code));\n        List<CSVRecord> records = parser.getRecords();\n        assertEquals(4, records.size());\n    }", "LocalizedBug": "String[][] data = parser.getRecords();\nassertEquals(4, data.length);", "LocalizedPatchLength": 68, "CodeLength": 277}
{"BuggyCode": "@Test\n    public void testCreate() throws Exception {\n        File f1 = newTempraryFile(\"vmf-create-1\");\n        File f2 = newTempraryFile(\"vmf-create-2\");\n\n        VanillaMappedFile vmf1 = new VanillaMappedFile(f1,VanillaMappedMode.RW);\n        VanillaMappedFile vmf2 = new VanillaMappedFile(f2,VanillaMappedMode.RW,128);\n\n        assertTrue(f1.exists());\n        assertTrue(f2.exists());\n\n        assertEquals(  0, vmf1.size());\n        assertEquals(128, vmf2.size());\n\n        vmf1.close();\n        vmf2.close();\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.RandomAccessFile` acquired by call to `VanillaMappedFile(...)` at line 73 is not released after line 84.\n**Note**: potential exception at line 74"}, "FixedCode": "@Test\n    public void testCreate() throws Exception {\n        File f1 = newTempraryFile(\"vmf-create-1\");\n        File f2 = newTempraryFile(\"vmf-create-2\");\n\n        VanillaMappedFile vmf1 = VanillaMappedFile.readWrite(f1);\n        VanillaMappedFile vmf2 = VanillaMappedFile.readWrite(f2,128);\n\n        assertTrue(f1.exists());\n        assertTrue(f2.exists());\n\n        assertEquals(0, vmf1.size());\n        assertEquals(128, vmf2.size());\n\n        vmf1.close();\n        vmf2.close();\n    }", "LocalizedBug": "VanillaMappedFile vmf1 = new VanillaMappedFile(f1,VanillaMappedMode.RW);\nVanillaMappedFile vmf2 = new VanillaMappedFile(f2,VanillaMappedMode.RW,128);", "LocalizedPatchLength": 149, "CodeLength": 521}
{"BuggyCode": "@Override\n    public void addConfigListener(String dataId, ConfigChangeListener listener) {\n        configListenersMap.putIfAbsent(dataId, new ArrayList<>());\n        configChangeNotifiersMap.putIfAbsent(dataId, new ArrayList<>());\n        ConfigChangeNotifier configChangeNotifier = new ConfigChangeNotifier(dataId, listener);\n        configChangeNotifiersMap.get(dataId).add(configChangeNotifier);\n        if (null != listener.getExecutor()) {\n            listener.getExecutor().submit(configChangeNotifier);\n        } else {\n            consulConfigExecutor.submit(configChangeNotifier);\n        }\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `io.seata.config.consul.ConsulConfiguration.addConfigListener` reads without synchronization from `consul.ConsulConfiguration.io.seata.config.consul.ConsulConfiguration.configListenersMap`. Potentially races with write in method `ConsulConfiguration.getInstance()`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "@Override\n    public void addConfigListener(String dataId, ConfigChangeListener listener) {\n        configListenersMap.putIfAbsent(dataId, new ArrayList<>());\n        configChangeNotifiersMap.putIfAbsent(dataId, new ArrayList<>());\n        ConfigChangeNotifier configChangeNotifier = new ConfigChangeNotifier(dataId, listener);\n        configChangeNotifiersMap.get(dataId).add(configChangeNotifier);\n        if (null != listener.getExecutor()) {\n            listener.getExecutor().submit(configChangeNotifier);\n        } else {\n            consulNotifierExecutor.submit(configChangeNotifier);\n        }\n    }", "LocalizedBug": "consulConfigExecutor.submit(configChangeNotifier);", "LocalizedPatchLength": 50, "CodeLength": 606}
{"BuggyCode": "@Override\n    public boolean remove(Object o) {\n        RedisConnection<String, Object> connection = connectionManager.connectionWriteOp();\n        try {\n            return connection.lrem(getName(), 1, o) > 0;\n        } finally {\n            connectionManager.release(connection);\n        }\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `connection.lrem(getName(this),1,o)` could be null and is dereferenced at line 92."}, "FixedCode": "@Override\n    public boolean remove(Object o) {\n        return remove(o, 1);\n    }", "LocalizedBug": "RedisConnection<String, Object> connection = connectionManager.connectionWriteOp();\ntry {\nreturn connection.lrem(getName(), 1, o) > 0;\n} finally {\nconnectionManager.release(connection);\n}", "LocalizedPatchLength": 187, "CodeLength": 297}
{"BuggyCode": "@Test\n    public void testWriteBeyondFileSize() throws Exception {\n        ReadableByteChannel channel = new ReadableByteChannelMock(\n                new String[] {\"a\"}, \"US-ASCII\");\n        HttpParams params = new BasicHttpParams();\n\n        SessionInputBuffer inbuf = new SessionInputBufferImpl(1024, 256, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedDecoder decoder = new LengthDelimitedDecoder(\n                channel, inbuf, metrics, 1);\n\n        File fileHandle = File.createTempFile(\"testFile\", \".txt\");\n\n        RandomAccessFile testfile = new RandomAccessFile(fileHandle, \"rw\");\n        FileChannel fchannel = testfile.getChannel();\n        Assert.assertEquals(0, testfile.length());\n\n        try {\n            decoder.transfer(fchannel, 5, 10);\n            Assert.fail(\"expected IOException\");\n        } catch(IOException iox) {}\n\n        testfile.close();\n        deleteWithCheck(fileHandle);\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `java.io.RandomAccessFile` acquired to `testfile` by call to `RandomAccessFile(...)` at line 400 is not released after line 411.\n**Note**: potential exception at line 402"}, "FixedCode": "@Test\n    public void testWriteBeyondFileSize() throws Exception {\n        ReadableByteChannel channel = new ReadableByteChannelMock(\n                new String[] {\"a\"}, \"US-ASCII\");\n        HttpParams params = new BasicHttpParams();\n\n        SessionInputBuffer inbuf = new SessionInputBufferImpl(1024, 256, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedDecoder decoder = new LengthDelimitedDecoder(\n                channel, inbuf, metrics, 1);\n\n        createTempFile();\n        RandomAccessFile testfile = new RandomAccessFile(this.tmpfile, \"rw\");\n        try {\n            FileChannel fchannel = testfile.getChannel();\n            Assert.assertEquals(0, testfile.length());\n            try {\n                decoder.transfer(fchannel, 5, 10);\n                Assert.fail(\"IOException should have been thrown\");\n            } catch(IOException expected) {\n            }\n        } finally {\n            testfile.close();\n        }\n    }", "LocalizedBug": "File fileHandle = File.createTempFile(\"testFile\", \".txt\");\nRandomAccessFile testfile = new RandomAccessFile(fileHandle, \"rw\");\nAssert.fail(\"expected IOException\");\n} catch(IOException iox) {}\ndeleteWithCheck(fileHandle);", "LocalizedPatchLength": 220, "CodeLength": 972}
{"BuggyCode": "@Test\n    public void testCreateEdgeBetweenVerticesPropertiesEagerlyLoadedOnHasHas() {\n        Vertex person1 = this.sqlgGraph.addVertex(T.label, \"Person\", \"name\", \"john\");\n        Vertex person2 = this.sqlgGraph.addVertex(T.label, \"Person\", \"name\", \"peter\");\n        this.sqlgGraph.tx().commit();\n        person1 = this.sqlgGraph.v(person1.id());\n        person2 = this.sqlgGraph.v(person2.id());\n        person1.addEdge(\"friend\", person2);\n        Assert.assertEquals(\"john\", person1.value(\"name\"));\n        Assert.assertEquals(\"peter\", person2.value(\"name\"));\n        this.sqlgGraph.tx().commit();\n        List<Vertex> vertices = this.sqlgGraph.traversal().V().<Vertex>has(T.label, \"Person\").<Vertex>has(\"name\", \"john\").toList();\n        Assert.assertEquals(1, vertexTraversal(vertices.get(0)).out(\"friend\").count().next().intValue());\n        Assert.assertEquals(1, vertices.size());\n        vertices = this.sqlgGraph.traversal().V().<Vertex>has(T.label, \"Person\").<Vertex>has(\"name\", \"peter\").toList();\n        Assert.assertEquals(1, vertexTraversal(vertices.get(0)).in(\"friend\").count().next().intValue());\n        Assert.assertEquals(1, vertices.size());\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `person1` last assigned on line 52 could be null and is dereferenced at line 54."}, "FixedCode": "@Test\n    public void testCreateEdgeBetweenVerticesPropertiesEagerlyLoadedOnHasHas() {\n        Vertex person1 = this.sqlgGraph.addVertex(T.label, \"Person\", \"name\", \"john\");\n        Vertex person2 = this.sqlgGraph.addVertex(T.label, \"Person\", \"name\", \"peter\");\n        this.sqlgGraph.tx().commit();\n        person1 = this.sqlgGraph.traversal().V(person1.id()).next();\n        person2 = this.sqlgGraph.traversal().V(person2.id()).next();\n        person1.addEdge(\"friend\", person2);\n        Assert.assertEquals(\"john\", person1.value(\"name\"));\n        Assert.assertEquals(\"peter\", person2.value(\"name\"));\n        this.sqlgGraph.tx().commit();\n        List<Vertex> vertices = this.sqlgGraph.traversal().V().<Vertex>has(T.label, \"Person\").<Vertex>has(\"name\", \"john\").toList();\n        Assert.assertEquals(1, vertexTraversal(vertices.get(0)).out(\"friend\").count().next().intValue());\n        Assert.assertEquals(1, vertices.size());\n        vertices = this.sqlgGraph.traversal().V().<Vertex>has(T.label, \"Person\").<Vertex>has(\"name\", \"peter\").toList();\n        Assert.assertEquals(1, vertexTraversal(vertices.get(0)).in(\"friend\").count().next().intValue());\n        Assert.assertEquals(1, vertices.size());\n    }", "LocalizedBug": "person1 = this.sqlgGraph.v(person1.id());\nperson2 = this.sqlgGraph.v(person2.id());", "LocalizedPatchLength": 83, "CodeLength": 1167}
{"BuggyCode": "@Test\n\tpublic void parseXml() {\n\t\tICalParameters params = new ICalParameters();\n\n\t\tElement element = xcalPropertyElement(marshaller, \"<latitude>12.34</latitude><longitude>56.78</longitude>\");\n\t\tResult<Geo> result = marshaller.parseXml(element, params);\n\n\t\tGeo prop = result.getValue();\n\t\tassertEquals(12.34, prop.getLatitude(), 0.001);\n\t\tassertEquals(56.78, prop.getLongitude(), 0.001);\n\t\tassertWarnings(0, result.getWarnings());\n\t}", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `element` last assigned on line 178 could be null and is dereferenced by call to `parseXml(...)` at line 179."}, "FixedCode": "@Test\n\tpublic void parseXml() {\n\t\tResult<Geo> result = parseXCalProperty(\"<latitude>12.34</latitude><longitude>56.78</longitude>\", marshaller);\n\n\t\tGeo prop = result.getValue();\n\t\tassertEquals(12.34, prop.getLatitude(), 0.001);\n\t\tassertEquals(56.78, prop.getLongitude(), 0.001);\n\t\tassertWarnings(0, result.getWarnings());\n\t}", "LocalizedBug": "ICalParameters params = new ICalParameters();\nElement element = xcalPropertyElement(marshaller, \"<latitude>12.34</latitude><longitude>56.78</longitude>\");\nResult<Geo> result = marshaller.parseXml(element, params);", "LocalizedPatchLength": 213, "CodeLength": 432}
{"BuggyCode": "@Test\n    public void rendersHtmlAwardsPageForFirefox() throws Exception {\n        final Farm farm = new PropsFarm(new FkFarm());\n        final String user = \"yegor256\";\n        final int points = 1234;\n        new Awards(farm, user).bootstrap()\n            .add(new FkProject(), points, \"none\", \"reason\");\n        final String html = new View(\n            farm, String.format(\"/u/%s/awards\", user)\n        ).html();\n        MatcherAssert.assertThat(\n            html,\n            XhtmlMatchers.hasXPaths(\"//xhtml:html\")\n        );\n        MatcherAssert.assertThat(\n            html,\n            Matchers.containsString(String.format(\"+%d\", points))\n        );\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.zerocracy.FkFarm` acquired by call to `FkFarm()` at line 53 is not released after line 60."}, "FixedCode": "@Test\n    public void rendersHtmlAwardsPageForFirefox() throws Exception {\n        final Farm farm = FkFarm.props();\n        final String user = \"yegor256\";\n        final int points = 1234;\n        new Awards(farm, user).bootstrap()\n            .add(new FkProject(), points, \"none\", \"reason\");\n        final String html = new View(\n            farm, String.format(\"/u/%s/awards\", user)\n        ).html();\n        MatcherAssert.assertThat(\n            html,\n            XhtmlMatchers.hasXPaths(\"//xhtml:html\")\n        );\n        MatcherAssert.assertThat(\n            html,\n            Matchers.containsString(String.format(\"+%d\", points))\n        );\n    }", "LocalizedBug": "final Farm farm = new PropsFarm(new FkFarm());", "LocalizedPatchLength": 46, "CodeLength": 666}
{"BuggyCode": "private Tuple createTuple(String value)\n    {\n        byte[] bytes = value.getBytes(UTF_8);\n        Slice slice = Slices.allocate(bytes.length + SIZE_OF_SHORT);\n        slice.output()\n                .appendShort(bytes.length + 2)\n                .appendBytes(bytes);\n\n        return new Tuple(slice, new TupleInfo(VARIABLE_BINARY));\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `com.facebook.presto.BasicSliceOutput` acquired by call to `output()` at line 59 is not released after line 61."}, "FixedCode": "private Tuple createTuple(String value)\n    {\n        TupleInfo tupleInfo = new TupleInfo(VARIABLE_BINARY);\n        Tuple tuple = tupleInfo.builder()\n                .append(Slices.wrappedBuffer(value.getBytes(UTF_8)))\n                .build();\n\n        return tuple;\n    }", "LocalizedBug": "byte[] bytes = value.getBytes(UTF_8);\nSlice slice = Slices.allocate(bytes.length + SIZE_OF_SHORT);\nslice.output()\n.appendShort(bytes.length + 2)\n.appendBytes(bytes);\nreturn new Tuple(slice, new TupleInfo(VARIABLE_BINARY));", "LocalizedPatchLength": 222, "CodeLength": 339}
{"BuggyCode": "@Test\n    public void testNextElementSiblings() {\n        Document doc = Jsoup.parse(\"<li id='a'>a</li>\" +\n            \"<li id='b'>b</li>\" +\n            \"<li id='c'>c</li>\");\n        Element element = doc.getElementById(\"a\");\n        List<Element> elementSiblings = element.nextElementSiblings();\n        assertNotNull(elementSiblings);\n        assertEquals(2, elementSiblings.size());\n\n        Element element1 = doc.getElementById(\"c\");\n        List<Element> elementSiblings1 = element1.nextElementSiblings();\n        assertNull(elementSiblings1);\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `elementSiblings` last assigned on line 1333 could be null and is dereferenced at line 1335."}, "FixedCode": "@Test\n    public void testNextElementSiblings() {\n        Document doc = Jsoup.parse(\"<ul id='ul'>\" +\n            \"<li id='a'>a</li>\" +\n            \"<li id='b'>b</li>\" +\n            \"<li id='c'>c</li>\" +\n            \"</ul>\" +\n            \"<div id='div'>\" +\n            \"<li id='d'>d</li>\" +\n            \"</div>\");\n\n        Element element = doc.getElementById(\"a\");\n        List<Element> elementSiblings = element.nextElementSiblings();\n        assertNotNull(elementSiblings);\n        assertEquals(2, elementSiblings.size());\n        assertEquals(\"b\", elementSiblings.get(0).id());\n        assertEquals(\"c\", elementSiblings.get(1).id());\n\n        Element element1 = doc.getElementById(\"b\");\n        List<Element> elementSiblings1 = element1.nextElementSiblings();\n        assertNotNull(elementSiblings1);\n        assertEquals(1, elementSiblings1.size());\n        assertEquals(\"c\", elementSiblings1.get(0).id());\n\n        Element element2 = doc.getElementById(\"c\");\n        List<Element> elementSiblings2 = element2.nextElementSiblings();\n        assertEquals(0, elementSiblings2.size());\n\n        Element ul = doc.getElementById(\"ul\");\n        List<Element> elementSiblings3 = ul.nextElementSiblings();\n        assertNotNull(elementSiblings3);\n        assertEquals(1, elementSiblings3.size());\n        assertEquals(\"div\", elementSiblings3.get(0).id());\n\n        Element div = doc.getElementById(\"div\");\n        List<Element> elementSiblings4 = div.nextElementSiblings();\n        try {\n            Element elementSibling = elementSiblings4.get(0);\n            fail(\"This element should has no next siblings\");\n        } catch (IndexOutOfBoundsException e) {\n        }\n    }", "LocalizedBug": "List<Element> elementSiblings1 = element1.nextElementSiblings();\nassertNull(elementSiblings1);", "LocalizedPatchLength": 94, "CodeLength": 555}
{"BuggyCode": "public void disconnect() throws InterruptedException,\n\t\t\tServiceLocatorException {\n\t\tdisconnect(true, false);\n\t}", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `org.talend.esb.locator.ServiceLocator.disconnect` indirectly reads with synchronization from `this.org.talend.esb.locator.ServiceLocator.businessOperations`. Potentially races with unsynchronized write in method `ServiceLocator.unregister(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public void disconnect() throws InterruptedException,\n\t\t\tServiceLocatorException {\n\t\ttry {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (LOG.isLoggable(Level.FINE)) {\n\t\t\t\t\tLOG.log(Level.FINE, \"Start disconnect session\");\n\t\t\t\t}\n\n\t\t\t\tblockedByRunUpOperation = true;\n\n\t\t\t\tdisconnect(false);\n\n\t\t\t\tblockedByRunUpOperation = false;\n\n\t\t\t\tif (LOG.isLoggable(Level.FINER)) {\n\t\t\t\t\tLOG.log(Level.FINER, \"End disconnect session\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\tblockedByRunUpOperation = false;\n\t\t\tthrow e;\n\t\t} catch (ServiceLocatorException e) {\n\t\t\tblockedByRunUpOperation = false;\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tblockedByRunUpOperation = false;\n\t\t\tif (LOG.isLoggable(Level.SEVERE)) {\n\t\t\t\tLOG.log(Level.SEVERE, \"Connect not passed: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\n\t}", "LocalizedBug": "disconnect(true, false);", "LocalizedPatchLength": 24, "CodeLength": 112}
{"BuggyCode": "public String getAuthor() throws IOException, ParseException {\n        if (author != null) {\n            return author;\n        }\n        if (url == null)\n            throw new IOException(\"URL needs to be present\");\n\n        return info(url).get(\"author\").toString();\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `info(this,Submission.url).get(\"author\")` could be null and is dereferenced at line 216."}, "FixedCode": "public String getAuthor() {\n        return author;\n    }", "LocalizedBug": "public String getAuthor() throws IOException, ParseException {\nif (author != null) {\nif (url == null)\nthrow new IOException(\"URL needs to be present\");\nreturn info(url).get(\"author\").toString();\n}", "LocalizedPatchLength": 196, "CodeLength": 274}
{"BuggyCode": "public static RankManager getInstance() {\n        if (instance == null) {\n            new RankManager();\n        }\n        return instance;\n    }", "BugInfo": {"bug_type": "THREAD_SAFETY_VIOLATION", "qualifier": "Read/Write race. Non-private method `net.dzikoysk.funnyguilds.basic.rank.RankManager.getInstance` reads without synchronization from `rank.RankManager.net.dzikoysk.funnyguilds.basic.rank.RankManager.instance`. Potentially races with write in method `RankManager.remove(...)`.\n Reporting because another access to the same memory occurs on a background thread, although this access may not."}, "FixedCode": "public static RankManager getInstance() {\n        return INSTANCE;\n    }", "LocalizedBug": "if (instance == null) {\nnew RankManager();\nreturn instance;\n}", "LocalizedPatchLength": 61, "CodeLength": 145}
{"BuggyCode": "void doPublish(Request req) {\n        Q q = getQ(req.name);\n        if (q.blCurrentPut == null) {\n            q.setCurrentPut();\n        }\n        int index = q.publish(req);\n        req.longValue = index;\n        req.response = Boolean.TRUE;\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object `q` last assigned on line 1168 could be null and is dereferenced at line 1169."}, "FixedCode": "void syncForDead(Address addressDead) {\n        MemberImpl member = getNextMemberBeforeSync(addressDead, true, 1);\n        if (DEBUG) {\n            log(addressDead + \" is dead and its backup was \" + member);\n        }\n        Address addressNewOwner = (member == null) ? thisAddress : member.getAddress();\n\n        Collection<Q> queues = mapQueues.values();\n        for (Q q : queues) {\n            List<Block> lsBlocks = q.lsBlocks;\n            for (Block block : lsBlocks) {\n                if (block.address.equals(addressDead)) {\n                    // set the new owner\n                    block.address = addressNewOwner;\n                    block.resetAddIndex();\n                    if (lsMembers.size() > 1) {\n                        if (addressNewOwner.equals(thisAddress)) {\n                            // I am the new owner so backup to next member\n                            int indexUpto = block.size() - 1;\n                            if (DEBUG) {\n                                log(\"IndexUpto \" + indexUpto);\n                            }\n                            if (indexUpto > -1) {\n                                executeLocally(new BlockBackupSyncRunner(new BlockBackupSync(q, block,\n                                        indexUpto)));\n                            }\n                        }\n                    }\n                } else if (block.address.equals(thisAddress)) {\n                    // If I am/was the owner of this block\n                    // did my backup change..\n                    // if so backup to the new next\n                    if (lsMembers.size() > 1) {\n                        MemberImpl memberBackupWas = getNextMemberBeforeSync(thisAddress, true, 1);\n                        if (memberBackupWas == null\n                                || memberBackupWas.getAddress().equals(addressDead)) {\n                            int indexUpto = block.size() - 1;\n                            if (indexUpto > -1) {\n                                executeLocally(new BlockBackupSyncRunner(new BlockBackupSync(q, block,\n                                        indexUpto)));\n                            }\n                        }\n                    }\n                }\n            }\n            // packetalidate the dead member's scheduled actions\n            List<ScheduledPollAction> scheduledPollActions = q.lsScheduledPollActions;\n            for (ScheduledPollAction scheduledAction : scheduledPollActions) {\n                if (addressDead.equals(scheduledAction.request.caller)) {\n                    scheduledAction.setValid(false);\n                    ClusterManager.get().deregisterScheduledAction(scheduledAction);\n                }\n            }\n            List<ScheduledOfferAction> scheduledOfferActions = q.lsScheduledOfferActions;\n            for (ScheduledOfferAction scheduledAction : scheduledOfferActions) {\n                if (addressDead.equals(scheduledAction.request.caller)) {\n                    scheduledAction.setValid(false);\n                    ClusterManager.get().deregisterScheduledAction(scheduledAction);\n                }\n            }\n        }\n        doResetBlockSizes();\n    }", "LocalizedBug": "void doPublish(Request req) {\nQ q = getQ(req.name);\nif (q.blCurrentPut == null) {\nq.setCurrentPut();\n}\nint index = q.publish(req);\nreq.longValue = index;\nreq.response = Boolean.TRUE;\n}", "LocalizedPatchLength": 184, "CodeLength": 248}
{"BuggyCode": "public final short getClock() {\n        return totalClock;\n    }", "BugInfo": {"bug_type": "UNSAFE_GUARDED_BY_ACCESS", "qualifier": "The field `hivemall.mix.store.PartialResult.totalClock` is annotated with `@GuardedBy(\"lock()\")`, but the lock `lock()` is not held during the access to the field at line 56. Since the current method is non-private, it can be called from outside the current class without synchronization. Consider wrapping the access in a `synchronized(lock())` block or making the method private."}, "FixedCode": "public final short getClock() {\n        return globalClock;\n    }", "LocalizedBug": "return totalClock;", "LocalizedPatchLength": 18, "CodeLength": 64}
{"BuggyCode": "public double created() throws IOException, ParseException {\n        return Double.parseDouble(info().get(\"created\").toString());\n    }", "BugInfo": {"bug_type": "NULL_DEREFERENCE", "qualifier": "object returned by `info(this)` could be null and is dereferenced at line 124."}, "FixedCode": "public double created() throws IOException, ParseException {\n        return Double.parseDouble(getUserInformation().get(\"created\").toString());\n    }", "LocalizedBug": "return Double.parseDouble(info().get(\"created\").toString());", "LocalizedPatchLength": 60, "CodeLength": 135}
{"BuggyCode": "@Test\n    public void testNextToken3Escaping() throws IOException {\n        /* file: a,\\,,b\n        *       \\,,\n        */\n        final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n        final CSVFormat format = CSVFormat.newBuilder().withEscape('\\\\').withIgnoreEmptyLines(false).build();\n        assertTrue(format.isEscaping());\n        final Lexer parser = getLexer(code, format);\n\n        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n        assertTokenEquals(TOKEN, \",\", parser.nextToken(new Token()));\n        assertTokenEquals(EORECORD, \"b\\\\\", parser.nextToken(new Token()));\n        assertTokenEquals(TOKEN, \",\", parser.nextToken(new Token()));\n        assertTokenEquals(TOKEN, \"\\nc\", parser.nextToken(new Token()));\n        assertTokenEquals(EORECORD, \"d\\r\", parser.nextToken(new Token()));\n        assertTokenEquals(EOF, \"e\", parser.nextToken(new Token()));\n    }", "BugInfo": {"bug_type": "RESOURCE_LEAK", "qualifier": "resource of type `org.apache.commons.csv.ExtendedBufferedReader` acquired by call to `getLexer(...)` at line 198 is not released after line 206."}, "FixedCode": "@Test\n    public void testNextToken3Escaping() throws IOException {\n        /* file: a,\\,,b\n        *       \\,,\n        */\n        final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n        final CSVFormat format = formatWithEscaping.toBuilder().withIgnoreEmptyLines(false).build();\n        assertTrue(format.isEscaping());\n        final Lexer parser = getLexer(code, format);\n\n        assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n        assertTokenEquals(TOKEN, \",\", parser.nextToken(new Token()));\n        assertTokenEquals(EORECORD, \"b\\\\\", parser.nextToken(new Token()));\n        assertTokenEquals(TOKEN, \",\", parser.nextToken(new Token()));\n        assertTokenEquals(TOKEN, \"\\nc\", parser.nextToken(new Token()));\n        assertTokenEquals(EORECORD, \"d\\r\", parser.nextToken(new Token()));\n        assertTokenEquals(EOF, \"e\", parser.nextToken(new Token()));\n    }", "LocalizedBug": "final CSVFormat format = CSVFormat.newBuilder().withEscape('\\\\').withIgnoreEmptyLines(false).build();", "LocalizedPatchLength": 101, "CodeLength": 896}
